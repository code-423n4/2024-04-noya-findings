

## Summary

### Medium Risk Issues

| |Issue|Instances|
|-|:-|:-:|
| [[M001](#m001---centralization-risk-for-trusted-owners)] | Centralization risk for trusted owners | 28 |
| [[M002](#m002---some-erc20-revert-on-zero-value-transfer)] | Some ERC20 revert on zero value transfer | 6 |
| [[M003](#m003---chainlink-oracle-will-return-the-wrong-price-if-the-aggregator-hits-minanswer)] | Chainlink oracle will return the wrong price if the aggregator hits minAnswer | 1 |
| [[M004](#m004---nft-minting-can-allow-json-injection)] | NFT minting can allow JSON Injection | 1 |
| [[M005](#m005---no-way-to-retrieve-eth-from-the-contract)] | No way to retrieve ETH from the contract | 2 |
| [[M006](#m006---large-transfers-may-not-work-with-some-erc20-tokens)] | Large transfers may not work with some ERC20 tokens | 4 |

Total: 42 instances over 6 issues


### Low Risk Issues

| |Issue|Instances|
|-|:-|:-:|
| [[L001](#l001---consider-the-case-where-totalsupply-is-0)] | Consider the case where `totalsupply` is 0 | 12 |
| [[L002](#l002---abiencodepacked-should-not-be-used-with-dynamic-types-when-passing-the-result-to-a-hash-function-such-as-keccak256)] | `abi.encodePacked()` should not be used with dynamic types when passing the result to a hash function such as `keccak256()` | 2 |
| [[L003](#l003---loss-of-precision-due-to-division-by-large-numbers)] | Loss of precision due to division by large numbers | 8 |
| [[L004](#l004---array-lengths-not-checked)] | Array lengths not checked | 9 |
| [[L005](#l005---division-by-zero-not-prevented)] | Division by zero not prevented | 5 |
| [[L006](#l006---missing-checks-for-address0x0-when-assigning-values-to-address-state-variables)] | Missing checks for `address(0x0)` when assigning values to address state variables | 3 |
| [[L007](#l007---use-ownable2step-rather-than-ownable)] | Use `Ownable2Step` rather than `Ownable` | 1 |
| [[L008](#l008---unsafe-downcast)] | Unsafe downcast | 3 |
| [[L009](#l009---arrays-can-grow-in-size-without-a-way-to-shrink-them)] | Arrays can grow in size without a way to shrink them | 1 |
| [[L010](#l010---setters-should-have-initial-value-check)] | Setters should have initial value check | 5 |
| [[L011](#l011---empty-receivepayable-fallback-function-does-not-authorize-requests)] | Empty `receive()`/`payable fallback()` function does not authorize requests | 3 |
| [[L012](#l012---contracts-are-designed-to-receive-eth-but-do-not-implement-function-for-withdrawal)] | Contracts are designed to receive ETH but do not implement function for withdrawal | 3 |
| [[L013](#l013---functions-calling-contractsaddresses-with-transfer-hooks-are-missing-reentrancy-guards)] | Functions calling contracts/addresses with transfer hooks are missing reentrancy guards | 5 |
| [[L014](#l014---constant-decimal-values)] | Constant decimal values | 6 |
| [[L015](#l015---no-limits-when-setting-state-variable-amounts)] | No limits when setting state variable amounts | 7 |
| [[L016](#l016---pausing-withdrawals-is-unfair-to-the-users)] | Pausing withdrawals is unfair to the users | 1 |
| [[L017](#l017---allowed-feesrates-should-be-capped-by-smart-contracts)] | Allowed fees/rates should be capped by smart contracts | 1 |
| [[L018](#l018---double-type-casts-create-complexity-within-the-code)] | Double type casts create complexity within the code | 5 |
| [[L019](#l019---constructorinitialize-function-lacks-parameter-validation)] | constructor/initialize function lacks parameter validation | 6 |
| [[L020](#l020---consider-the-case-where-totalsupply-is-0)] | Consider the case where `totalsupply` is 0 | 12 |
| [[L021](#l021---for-loops-in-public-or-external-functions-should-be-avoided-due-to-high-gas-costs-and-possible-dos)] | For loops in `public` or `external` functions should be avoided due to high gas costs and possible DOS | 15 |
| [[L022](#l022---function-calls-within-for-loops)] | Function calls within for loops | 6 |
| [[L023](#l023---external-calls-in-an-unbounded-for-loop-may-result-in-a-dos)] | External calls in an unbounded for-loop may result in a DoS | 15 |
| [[L024](#l024---contracts-are-not-using-their-oz-upgradeable-counterparts)] | Contracts are not using their OZ Upgradeable counterparts | 22 |
| [[L025](#l025---consider-implementing-two-step-procedure-for-updating-protocol-addresses)] | Consider implementing two-step procedure for updating protocol addresses | 5 |
| [[L026](#l026---decimals-is-not-a-part-of-the-erc-20-standard)] | `decimals()` is not a part of the ERC-20 standard | 1 |
| [[L027](#l027---missing-checks-for-address0x0-in-the-constructor)] | Missing checks for address(0x0) in the constructor | 3 |
| [[L028](#l028---governance-functions-should-be-controlled-by-time-locks)] | Governance functions should be controlled by time locks | 16 |
| [[L029](#l029---missing-checks-for-address0x0-when-updating-address-state-variables)] | Missing checks for address(0x0) when updating address state variables | 5 |
| [[L030](#l030---approvesafeapprove-may-revert-if-the-current-approval-is-not-zero)] | approve()/safeApprove() may revert if the current approval is not zero | 2 |
| [[L031](#l031---unbounded-state-array-which-is-iterated-upon)] | Unbounded state array which is iterated upon | 5 |
| [[L032](#l032---prefer-continue-over-revert-model-in-iteration)] | Prefer continue over revert model in iteration | 6 |
| [[L033](#l033---consider-disallowing-mintingtransfers-to-addressthis)] | Consider disallowing minting/transfers to address(this) | 1 |
| [[L034](#l034---external-calls-in-modifiers-should-be-avoided)] | External calls in modifiers should be avoided | 4 |



### Non-critical Issues

| |Issue|Instances|
|-|:-|:-:|
| [[NC001](#nc001---todo-left-in-the-code)] | TODO Left in the code | 2 |
| [[NC002](#nc002---the-nonreentrant-modifier-should-occur-before-all-other-modifiers)] | The `nonReentrant` `modifier` should occur before all other modifiers | 23 |
| [[NC003](#nc003---requirerevert-statements-should-have-descriptive-reason-strings)] | `require()`/`revert()` statements should have descriptive reason strings | 26 |
| [[NC004](#nc004---constants-should-be-defined-rather-than-using-magic-numbers)] | Constants should be defined rather than using magic numbers | 15 |
| [[NC005](#nc005---use-scientific-notation-eg-1e18-rather-than-exponentiation-eg-1018)] | Use scientific notation (e.g. 1e18) rather than exponentiation (e.g. 10**18) | 1 |
| [[NC006](#nc006---event-is-not-properly-indexed)] | Event is not properly indexed | 13 |
| [[NC007](#nc007---function-ordering-does-not-follow-the-solidity-style-guide)] | Function ordering does not follow the Solidity style guide | 15 |
| [[NC008](#nc008---imports-could-be-organized-more-systematically)] | Imports could be organized more systematically | 27 |
| [[NC009](#nc009---constants-in-comparisons-should-appear-on-the-left-side)] | Constants in comparisons should appear on the left side | 28 |
| [[NC010](#nc010---else-block-not-required)] | else-block not required | 1 |
| [[NC011](#nc011---events-may-be-emitted-out-of-order-due-to-reentrancy)] | Events may be emitted out of order due to reentrancy | 13 |
| [[NC012](#nc012---if-statement-can-be-converted-to-a-ternary)] | If-statement can be converted to a ternary | 1 |
| [[NC013](#nc013---import-declarations-should-import-specific-identifiers-rather-than-the-whole-file)] | Import declarations should import specific identifiers, rather than the whole file | 21 |
| [[NC014](#nc014---adding-a-return-statement-when-the-function-defines-a-named-return-variable-is-redundant)] | Adding a return statement when the function defines a named return variable, is redundant | 2 |
| [[NC015](#nc015---public-functions-not-called-by-the-contract-should-be-declared-external-instead)] | Public functions not called by the contract should be declared external instead | 34 |
| [[NC016](#nc016---multiple-addressid-mappings-can-be-combined-into-a-single-mapping-of-an-addressid-to-a-struct-for-readability)] | Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`, for readability | 5 |
| [[NC017](#nc017---duplicated-requirerevert-checks-should-be-refactored-to-a-modifier-or-function)] | Duplicated `require()`/`revert()` checks should be refactored to a modifier or function | 1 |
| [[NC018](#nc018---variables-need-not-be-initialized-to-zero)] | Variables need not be initialized to zero | 18 |
| [[NC019](#nc019---variable-names-that-consist-of-all-capital-letters-should-be-reserved-for-constantimmutable-variables)] | Variable names that consist of all capital letters should be reserved for constant/immutable variables | 8 |
| [[NC020](#nc020---consider-using-delete-rather-than-assigning-falsezero-to-clear-values)] | Consider using delete rather than assigning false/zero to clear values | 5 |
| [[NC021](#nc021---variable-names-for-constants-are-improperly-named)] | Variable names for `constant`s are improperly named | 1 |
| [[NC022](#nc022---variable-names-for-immutables-should-use-constant_case)] | Variable names for `immutable`s should use CONSTANT_CASE | 3 |
| [[NC023](#nc023---lines-are-too-long)] | Lines are too long | 96 |
| [[NC024](#nc024---file-is-missing-natspec-comments)] | File is missing NatSpec comments | 7 |
| [[NC025](#nc025---function-declarations-should-have-natspec-descriptions)] | Function declarations should have NatSpec descriptions | 40 |
| [[NC026](#nc026---contract-declarations-should-have-notice-tags)] | Contract declarations should have `@notice` tags | 39 |
| [[NC027](#nc027---invalid-natspec-comment-style)] | Invalid NatSpec comment style | 2 |
| [[NC028](#nc028---error-declarations-should-have-natspec-descriptions)] | Error declarations should have NatSpec descriptions | 7 |
| [[NC029](#nc029---contract-does-not-follow-the-solidity-style-guides-suggested-layout-ordering)] | Contract does not follow the Solidity style guide's suggested layout ordering | 2 |
| [[NC030](#nc030---non-externalpublic-variable-names-should-begin-with-an-underscore)] | Non-external/public variable names should begin with an underscore | 8 |
| [[NC031](#nc031---consider-disabling-renounceownership)] | Consider disabling `renounceOwnership()` | 3 |
| [[NC032](#nc032---not-using-the-named-return-variables-anywhere-in-the-function-is-confusing)] | Not using the named return variables anywhere in the function is confusing | 16 |
| [[NC033](#nc033---unused-arguments-in-override-functions)] | Unused arguments in override functions | 4 |
| [[NC034](#nc034---expressions-for-constant-values-such-as-a-call-to-keccak256-should-use-immutable-rather-than-constant)] | Expressions for constant values such as a call to `keccak256()`, should use `immutable` rather than `constant` | 2 |
| [[NC035](#nc035---empty-function-body---consider-commenting-why)] | Empty Function Body - Consider commenting why | 1 |
| [[NC036](#nc036---contracts-should-have-full-test-coverage)] | Contracts should have full test coverage | 1 |
| [[NC037](#nc037---large-or-complicated-code-bases-should-implement-invariant-tests)] | Large or complicated code bases should implement invariant tests | 1 |
| [[NC038](#nc038---consider-using-blocknumber-instead-of-blocktimestamp)] | Consider using `block.number` instead of `block.timestamp` | 7 |
| [[NC039](#nc039---consider-bounding-input-array-length)] | Consider bounding input array length | 12 |
| [[NC040](#nc040---large-numeric-literals-should-use-underscores-for-readability)] | Large numeric literals should use underscores for readability | 2 |
| [[NC041](#nc041---variables-should-be-named-in-mixedcase-style)] | Variables should be named in mixedCase style | 21 |
| [[NC042](#nc042---consider-using-named-mappings)] | Consider using named mappings | 11 |
| [[NC043](#nc043---use-allowlistdenylist-rather-than-whitelistblacklist)] | Use allowlist/denylist rather than whitelist/blacklist | 2 |
| [[NC044](#nc044---function-names-should-use-lowercamelcase)] | Function names should use lowerCamelCase | 26 |
| [[NC045](#nc045---consider-adding-a-deny-list)] | Consider adding a deny-list | 36 |
| [[NC046](#nc046---custom-errors-should-be-used-rather-than-revertrequire)] | Custom errors should be used rather than `revert()`/`require()` | 27 |
| [[NC047](#nc047---top-level-declarations-should-be-separated-by-two-blank-lines)] | Top level declarations should be separated by two blank lines | 10 |
| [[NC048](#nc048---custom-error-has-no-error-details)] | Custom error has no error details | 3 |
| [[NC049](#nc049---contract-uses-both-requirerevert-as-well-as-custom-errors)] | Contract uses both `require()`/`revert()` as well as custom errors | 7 |
| [[NC050](#nc050---consider-moving-msgsender-checks-to-a-common-authorization-modifier)] | Consider moving `msg.sender` checks to a common authorization `modifier` | 2 |
| [[NC051](#nc051---internal-functions-not-called-by-the-contract-should-be-removed)] | `internal` functions not called by the contract should be removed | 1 |
| [[NC052](#nc052---unused-struct-definition)] | Unused `struct` definition | 2 |
| [[NC053](#nc053---unused-error-definition)] | Unused `error` definition | 1 |
| [[NC054](#nc054---events-are-missing-sender-information)] | Events are missing sender information | 21 |
| [[NC055](#nc055---enum-values-should-be-used-in-place-of-constant-array-indexes)] | Enum values should be used in place of constant array indexes | 13 |
| [[NC056](#nc056---zero-as-a-function-argument-should-have-a-descriptive-meaning)] | Zero as a function argument should have a descriptive meaning | 22 |
| [[NC057](#nc057---function-names-should-differ-to-make-the-code-more-readable)] | Function names should differ to make the code more readable | 120 |
| [[NC058](#nc058---it-is-standard-for-all-external-and-public-functions-to-be-override-from-an-interface)] | It is standard for all external and public functions to be override from an interface | 37 |
| [[NC059](#nc059---consider-adding-formal-verification-proofs)] | Consider adding formal verification proofs | 1 |
| [[NC060](#nc060---common-functions-should-be-refactored-to-a-common-base-contract)] | Common functions should be refactored to a common base contract | 4 |
| [[NC061](#nc061---polymorphic-functions-make-security-audits-more-time-consuming-and-error-prone)] | Polymorphic functions make security audits more time-consuming and error-prone | 6 |
| [[NC062](#nc062---event-names-should-use-camelcase)] | Event names should use CamelCase | 1 |
| [[NC063](#nc063---consider-using-accesscontroldefaultadminrules-rather-than-accesscontrol)] | Consider using `AccessControlDefaultAdminRules` rather than `AccessControl` | 1 |
| [[NC064](#nc064---missing-timelock-for-critical-parameter-change)] | Missing timelock for critical parameter change | 5 |
| [[NC065](#nc065---setters-should-prevent-re-setting-of-the-same-value)] | Setters should prevent re-setting of the same value | 9 |
| [[NC066](#nc066---consider-splitting-long-calculations)] | Consider splitting long calculations | 1 |
| [[NC067](#nc067---use-of-override-is-unnecessary)] | Use of override is unnecessary | 49 |
| [[NC068](#nc068---non-externalpublic-function-names-should-begin-with-an-underscore)] | Non-`external`/`public` function names should begin with an underscore | 1 |
| [[NC069](#nc069---unused-import)] | Unused import | 5 |
| [[NC070](#nc070---unused-function-parameter)] | Unused function parameter | 9 |
| [[NC071](#nc071---unsafe-conversion-from-unsigned-to-signed-values)] | Unsafe conversion from unsigned to signed values | 2 |
| [[NC072](#nc072---put-all-system-wide-constants-in-one-file)] | Put all system-wide constants in one file | 29 |
| [[NC073](#nc073---add-inline-comments-for-unnamed-variables)] | Add inline comments for unnamed variables | 13 |
| [[NC074](#nc074---consider-adding-emergency-stop-functionality)] | Consider adding emergency-stop functionality | 6 |
| [[NC075](#nc075---named-imports-of-parent-contracts-are-missing)] | Named imports of parent contracts are missing | 37 |
| [[NC076](#nc076---contract-doesnt-handle-all-nft-types)] | Contract doesn't handle all NFT types | 2 |
| [[NC077](#nc077---use-bytesconcat-on-bytes-instead-of-abiencodepacked-for-clearer-semantic-meaning)] | Use `bytes.concat()` on bytes instead of `abi.encodePacked()` for clearer semantic meaning | 1 |
| [[NC078](#nc078---consider-using-safetransferlibsafetransfereth-or-addresssendvalue-for-clearer-semantic-meaning)] | Consider using `SafeTransferLib.safeTransferETH()` or `Address.sendValue()` for clearer semantic meaning | 2 |
| [[NC079](#nc079---style-guide-state-and-local-variables-should-be-named-using-lowercamelcase)] | Style guide: State and local variables should be named using lowerCamelCase | 40 |
| [[NC080](#nc080---unnecessary-cast)] | Unnecessary cast | 4 |
| [[NC081](#nc081---visibility-should-be-set-explicitly-rather-than-defaulting-to-internal)] | Visibility should be set explicitly rather than defaulting to internal | 8 |
| [[NC082](#nc082---event-declarations-should-have-natspec-param-annotations)] | Event declarations should have NatSpec @param annotations | 25 |
| [[NC083](#nc083---event-declarations-should-have-natspec-dev-annotations)] | Event declarations should have NatSpec @dev annotations | 25 |
| [[NC084](#nc084---function-definitions-should-have-natspec-dev-annotations)] | Function definitions should have NatSpec @dev annotations | 41 |
| [[NC085](#nc085---function-definitions-should-have-natspec-notice-annotations)] | Function definitions should have NatSpec @notice annotations | 40 |
| [[NC086](#nc086---abstract-contract-declarations-should-have-natspec-title-annotations)] | Abstract contract declarations should have NatSpec @title annotations | 1 |
| [[NC087](#nc087---abstract-contract-declarations-should-have-natspec-author-annotations)] | Abstract contract declarations should have NatSpec @author annotations | 1 |
| [[NC088](#nc088---abstract-contract-declarations-should-have-natspec-dev-annotations)] | Abstract contract declarations should have Natspec @dev annotations | 1 |
| [[NC089](#nc089---library-declarations-should-have-natspec-title-annotations)] | Library declarations should have Natspec @title annotations | 1 |
| [[NC090](#nc090---library-declarations-should-have-natspec-author-annotations)] | Library declarations should have Natspec @author annotations | 1 |
| [[NC091](#nc091---library-declarations-should-have-natspec-notice-annotations)] | Library declarations should have Natspec @notice annotations | 1 |
| [[NC092](#nc092---library-declarations-should-have-natspec-dev-annotations)] | Library declarations should have Natspec @dev annotations | 1 |
| [[NC093](#nc093---modifier-definitions-should-have-natspec-notice-annotations)] | Modifier definitions should have Natspec @notice annotations | 7 |
| [[NC094](#nc094---modifier-definitions-should-have-natspec-dev-annotations)] | Modifier definitions should have Natspec @dev annotations | 7 |
| [[NC095](#nc095---contract-definitions-should-have-natspec-title-annotations)] | Contract definitions should have Natspec @title annotations | 35 |
| [[NC096](#nc096---contract-definitions-should-have-natspec-author-annotations)] | Contract definitions should have Natspec @author annotations | 39 |
| [[NC097](#nc097---contract-definitions-should-have-natspec-notice-annotations)] | Contract definitions should have Natspec @notice annotations | 35 |
| [[NC098](#nc098---contract-definitions-should-have-natspec-dev-annotations)] | Contract definitions should have Natspec @dev annotations | 38 |
| [[NC099](#nc099---event-definitions-should-have-natspec-notice-annotations)] | Event definitions should have Natspec @notice annotations | 25 |
| [[NC100](#nc100---state-variable-declarations-should-have-natspec-notice-annotations)] | State variable declarations should have Natspec @notice annotations | 36 |
| [[NC101](#nc101---state-variable-declarations-should-have-natspec-dev-annotations)] | State variable declarations should have Natspec @dev annotations | 36 |
| [[NC102](#nc102---functions-should-have-natspec-return-annotations)] | Functions should have Natspec @return annotations | 31 |
| [[NC103](#nc103---functions-should-have-natspec-param-annotations)] | Functions should have Natspec @param annotations | 40 |
| [[NC104](#nc104---missing-events-in-sensitive-functions)] | Missing events in sensitive functions | 4 |
| [[NC105](#nc105---if-statement-control-structures-do-not-comply-with-best-practices)] | If statement control structures do not comply with best practices | 20 |
| [[NC106](#nc106---a-event-should-be-emitted-if-a-non-immutable-state-variable-is-set-in-a-constructor)] | A event should be emitted if a non immutable state variable is set in a constructor | 26 |
| [[NC107](#nc107---public-state-arrays-should-have-a-getter-to-return-all-elements)] | Public state arrays should have a getter to return all elements | 1 |
| [[NC108](#nc108---it-is-best-practice-to-use-linear-inheritance)] | It is best practice to use linear inheritance | 11 |
| [[NC109](#nc109---use-a-struct-to-encapsulate-multiple-function-parameters)] | Use a struct to encapsulate multiple function parameters | 13 |
| [[NC110](#nc110---avoid-defining-a-function-in-a-single-line-including-its-contents)] | Avoid defining a function in a single line including it's contents | 9 |
| [[NC111](#nc111---empty-bytes-check-is-missing)] | Empty bytes check is missing | 21 |
| [[NC112](#nc112---defining-all-externalpublic-functions-in-contract-interfaces)] | Defining All External/Public Functions in Contract Interfaces | 32 |
| [[NC113](#nc113---avoid-mutating-function-parameters)] | Avoid mutating function parameters | 1 |

Total: 1716 instances over 113 issues


### Gas Optimizations

| |Issue|Instances|Total Gas Saved|
|-|:-|:-|:-:|
| [[G001](#g001---dont-initialize-variables-with-default-value)] | Don't Initialize Variables with Default Value | 58 | - |
| [[G002](#g002---cache-array-length-outside-of-loop)] | Cache Array Length Outside of Loop | 18 | 54 |
| [[G003](#g003---use--0-instead-of--0-for-unsigned-integer-comparison)] | Use != 0 instead of > 0 for Unsigned Integer Comparison | 8 | 24 |
| [[G004](#g004---using-private-rather-than-public-for-constants-saves-gas)] | Using `private` rather than `public` for constants, saves gas | 29 | - |
| [[G005](#g005---long-revert-strings)] | Long Revert Strings | 5 | - |
| [[G006](#g006---use-custom-errors)] | Use Custom Errors | 27 | 783 |
| [[G007](#g007---i-costs-less-gas-than-i-especially-when-its-used-in-for-loops---ii---too)] | ++i costs less gas than i++, especially when it's used in for-loops (--i/i-- too) | 18 | 90 |
| [[G008](#g008---use-assembly-to-check-for-address0)] | Use assembly to check for `address(0)` | 29 | 174 |
| [[G009](#g009---internal-functions-not-called-by-the-contract-should-be-removed-to-save-deployment-gas)] | `internal` functions not called by the contract should be removed to save deployment gas | 3 | - |
| [[G010](#g010---use-calldata-instead-of-memory-for-function-arguments-that-do-not-get-mutated)] | Use calldata instead of memory for function arguments that do not get mutated | 31 | 11160 |
| [[G011](#g011---multiple-addressid-mappings-can-be-combined-into-a-single-mapping-of-an-addressid-to-a-struct-where-appropriate)] | Multiple address/ID mappings can be combined into a single mapping of an address/ID to a struct, where appropriate | 5 | 100210 |
| [[G012](#g012---using-storage-instead-of-memory-for-structsarrays-saves-gas)] | Using storage instead of `memory` for structs/arrays saves gas | 7 | 29400 |
| [[G013](#g013---multiple-accesses-of-a-mappingarray-should-use-a-local-variable-cache)] | Multiple accesses of a mapping/array should use a local variable cache. | 19 | 798 |
| [[G014](#g014---internal-functions-only-called-once-can-be-inlined-to-save-gas)] | Internal functions only called once can be inlined to save gas | 4 | 80 |
| [[G015](#g015---add-unchecked--for-subtractions-where-the-operands-cannot-underflow-because-of-a-previous-require-or-if-statement)] | Add unchecked {} for subtractions where the operands cannot underflow because of a previous require() or if-statement | 1 | 85 |
| [[G016](#g016---optimize-names-to-save-gas)] | Optimize names to save gas | 39 | 858 |
| [[G017](#g017---structs-should-group-like-types-together-to-save-gas)] | Structs should group like types together to save gas | 2 | - |
| [[G018](#g018---the-result-of-function-calls-should-be-cached-rather-than-re-calling-the-function)] | The result of function calls should be cached rather than re-calling the function | 1 | 21 |
| [[G019](#g019---splitting-require-statements-that-use--saves-gas)] | Splitting require() statements that use && saves gas | 2 | 6 |
| [[G020](#g020---stack-variable-used-as-a-cheaper-cache-for-a-state-variable-is-only-used-once)] | Stack variable used as a cheaper cache for a state variable is only used once | 12 | 3216 |
| [[G021](#g021---functions-guaranteed-to-revert-when-called-by-normal-users-can-be-marked-payable)] | Functions guaranteed to revert when called by normal users can be marked payable | 33 | 693 |
| [[G022](#g022---x--y-costs-more-gas-than-x--x--y-for-state-variables)] | `<x> += <y>` costs more gas than `<x> = <x> + <y>` for state variables | 1 | 113 |
| [[G023](#g023---constructors-can-be-marked-payable)] | Constructors can be marked payable | 39 | 819 |
| [[G024](#g024---remove-unused-local-variables)] | Remove unused local variables | 5 | - |
| [[G025](#g025---use-solidity-version-0820-or-above-to-improve-gas-performance)] | Use solidity version 0.8.20 or above to improve gas performance | 41 | 41000 |
| [[G026](#g026---use-assembly-to-emit-events)] | Use assembly to emit events | 27 | - |
| [[G027](#g027---comparing-to-constant-boolean)] | Comparing to constant boolean | 3 | - |
| [[G028](#g028---dont-compare-boolean-expressions-to-boolean-literals)] | Don't compare boolean expressions to boolean literals | 3 | - |
| [[G029](#g029---state-variables-only-set-in-the-constructor-should-be-declared-immutable)] | State variables only set in the constructor should be declared `immutable` | 22 | 440000 |
| [[G030](#g030---use-uint2561uint2562-instead-for-true-and-false-boolean-states)] | Use `uint256(1)`/`uint256(2)` instead for `true` and `false` boolean states | 3 | 51300 |
| [[G031](#g031---fewer-storage-slots-can-be-used-by-storing-timestamps-in-types-smaller-than-uint256)] | Fewer storage slots can be used by storing timestamps in types smaller than uint256 | 1 | - |
| [[G032](#g032---superfluous-event-fields)] | Superfluous event fields | 2 | - |
| [[G033](#g033---ii-should-be-uncheckediuncheckedi-when-it-is-not-possible-for-them-to-overflow-as-is-the-case-when-used-in-for--and-while-loops)] | `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops | 19 | 1140 |
| [[G034](#g034---usage-of-uintsints-smaller-than-32-bytes-256-bits-incurs-overhead)] | Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead | 4 | 40 |
| [[G035](#g035---consider-activating-via-ir-for-deploying)] | Consider activating `via-ir` for deploying | 1 | - |
| [[G036](#g036---emit-used-in-loop)] | Emit Used In Loop | 6 | - |
| [[G037](#g037---calling-external-function-with-this-keyword)] | Calling External Function With this Keyword | 2 | - |
| [[G038](#g038---unchecked--can-be-used-on-the-division-of-two-uints-in-order-to-save-gas)] | `unchecked {}` can be used on the division of two `uints` in order to save gas | 11 | - |
| [[G039](#g039---low-level-call-can-be-optimized-with-assembly)] | Low level call can be optimized with assembly | 4 | - |
| [[G040](#g040---use-assembly-to-calculate-hashes-to-save-gas)] | Use assembly to calculate hashes to save gas | 4 | 320 |
| [[G041](#g041---unused-named-return-variables-without-optimizer-waste-gas)] | Unused named return variables without optimizer waste gas | 16 | - |
| [[G042](#g042---avoid-updating-storage-when-the-value-hasnt-changed)] | Avoid updating storage when the value hasn't changed | 9 | 26100 |
| [[G043](#g043---duplicated-requirerevert-checks-should-be-refactored-to-a-modifier-or-function)] | Duplicated `require()`/`revert()` checks should be refactored to a modifier or function | 1 | - |
| [[G044](#g044---the-use-of-a-logical-and-in-place-of-double-if-is-slightly-less-gas-efficient-in-instances-where-there-isnt-a-corresponding-else-statement-for-the-given-if-statement)] | The use of a logical AND in place of double if is slightly less gas efficient in instances where there isn't a corresponding else statement for the given if statement | 12 | - |
| [[G045](#g045---use-the-inputsresults-of-assignments-rather-than-re-reading-state-variables)] | Use the inputs/results of assignments rather than re-reading state variables | 14 | - |
| [[G046](#g046---avoid-fetching-a-low-level-calls-return-data-by-using-assembly)] | Avoid fetching a low-level call's return data by using assembly | 4 | - |
| [[G047](#g047---using-msg-globals-directly-rather-than-caching-the-value-saves-gas)] | Using msg globals directly, rather than caching the value, saves gas | 4 | - |
| [[G048](#g048---state-variable-read-in-a-loop)] | State variable read in a loop | 6 | - |
| [[G049](#g049---storage-re-read-via-storage-pointer)] | Storage re-read via storage pointer | 1 | - |
| [[G050](#g050---state-variables-only-set-in-their-definitions-should-be-declared-constant)] | State variables only set in their definitions should be declared constant | 28 | - |
| [[G051](#g051---state-variables-only-set-in-the-constructor-should-be-declared-immutable)] | State variables only set in the constructor should be declared immutable | 13 | - |
| [[G052](#g052---state-variables-can-be-packed-into-fewer-storage-slots)] | State variables can be packed into fewer storage slots | 1 | - |
| [[G053](#g053---use-local-variables-for-emitting)] | Use local variables for emitting | 3 | - |


## M001 - Centralization risk for trusted owners:

Having a single EOA as the only owner of contracts is a large centralization risk and a single point of failure. A single private key may be taken in a hack, or the sole holder of the key may become unable to retrieve the key when necessary. Consider changing to a multi-signature setup, or having a role-based authorization model.


<details>
<summary>Click to show 28 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


226         function calculateDepositShares(uint256 maxIterations) public onlyManager nonReentrant whenNotPaused {
259             onlyManager
328         function calculateWithdrawShares(uint256 maxIterations) public onlyManager nonReentrant whenNotPaused {
360         function startCurrentWithdrawGroup() public onlyManager nonReentrant whenNotPaused {
370         function fulfillCurrentWithdrawGroup() public onlyManager nonReentrant whenNotPaused {
396         function executeWithdraw(uint256 maxIterations) public onlyManager nonReentrant whenNotPaused {
453         function resetMiddle(uint256 newMiddle, bool depositOrWithdraw) public onlyManager {
475         function recordProfitForFee() public onlyManager nonReentrant {
505         function collectManagementFees() public onlyManager nonReentrant returns (uint256, uint256) {
526         function collectPerformanceFees() public onlyManager nonReentrant {
548         function retrieveTokensForWithdraw(RetrieveData[] calldata retrieveData) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


23          function withdrawShares(uint256 amount) external onlyOwner {
27          function burnShares(uint256 amount) external onlyOwner {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


46          function supply(address supplyToken, uint256 amount) external onlyManager nonReentrant {
64              onlyManager
81          function repay(address asset, uint256 amount, uint256 i) external onlyManager nonReentrant {
88          function repayWithCollateral(uint256 _amount, uint256 i, address _borrowAsset) external onlyManager {
100         function withdrawCollateral(uint256 _collateralAmount, address _collateral) external onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


53          function supply(DepositData memory data) public onlyManager nonReentrant {
79          function withdraw(WithdrawData memory data) public onlyManager nonReentrant {
100         function stake(address pool, uint256 liquidity) public onlyManager nonReentrant {
106         function unstake(address pool, uint256 liquidity) public onlyManager nonReentrant {
111         function claim(address pool) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


53          function harvestAuraRewards(address[] calldata rewardsPools) public onlyManager nonReentrant {
70          ) public onlyManager nonReentrant {
109         function depositIntoAuraBooster(bytes32 poolId, uint256 _amount) public onlyManager nonReentrant {
115         function decreasePosition(DecreasePositionParams memory p) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


43          function addLiquidityInCamelotPool(CamelotAddLiquidityParams calldata p) external onlyManager nonReentrant {
67              onlyManager


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


29          function supply(address market, address asset, uint256 amount) external onlyManager nonReentrant {
48          function withdrawOrBorrow(address _market, address asset, uint256 amount) external onlyManager nonReentrant {
63          function claimRewards(address rewardContract, address market) external onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


68          function depositIntoGauge(address pool, uint256 amount) public onlyManager nonReentrant {
81          function depositIntoPrisma(address pool, uint256 amount, bool curveOrConvex) public onlyManager nonReentrant {
103         function depositIntoConvexBooster(address pool, uint256 pid, uint256 amount, bool stake) public onlyManager {
119             onlyManager
162             onlyManager
182         function withdrawFromConvexBooster(uint256 pid, uint256 amount) public onlyManager {
192         function withdrawFromConvexRewardPool(address pool, uint256 amount) public onlyManager {
202         function withdrawFromGauge(address pool, uint256 amount) public onlyManager {
212         function withdrawFromPrisma(address depostiToken, uint256 amount) public onlyManager {
221         function harvestRewards(address[] calldata gauges) public onlyManager nonReentrant {
233         function harvestPrismaRewards(address[] calldata pools) public onlyManager nonReentrant {
247         function harvestConvexRewards(address[] calldata rewardsPools) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


30          function deposit(uint256 marketId, uint256 _amount) public onlyManager nonReentrant {
43          function withdraw(uint256 marketId, uint256 _amount) public onlyManager nonReentrant {
60              onlyManager
79              onlyManager
98          function closeBorrowPosition(uint256[] memory marketIds, uint256 accountId) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


40              onlyManager
68          function withdraw(IFraxPair pool, uint256 withdrawAmount) public onlyManager nonReentrant {
87          function repay(IFraxPair pool, uint256 sharesToRepay) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


24          function openAccount(address facade, uint256 ref) public onlyManager {
41          function closeAccount(address facade, address creditAccount) public onlyManager nonReentrant {
68          ) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


37          function deposit(uint256 amountIn) external onlyManager nonReentrant {
51          function requestWithdrawals(uint256 amount) public onlyManager nonReentrant {
69          function claimWithdrawal(uint256 requestId) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


64          function stake(uint256 amount, uint256 duration, bool doDelegation) external onlyManager nonReentrant {
78          function unstake(uint256 lockupId) external onlyManager nonReentrant {
91          function addLiquidityInMaverickPool(MavericAddLiquidityParams calldata p) external onlyManager nonReentrant {
117             onlyManager
137         function claimBoostedPositionRewards(IMaverickReward rewardContract) external onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


35          function supply(uint256 amount, Id id, bool sOrC) external onlyManager nonReentrant {
58          function withdraw(uint256 amount, Id id, bool sOrC) external onlyManager nonReentrant {
80          function borrow(uint256 amount, Id id) external onlyManager nonReentrant {
95          function repay(uint256 amount, Id id) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


31          function sendPositionToMasterChef(uint256 tokenId) external onlyManager nonReentrant {
40          function updatePosition(uint256 tokenId) public onlyManager nonReentrant {
50          function withdraw(uint256 tokenId) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


78          function supply(address market, uint256 amount) external onlyManager nonReentrant {
97          function mintPTAndYT(address market, uint256 syAmount) external onlyManager nonReentrant {
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
126         function depositIntoPenpie(address _market, uint256 _amount) public onlyManager nonReentrant {
137         function withdrawFromPenpie(address _market, uint256 _amount) public onlyManager nonReentrant {
151             onlyManager
168             onlyManager
185             onlyManager
203         function burnLP(IPMarket market, uint256 amount) external onlyManager nonReentrant {
216         function decreasePosition(IPMarket market, uint256 _amount, bool closePosition) external onlyManager nonReentrant {
241         function claimRewards(IPMarket market) external onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


33          function approveZap(IStakeNTroveZap zap, address tm, bool approve) public onlyManager nonReentrant {
54              onlyManager
75          function addColl(IStakeNTroveZap zapContract, address tm, uint256 amountIn) public onlyManager nonReentrant {
104         ) public onlyManager nonReentrant {
129         function closeTrove(IStakeNTroveZap zapContract, address troveManager) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


25          function createAccount() public onlyManager {
30          function deposit(address _token, uint256 _amount, uint128 _accountId) public onlyManager {
46          function withdraw(address _token, uint256 _amount, uint128 _accountId) public onlyManager {
73          ) public onlyManager {
87          ) public onlyManager {
96              onlyManager
108         ) public onlyManager {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


33          function deposit(address siloToken, address dToken, uint256 amount, bool oC) external onlyManager nonReentrant {
54              onlyManager
85          function borrow(address siloToken, address bToken, uint256 amount) external onlyManager nonReentrant {
98          function repay(address siloToken, address rToken, uint256 amount) external onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


49          function depositIntoStargatePool(StargateRequest calldata depositRequest) external onlyManager nonReentrant {
76          function withdrawFromStargatePool(StargateRequest calldata withdrawRequest) external onlyManager nonReentrant {
103         function claimStargateRewards(uint256 poolId) external onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


40          function openPosition(MintParams memory p) external onlyManager nonReentrant returns (uint256 tokenId) {
63          function decreasePosition(DecreaseLiquidityParams memory p) external onlyManager nonReentrant {
87          function increasePosition(IncreaseLiquidityParams memory p) external onlyManager nonReentrant {
101         function collectAllFees(uint256[] memory tokenIds) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


42          function updateOwners(address[] memory _owners, bool[] memory addOrRemove) public onlyOwner {
63          function setThreshold(uint8 _threshold) public onlyOwner {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


127         ) external onlyManager nonReentrant {
153         function updateTokenInRegistry(address token) public onlyManager {
210         ) external onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


40          function setChainInfo(uint256 chainId, uint32 lzChainId, address lzHelperAddress) public onlyOwner {
52          function addVaultInfo(uint256 vaultId, uint256 baseChainId, address omniChainManager) public onlyOwner {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


36          function updateMessageSetting(bytes memory _messageSetting) public onlyOwner {
51          function setChainInfo(uint256 chainId, uint32 lzChainId, address lzHelperAddress) public onlyOwner {
63          function addVaultInfo(uint256 vaultId, uint256 baseChainId, address omniChainManager) public onlyOwner {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


57          function updateBridgeTransactionApproval(bytes32 transactionHash) public onlyManager {
68          function startBridgeTransaction(BridgeRequest memory bridgeRequest) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol


28          function updateTVLInfo() external onlyManager {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


45          function addHandler(address _handler, bool state) external onlyOwner {
55          function addChain(uint256 _chainId, bool state) external onlyOwner {
65          function addBridgeBlacklist(string memory bridgeName, bool state) external onlyOwner {
193         function rescueFunds(address token, address userAddress, uint256 amount) external onlyOwner {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

</details>

## M002 - Some ERC20 revert on zero value transfer:

Example: https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers.


<details>
<summary>Click to show 6 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


156                 IERC20(token).safeTransfer(address(msg.sender), amount);
205             baseToken.safeTransferFrom(msg.sender, address(this), amount);
428                 baseToken.safeTransfer(data.receiver, baseTokenAmount);
439                 baseToken.safeTransfer(withdrawFeeReceiver, withdrawFeeAmount);
688                 IERC20(token).safeTransfer(msg.sender, amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


76                      tokens[i].safeTransfer(receiver, amounts[i]);
91                  tokens[i].safeTransfer(msg.sender, amounts[i]);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


99              IERC20(address(_SY)).safeTransfer(address(_YT), syAmount);
114             IERC20(address(_SY)).safeTransfer(address(market), SYamount);
115             IERC20(address(_PT)).safeTransfer(address(market), PTamount);
189             IERC20(address(_PT)).safeTransfer(address(market), exactPTIn);
204             IERC20(address(market)).safeTransfer(address(market), amount);
221             IERC20(address(SY)).safeTransfer(address(SY), _amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


96                  IERC20(token).safeTransfer(address(accountingManager), newAmount);
99                  IERC20(token).safeTransfer(address(msg.sender), amount);
104                 IERC20(token).safeTransfer(msg.sender, amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


32                  IERC20(token).safeTransfer(msg.sender, amount);
36              IERC20(token).safeTransfer(msg.sender, amountToSend);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


198                 IERC20(token).safeTransfer(userAddress, amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

</details>

## M003 - Chainlink oracle will return the wrong price if the aggregator hits minAnswer:

Chainlink aggregators have a built-in circuit breaker if the price of an asset goes outside of a predetermined price band.The result is that if an asset experiences a huge drop in value (i.e. LUNA crash) the price of the oracle will continueto return the minPrice instead of the actual price of the asset. This would allow users to continue borrowing with theasset but at the wrong price. This is exactly what happened to Venus on BSC when LUNA crashed.Consider adding Min/Max price check.


```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


115         function getValueFromChainlinkFeed(
116             AggregatorV3Interface source,
117             uint256 amountIn,
118             uint256 sourceTokenUnit,
119             bool isInverse
120         ) public view returns (uint256) {
121             int256 price;
122             uint256 updatedAt;
123             (, price,, updatedAt,) = source.latestRoundData();
124             uint256 uintprice = uint256(price);
125             if (block.timestamp - updatedAt > chainlinkPriceAgeThreshold) {
126                 revert NoyaChainlinkOracle_DATA_OUT_OF_DATE();
127             }
128             if (price <= 0) {
129                 revert NoyaChainlinkOracle_PRICE_ORACLE_UNAVAILABLE(address(source), address(0), address(0));
130             }
131             if (isInverse) {
132                 return (amountIn * sourceTokenUnit) / uintprice;
133             }
134             return (amountIn * uintprice) / (sourceTokenUnit);
135         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

## M004 - NFT minting can allow JSON Injection:

Reason: JSON injection in NFT metadata can create various vulnerabilities and manipulation tactics in the NFT ecosystem. The metadata of NFTs, often stored off-chain and referenced by URI, could be manipulated through JSON injection if unsanitized inputs are allowed. This could alter the visual representation of an NFT on platforms and mislead buyers or impact the perceived value of the asset.

Resolution: To protect against JSON injection, the metadata processing system should properly sanitize and validate all inputs. Smart contracts should not handle this task due to their limitations. Instead, robust off-chain server code should manage the processing, using tools designed to prevent JSON injection such as input validation, escaping special characters, and utilizing secure JSON parsing libraries. In addition, implementing strict access control to the metadata storage can further safeguard against unauthorized changes.


```solidity
File: contracts/connectors/SNXConnector.sol


7       contract SNXV3Connector is BaseConnector, IERC721Receiver {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

## M005 - No way to retrieve ETH from the contract:

The following contracts contain at least one payable function, yet the function does not utilise forwarded ETH, and the contract is missing functionality to withdraw ETH from the contract. This means that funds may become trapped in the contract indefinitely.  Consider adding a withdraw/sweep function to contracts that are capable of receiving ether.


```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


19      contract LZHelperSender is OAppSender {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


10      contract SwapAndBridgeHandler is NoyaGovernanceBase, ISwapAndBridgeHandler, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

## M006 - Large transfers may not work with some ERC20 tokens:

Some  IERC20 implementations (e.g UNI, COMP) may fail if the valued transferred is larger than uint96. [Source](https://github.com/d-xo/weird-erc20#revert-on-large-approvals--transfers)


<details>
<summary>Click to show 4 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


156                 IERC20(token).safeTransfer(address(msg.sender), amount);
205             baseToken.safeTransferFrom(msg.sender, address(this), amount);
428                 baseToken.safeTransfer(data.receiver, baseTokenAmount);
439                 baseToken.safeTransfer(withdrawFeeReceiver, withdrawFeeAmount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


99              IERC20(address(_SY)).safeTransfer(address(_YT), syAmount);
114             IERC20(address(_SY)).safeTransfer(address(market), SYamount);
115             IERC20(address(_PT)).safeTransfer(address(market), PTamount);
189             IERC20(address(_PT)).safeTransfer(address(market), exactPTIn);
204             IERC20(address(market)).safeTransfer(address(market), amount);
221             IERC20(address(SY)).safeTransfer(address(SY), _amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


96                  IERC20(token).safeTransfer(address(accountingManager), newAmount);
99                  IERC20(token).safeTransfer(address(msg.sender), amount);
104                 IERC20(token).safeTransfer(msg.sender, amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


32                  IERC20(token).safeTransfer(msg.sender, amount);
36              IERC20(token).safeTransfer(msg.sender, amountToSend);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

</details>

## L001 - Consider the case where `totalsupply` is 0:

Consider the case where `totalSupply` is 0. When `totalSupply` is 0, it should return 0 directly, because there will be an error of dividing by 0.


<details>
<summary>Click to show 12 findings</summary>

```solidity
File: contracts/connectors/AerodromeConnector.sol


uint256 amount0 = balance * reserve0 / totalSupply;

uint256 amount1 = balance * reserve1 / totalSupply;

uint256 amount0 = balance * reserve0 / totalSupply;

uint256 amount1 = balance * reserve1 / totalSupply;

uint256 amount0 = balance * reserve0 / totalSupply;

uint256 amount1 = balance * reserve1 / totalSupply;

uint256 amount0 = balance * reserve0 / totalSupply;

uint256 amount1 = balance * reserve1 / totalSupply;

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L132:132

```solidity
File: contracts/connectors/CamelotConnector.sol


return balanceThis * (_getValue(tokenA, base, reserves0) + _getValue(tokenB, base, reserves1)) / totalSupply;

return balanceThis * (_getValue(tokenA, base, reserves0) + _getValue(tokenB, base, reserves1)) / totalSupply;

return balanceThis * (_getValue(tokenA, base, reserves0) + _getValue(tokenB, base, reserves1)) / totalSupply;

return balanceThis * (_getValue(tokenA, base, reserves0) + _getValue(tokenB, base, reserves1)) / totalSupply;

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L96:96

</details>

## L002 - `abi.encodePacked()` should not be used with dynamic types when passing the result to a hash function such as `keccak256()`:

Use `abi.encode()` instead which will pad items to 32 bytes, which will [prevent hash collisions](https://docs.soliditylang.org/en/v0.8.13/abi-spec.html#non-standard-packed-mode) (e.g. `abi.encodePacked(0x123,0x456)` => `0x123456` => `abi.encodePacked(0x1,0x23456)`, but `abi.encode(0x123,0x456)` => `0x0...1230...456`). Unless there is a compelling reason, `abi.encode` should be preferred. If there is only one argument to `abi.encodePacked()` it can often be cast to `bytes()` or `bytes32()` [instead](https://ethereum.stackexchange.com/questions/30912/how-to-compare-strings-in-solidity#answer-82739). If all arguments are strings and or bytes, `bytes.concat()` should be used instead.


```solidity
File: contracts/connectors/UNIv3Connector.sol


bytes32 key = keccak256(abi.encodePacked(positionManager, tL, tU));

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L136:136

```solidity
File: contracts/governance/Keepers.sol


bytes32 totalHash = keccak256(abi.encodePacked("\x19\x01", _domainSeparatorV4(), txInputHash));

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L102:102

## L003 - Loss of precision due to division by large numbers:

Division by large numbers may result in the result being zero, due to solidity not supporting fractions. Consider requiring a minimum amount for the numerator to ensure that it is always larger than the denominator.


<details>
<summary>Click to show 8 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


416                     data.amount * currentWithdrawGroup.totalABAmount / currentWithdrawGroup.totalCBAmountFullfilled;
423                     uint256 feeAmount = baseTokenAmount * withdrawFee / FEE_PRECISION;
275                     firstTemp, data.receiver, block.timestamp, data.shares, data.amount, data.shares * 1e18 / data.amount
484                 previewDeposit(((storedProfitForFee - totalProfitCalculated) * performanceFee) / FEE_PRECISION);
243                     middleTemp, data.receiver, block.timestamp, shares, data.amount, shares * 1e18 / data.amount
518                 (timePassed * managementFee * (totalShares - currentFeeShares)) / FEE_PRECISION / 365 days;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


131             uint256 amount0 = balance * reserve0 / totalSupply;
132             uint256 amount1 = balance * reserve1 / totalSupply;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


172             return (((1e18 * token1bal * lpBalance) / _weight) / _totalSupply);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


96              return balanceThis * (_getValue(tokenA, base, reserves0) + _getValue(tokenB, base, reserves1)) / totalSupply;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


118                         collateralBalance * collateralPriceInVirtualBase * baseScale / info.scale / basePrice;
78              return getCollBlanace(comet, true) * 1e18 / borrowBalanceInBase;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


136             uint256 currentHF = (fraxlendPairMaxLTV * 1e18) / currentPositionLTV;
129                 (((_borrowerAmount * _exchangeRate) * LTV_PRECISION) / EXCHANGE_PRECISION) / _collateralAmount;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


138             return amount * IOracle(marketOracle).price() / ORACLE_PRICE_SCALE;
115             return market.lltv * convertCToL(p.collateral, market.oracle, market.collateralToken) / borrowAmount;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


132                 return (amountIn * sourceTokenUnit) / uintprice;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

</details>

## L004 - Array lengths not checked:

If the length of the arrays are not required to be of the same length, user operations may not be fully executed due to a mismatch in the number of items iterated over, versus the number of items provided in the second array.


<details>
<summary>Click to show 9 findings</summary>

```solidity
File: contracts/accountingManager/Registry.sol


188         function addConnector(uint256 vaultId, address[] calldata _connectorAddresses, bool[] calldata _enableds)
189             external
190             onlyVaultMaintainer(vaultId)
191             vaultExists(vaultId)
192         {
193             Vault storage vault = vaults[vaultId];
194             for (uint256 i = 0; i < _connectorAddresses.length; i++) {
195                 vault.connectors[_connectorAddresses[i]].enabled = _enableds[i];
196                 emit ConnectorAdded(vaultId, _connectorAddresses[i]);
197             }
198         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


64          function openPosition(
65              bytes32 poolId,
66              uint256[] memory amounts,
67              uint256[] memory amountsWithoutBPT,
68              uint256 minBPT,
69              uint256 auraAmount
70          ) public onlyManager nonReentrant {
71              address[] memory tokens;
72              {
73                  (tokens,,) = IBalancerVault(balancerVault).getPoolTokens(poolId);
74              }
75              address pool = IBalancerVault(balancerVault).getPool(poolId);
76      
77              for (uint256 i = 0; i < tokens.length; i++) {
78                  if (amounts[i] > 0) _approveOperations(tokens[i], balancerVault, amounts[i]);
79              }
80      
81              IBalancerVault(balancerVault).joinPool(
82                  poolId,
83                  address(this), // sender
84                  address(this), // recipient
85                  IBalancerVault.JoinPoolRequest(
86                      tokens,
87                      amounts,
88                      abi.encode(
89                          IBalancerVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,
90                          amountsWithoutBPT, //_noBptAmounts,
91                          minBPT // minimumBPT
92                      ),
93                      false
94                  )
95              );
96              bytes32 positionId = registry.calculatePositionId(address(this), BALANCER_LP_POSITION, abi.encode(poolId));
97              registry.updateHoldingPosition(vaultId, positionId, "", "", false);
98      
99              if (auraAmount > 0) {
100                 (PoolInfo memory _poolInfo,) = _getPoolInfo(poolId);
101     
102                 uint256 amount = IERC20(pool).balanceOf(address(this));
103                 _approveOperations(pool, _poolInfo.auraPoolAddress, amount);
104                 IRewardPool(_poolInfo.auraPoolAddress).deposit(auraAmount, address(this));
105             }
106             emit OpenPosition(poolId, amounts, amountsWithoutBPT, minBPT, auraAmount);
107         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


37          function makeFlashLoan(IERC20[] memory tokens, uint256[] memory amounts, bytes memory userData)
38              external
39              nonReentrant
40          {
41              caller = msg.sender;
42              emit MakeFlashLoan(tokens, amounts);
43              vault.flashLoan(this, tokens, amounts, userData);
44              caller = address(0);
45          }
54          function receiveFlashLoan(
55              IERC20[] memory tokens,
56              uint256[] memory amounts,
57              uint256[] memory feeAmounts,
58              bytes memory userData
59          ) external override {
60              emit ReceiveFlashLoan(tokens, amounts, feeAmounts, userData);
61              require(msg.sender == address(vault));
62              (
63                  uint256 vaultId,
64                  address receiver,
65                  address[] memory destinationConnector,
66                  bytes[] memory callingData,
67                  uint256[] memory gas
68              ) = abi.decode(userData, (uint256, address, address[], bytes[], uint256[]));
69              (,,, address keeperContract,, address emergencyManager) = registry.getGovernanceAddresses(vaultId);
70              if (!(caller == keeperContract)) {
71                  revert Unauthorized(caller);
72              }
73              if (registry.isAnActiveConnector(vaultId, receiver)) {
74                  for (uint256 i = 0; i < tokens.length; i++) {
75                      // send the tokens to the receiver
76                      tokens[i].safeTransfer(receiver, amounts[i]);
77                      amounts[i] = amounts[i] + feeAmounts[i];
78                  }
79                  for (uint256 i = 0; i < destinationConnector.length; i++) {
80                      // execute the transactions
81                      (bool success,) = destinationConnector[i].call{ value: 0, gas: gas[i] }(callingData[i]);
82                      require(success, "BalancerFlashLoan: Flash loan failed");
83                  }
84                  for (uint256 i = 0; i < tokens.length; i++) {
85                      // send the tokens back to this contract
86                      BaseConnector(receiver).sendTokensToTrustedAddress(address(tokens[i]), amounts[i], address(this), "");
87                  }
88              }
89              for (uint256 i = 0; i < tokens.length; i++) {
90                  // send the tokens back to the vault
91                  tokens[i].safeTransfer(msg.sender, amounts[i]);
92                  require(tokens[i].balanceOf(address(this)) == 0, "BalancerFlashLoan: Flash loan extra tokens");
93              }
94          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


42          function updateOwners(address[] memory _owners, bool[] memory addOrRemove) public onlyOwner {
43              uint256 numOwnersTemp = numOwners;
44              for (uint256 i = 0; i < _owners.length; i++) {
45                  if (addOrRemove[i] && !isOwner[_owners[i]]) {
46                      isOwner[_owners[i]] = true;
47                      numOwnersTemp++;
48                  } else if (!addOrRemove[i] && isOwner[_owners[i]]) {
49                      isOwner[_owners[i]] = false;
50                      numOwnersTemp--;
51                  }
52              }
53              require(numOwnersTemp <= 10 && threshold <= numOwnersTemp && threshold > 1);
54              numOwners = numOwnersTemp;
55              emit UpdateOwners(_owners, addOrRemove);
56          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/governance/TimeLock.sol


7           constructor(uint256 minDelay, address[] memory proposers, address[] memory executors, address owner)
8               TimelockController(minDelay, proposers, executors, owner)
9           { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/TimeLock.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


122         function transferPositionToAnotherConnector(
123             address[] memory tokens,
124             uint256[] memory amounts,
125             bytes memory data,
126             address connector
127         ) external onlyManager nonReentrant {
128             emit TransferPositionToConnector(tokens, amounts, connector, data);
129             if (registry.isAnActiveConnector(vaultId, connector)) {
130                 IConnector(connector).addLiquidity(tokens, amounts, data);
131             }
132         }
169         function addLiquidity(address[] memory tokens, uint256[] memory amounts, bytes memory data)
170             external
171             override
172             nonReentrant
173         {
174             if (!registry.isAddressTrusted(vaultId, msg.sender)) {
175                 revert IConnector_InvalidAddress(msg.sender);
176             }
177     
178             for (uint256 i = 0; i < tokens.length; i++) {
179                 // gather all of the tokens
180                 uint256 _balance = IERC20(tokens[i]).balanceOf(address(this));
181                 ITokenTransferCallBack(msg.sender).sendTokensToTrustedAddress(tokens[i], amounts[i], msg.sender, "");
182                 uint256 _balanceAfter = IERC20(tokens[i]).balanceOf(address(this));
183                 if (_balanceAfter < amounts[i] + _balance) {
184                     revert IConnector_InsufficientDepositAmount(_balanceAfter - _balance, amounts[i]);
185                 }
186             }
187             _addLiquidity(tokens, amounts, data); // call the specific implementation if the connector needs to do something after the liquidity is added
188     
189             for (uint256 i = 0; i < tokens.length; i++) {
190                 _updateTokenInRegistry(tokens[i]); // update the token in the registry
191             }
192             emit AddLiquidity(tokens, amounts, data);
193         }
204         function swapHoldings(
205             address[] memory tokensIn,
206             address[] memory tokensOut,
207             uint256[] memory amountsIn,
208             bytes[] memory swapData,
209             uint256[] memory routeIds
210         ) external onlyManager nonReentrant {
211             for (uint256 i = 0; i < tokensIn.length; i++) {
212                 _executeSwap(
213                     SwapRequest(address(this), routeIds[i], amountsIn[i], tokensIn[i], tokensOut[i], swapData[i], true, 0)
214                 );
215                 _updateTokenInRegistry(tokensIn[i]);
216                 _updateTokenInRegistry(tokensOut[i]);
217                 emit SwapHoldings(tokensIn[i], tokensOut[i], amountsIn[i], swapData[i]);
218             }
219         }
267         function _addLiquidity(address[] memory, uint256[] memory, bytes memory) internal virtual returns (bool) {
268             return true;
269         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


40          function addLiquidity(address[] memory tokens, uint256[] memory amounts, bytes memory data) external {
41              for (uint256 i = 0; i < tokens.length; i++) {
42                  // gather all of the tokens
43      
44                  ITokenTransferCallBack(msg.sender).sendTokensToTrustedAddress(tokens[i], amounts[i], msg.sender, "");
45              }
46              for (uint256 i = 0; i < tokens.length; i++) {
47                  _updateTokenInRegistry(tokens[i]); // update the token in the registry
48              }
49          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


37          function updateDefaultPriceSource(address[] calldata baseCurrencies, INoyaValueOracle[] calldata oracles)
38              public
39              onlyMaintainer
40          {
41              for (uint256 i = 0; i < baseCurrencies.length; i++) {
42                  defaultPriceSource[baseCurrencies[i]] = oracles[i];
43              }
44              emit UpdatedDefaultPriceSource(baseCurrencies, oracles);
45          }
51          function updateAssetPriceSource(address[] calldata asset, address[] calldata baseToken, address[] calldata oracle)
52              external
53              onlyMaintainer
54          {
55              for (uint256 i = 0; i < oracle.length; i++) {
56                  priceSource[asset[i]][baseToken[i]] = INoyaValueOracle(oracle[i]);
57              }
58              emit UpdatedAssetPriceSource(asset, baseToken, oracle);
59          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


70          function setAssetSources(address[] calldata assets, address[] calldata baseTokens, address[] calldata sources)
71              external
72              onlyMaintainer
73          {
74              for (uint256 i = 0; i < assets.length; i++) {
75                  assetsSources[assets[i]][baseTokens[i]] = sources[i];
76                  emit AssetSourceUpdated(assets[i], baseTokens[i], sources[i]);
77              }
78          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

</details>

## L005 - Division by zero not prevented:

The divisions below take an input parameter which does not have any zero-value checks, which may lead to the functions reverting when zero is passed.


<details>
<summary>Click to show 5 findings</summary>

```solidity
File: contracts/connectors/AerodromeConnector.sol


131             uint256 amount0 = balance * reserve0 / totalSupply;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


172             return (((1e18 * token1bal * lpBalance) / _weight) / _totalSupply);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


96              return balanceThis * (_getValue(tokenA, base, reserves0) + _getValue(tokenB, base, reserves1)) / totalSupply;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


118                         collateralBalance * collateralPriceInVirtualBase * baseScale / info.scale / basePrice;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


132                 return (amountIn * sourceTokenUnit) / uintprice;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

</details>

## L006 - Missing checks for `address(0x0)` when assigning values to address state variables:

This issue arises when an address state variable is assigned a value without a preceding check to ensure it isn't address(0x0). This can lead to unexpected behavior as address(0x0) often represents an uninitialized address.


```solidity
File: contracts/accountingManager/Registry.sol


86              flashLoan = _flashLoan;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


59              swapHandler = SwapAndBridgeHandler(_swapHandler);
68              valueOracle = INoyaValueOracle(_valueOracle);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


49              valueOracle = INoyaValueOracle(_valueOracle);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

## L007 - Use `Ownable2Step` rather than `Ownable`:

`Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from mistakenly being transferred to an address that cannot handle it (e.g. due to a typo in the address), by requiring that the recipient of the owner permissions actively accept via a contract call of its own.


```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


7       contract NoyaFeeReceiver is Ownable {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

## L008 - Unsafe downcast:

When a type is downcast to a smaller type, the higher order bits are truncated, effectively applying a modulo to the original value. Without any other checks, this wrapping will lead to unexpected behavior and bugs.


```solidity
File: contracts/connectors/CurveConnector.sol


169             ICurveSwap(poolInfo.pool).remove_liquidity_one_coin(amount, int128(uint128(withdrawIndex)), minAmount);
302             int128 tokenIndex = int128(uint128(index));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


90                  _accountId, uint128(poolIds[poolIndex]), collateralType, newCollateralAmountD18, leverage


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


61              uint128 amountIn128 = uint128(amount);
81              int24 timeWeightedAverageTick = int24(tickCumulativesDelta / int56(int32(period)));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

## L009 - Arrays can grow in size without a way to shrink them:

Array entries are added but are never removed. Consider whether this should be the case, or whether there should be a maximum, or whether old entries should be removed. Consider adding a `pop` function to remove entries.


```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


149                 routes.push(_routes[i]);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

## L010 - Setters should have initial value check:

Setters should have initial value check to prevent assigning wrong value to the variable. Assginment of wrong value can lead to unexpected behavior of the contract.


<details>
<summary>Click to show 5 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


667         function setDepositLimits(uint256 _depositLimitPerTransaction, uint256 _depositTotalAmount) public onlyMaintainer {
668             depositLimitPerTransaction = _depositLimitPerTransaction;
669             depositLimitTotalAmount = _depositTotalAmount;
670             emit SetDepositLimits(_depositLimitPerTransaction, _depositTotalAmount);
671         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


84          function setFlashLoanAddress(address _flashLoan) external onlyRole(MAINTAINER_ROLE) {
85              emit updateFlashloanAddress(_flashLoan, flashLoan);
86              flashLoan = _flashLoan;
87          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


48          function setValueOracle(address _valueOracle) external onlyMaintainerOrEmergency {
49              valueOracle = INoyaValueOracle(_valueOracle);
50              emit SetValueOracle(_valueOracle);
51          }
57          function setGeneralSlippageTolerance(uint256 _slippageTolerance) external onlyMaintainerOrEmergency {
58              genericSlippageTolerance = _slippageTolerance;
59              emit SetSlippageTolerance(address(0), address(0), _slippageTolerance);
60          }
68          function setSlippageTolerance(address _inputToken, address _outputToken, uint256 _slippageTolerance)
69              external
70              onlyMaintainerOrEmergency
71          {
72              slippageTolerance[_inputToken][_outputToken] = _slippageTolerance;
73              emit SetSlippageTolerance(_inputToken, _outputToken, _slippageTolerance);
74          }
158         function setEnableRoute(uint256 _routeId, bool enable) external onlyMaintainerOrEmergency {
159             routes[_routeId].isEnabled = enable;
160             emit RouteUpdate(_routeId, false);
161         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


185         function _setAllowance(IERC20 token, address spender, uint256 amount) internal {
186             token.forceApprove(spender, amount);
187         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


70          function setAssetSources(address[] calldata assets, address[] calldata baseTokens, address[] calldata sources)
71              external
72              onlyMaintainer
73          {
74              for (uint256 i = 0; i < assets.length; i++) {
75                  assetsSources[assets[i]][baseTokens[i]] = sources[i];
76                  emit AssetSourceUpdated(assets[i], baseTokens[i], sources[i]);
77              }
78          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

</details>

## L011 - Empty `receive()`/`payable fallback()` function does not authorize requests:

If the intention is for the Ether to be used, the function should call another function, otherwise it should revert (e.g. `require(msg.sender == address(weth))`). Having no access control on the function means that someone may send Ether to the contract, and have no way to get anything back out, which is a loss of funds. If the concern is having to spend a small amount of gas to check the sender against an immutable address, the code should at least have a function to rescue unused Ether.


```solidity
File: contracts/connectors/LidoConnector.sol


89          receive() external payable { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


56          receive() external payable { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


27          receive() external payable { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

## L012 - Contracts are designed to receive ETH but do not implement function for withdrawal:

The following contracts can receive ETH but can not withdraw, ETH is occasionally sent by users will be stuck in those contracts. This functionality also applies to baseTokens resulting in locked tokens and loss of funds.


```solidity
File: contracts/connectors/LidoConnector.sol


89          receive() external payable { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


56          receive() external payable { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


27          receive() external payable { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

## L013 - Functions calling contracts/addresses with transfer hooks are missing reentrancy guards:

Even if the function follows the best practice of check-effects-interaction, not using a reentrancy guard when there may be transfer hooks to unknown or untrusted ERC20 tokens will open the users of this protocol up to [read-only reentrancies](https://chainsecurity.com/curve-lp-oracle-manipulation-post-mortem/) with no way to protect against it, except by block-listing the whole protocol.


<details>
<summary>Click to show 5 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


156                 IERC20(token).safeTransfer(address(msg.sender), amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


76                      tokens[i].safeTransfer(receiver, amounts[i]);
91                  tokens[i].safeTransfer(msg.sender, amounts[i]);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


96                  IERC20(token).safeTransfer(address(accountingManager), newAmount);
104                 IERC20(token).safeTransfer(msg.sender, amount);
99                  IERC20(token).safeTransfer(address(msg.sender), amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


32                  IERC20(token).safeTransfer(msg.sender, amount);
36              IERC20(token).safeTransfer(msg.sender, amountToSend);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


198                 IERC20(token).safeTransfer(userAddress, amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

</details>

## L014 - Constant decimal values:

The use of fixed decimal values such as 1e18 or 1e8 in Solidity contracts can lead to inaccuracies, bugs, and vulnerabilities, particularly when interacting with tokens having different decimal configurations. Not all ERC20 tokens follow the standard 18 decimal places, and assumptions about decimal places can lead to miscalculations. Always retrieve and use the decimals() function from the token contract itself when performing calculations involving token amounts.


<details>
<summary>Click to show 6 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


243                     middleTemp, data.receiver, block.timestamp, shares, data.amount, shares * 1e18 / data.amount
275                     firstTemp, data.receiver, block.timestamp, data.shares, data.amount, data.shares * 1e18 / data.amount


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


172             return (((1e18 * token1bal * lpBalance) / _weight) / _totalSupply);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


78              return getCollBlanace(comet, true) * 1e18 / borrowBalanceInBase;
119                     if (riskAdjusted) CollValue += collateralValueInVirtualBase * info.liquidateCollateralFactor / 1e18;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


136             uint256 currentHF = (fraxlendPairMaxLTV * 1e18) / currentPositionLTV;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


271                     SYAmount += lpBalance * IPMarket(market).getLpToAssetRate(10) / 1e18;
275                 if (PTAmount > 0) SYAmount += PTAmount * IPMarket(market).getPtToAssetRate(10) / 1e18;
280                 if (SYAmount > 0) underlyingBalance += SYAmount * _SY.exchangeRate() / 1e18;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


124                 totalDepositAmount += depositAmount * price / 1e18;
125                 totalBAmount += borrowAmount * price / 1e18;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

</details>

## L015 - No limits when setting state variable amounts:

It is important to ensure state variables numbers are set to a reasonable value.


<details>
<summary>Click to show 7 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


536             totalProfitCalculated = storedProfitForFee;
668             depositLimitPerTransaction = _depositLimitPerTransaction;
669             depositLimitTotalAmount = _depositTotalAmount;
674             depositWaitingTime = _depositWaitingTime;
679             withdrawWaitingTime = _withdrawWaitingTime;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


380                 vaults[vaultId].holdingPositions[positionIndex].positionTimestamp = positionTimestamp;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/governance/NoyaGovernanceBase.sol


24              vaultId = _vaultId;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


36              minimumHealthFactor = MINIMUM_HEALTH_FACTOR;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


24              vaultId = _vaultId;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


22              DUST_LEVEL = dl;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


58              genericSlippageTolerance = _slippageTolerance;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

</details>

## L016 - Pausing withdrawals is unfair to the users:

Users should always have the possibility of accessing their own funds, but when these functions are paused, their funds will be locked until the contracts are unpaused.


```solidity
File: contracts/accountingManager/AccountingManager.sol


304         function withdraw(uint256 share, address receiver) public nonReentrant whenNotPaused {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

## L017 - Allowed fees/rates should be capped by smart contracts:

Fees/rates should be required to be below 100%, preferably at a much lower limit, to ensure users don't have to monitor the blockchain for changes prior to using the protocol.


```solidity
File: contracts/accountingManager/AccountingManager.sol


135         function setFeeReceivers(
136             address _withdrawFeeReceiver,
137             address _performanceFeeReceiver,
138             address _managementFeeReceiver
139         ) public onlyMaintainer {
140             require(_withdrawFeeReceiver != address(0));
141             require(_performanceFeeReceiver != address(0));
142             require(_managementFeeReceiver != address(0));
143             withdrawFeeReceiver = _withdrawFeeReceiver;
144             performanceFeeReceiver = _performanceFeeReceiver;
145             managementFeeReceiver = _managementFeeReceiver;
146             emit FeeRecepientsChanged(_withdrawFeeReceiver, _performanceFeeReceiver, _managementFeeReceiver);
147         }
170         function setFees(uint256 _withdrawFee, uint256 _performanceFee, uint256 _managementFee) public onlyMaintainer {
171             if (
172                 _withdrawFee > WITHDRAWAL_MAX_FEE || _performanceFee > PERFORMANCE_MAX_FEE
173                     || _managementFee > MANAGEMENT_MAX_FEE
174             ) {
175                 revert NoyaAccounting_INVALID_FEE();
176             }
177             withdrawFee = _withdrawFee;
178             performanceFee = _performanceFee;
179             managementFee = _managementFee;
180             emit FeeRatesChanged(_withdrawFee, _performanceFee, _managementFee);
181         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

## L018 - Double type casts create complexity within the code:

Double type casting should be avoided in Solidity contracts to prevent unintended consequences and ensure accurate data representation. Performing multiple type casts in succession can lead to unexpected truncation, rounding errors, or loss of precision, potentially compromising the contract's functionality and reliability. Furthermore, double type casting can make the code less readable and harder to maintain, increasing the likelihood of errors and misunderstandings during development and debugging. To ensure precise and consistent data handling, developers should use appropriate data types and avoid unnecessary or excessive type casting, promoting a more robust and dependable contract execution.


<details>
<summary>Click to show 5 findings</summary>

```solidity
File: contracts/connectors/CompoundConnector.sol


uint256 principalInBase = uint256(uint104(userBasic.principal));

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L101:101

```solidity
File: contracts/connectors/CurveConnector.sol


ICurveSwap(poolInfo.pool).remove_liquidity_one_coin(amount, int128(uint128(withdrawIndex)), minAmount);

int128 tokenIndex = int128(uint128(index));

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L302:302

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


int24 timeWeightedAverageTick = int24(tickCumulativesDelta / int56(int32(period)));

if (tickCumulativesDelta < 0 && (tickCumulativesDelta % int56(int32(period)) != 0)) {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L82:82

</details>

## L019 - constructor/initialize function lacks parameter validation:

In Solidity, when values are being assigned in constructors to unsigned or integer variables, it's crucial to ensure the provided values adhere to the protocol's specific operational boundaries as laid out in the project specifications and documentation. If the constructors lack appropriate validation checks, there's a risk of setting state variables with values that could cause unexpected and potentially detrimental behavior within the contract's operations, violating the intended logic of the protocol. This can compromise the contract's security and impact the maintainability and reliability of the system. In order to avoid such issues, it is recommended to incorporate rigorous validation checks in constructors. These checks should align with the project's defined rules and constraints, making use of Solidity's built-in require function to enforce these conditions. If the validation checks fail, the require function will cause the transaction to revert, ensuring the integrity and adherence to the protocol's expected behavior.


<details>
<summary>Click to show 6 findings</summary>

```solidity
File: contracts/connectors/UNIv3Connector.sol


27          constructor(address _positionManager, address _factory, BaseConnectorCP memory baseConnectorParams)
28              BaseConnector(baseConnectorParams)
29          {
30              positionManager = INonfungiblePositionManager(_positionManager);
31              factory = IUniswapV3Factory(_factory);
32          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


33          constructor(BaseConnectorCP memory params) NoyaGovernanceBase(params.registry, params.vaultId) {
34              swapHandler = params.swapHandler;
35              valueOracle = params.valueOracle;
36              minimumHealthFactor = MINIMUM_HEALTH_FACTOR;
37          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


22          constructor(address _registry, uint256 _vaultId) {
23              registry = PositionRegistry(_registry);
24              vaultId = _vaultId;
25          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


19          constructor(uint256 dl, address payable _lzHelper, BaseConnectorCP memory baseConnectorParams)
20              OmnichainLogic(_lzHelper, baseConnectorParams)
21          {
22              DUST_LEVEL = dl;
23          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


27          constructor(address swapHandler, address _lifi) Ownable2Step() Ownable(msg.sender) {
28              isHandler[swapHandler] = true;
29              lifi = _lifi;
30          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


31          constructor(address _factory, PositionRegistry _registry) {
32              factory = _factory;
33              registry = _registry;
34          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## L020 - Consider the case where `totalsupply` is 0:

Consider the case where `totalSupply` is 0. When `totalSupply` is 0, it should return 0 directly, because there will be an error of dividing by 0.


<details>
<summary>Click to show 12 findings</summary>

```solidity
File: contracts/connectors/AerodromeConnector.sol


uint256 amount0 = balance * reserve0 / totalSupply;

uint256 amount1 = balance * reserve1 / totalSupply;

uint256 amount0 = balance * reserve0 / totalSupply;

uint256 amount1 = balance * reserve1 / totalSupply;

uint256 amount0 = balance * reserve0 / totalSupply;

uint256 amount1 = balance * reserve1 / totalSupply;

uint256 amount0 = balance * reserve0 / totalSupply;

uint256 amount1 = balance * reserve1 / totalSupply;

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L132:132

```solidity
File: contracts/connectors/CamelotConnector.sol


return balanceThis * (_getValue(tokenA, base, reserves0) + _getValue(tokenB, base, reserves1)) / totalSupply;

return balanceThis * (_getValue(tokenA, base, reserves0) + _getValue(tokenB, base, reserves1)) / totalSupply;

return balanceThis * (_getValue(tokenA, base, reserves0) + _getValue(tokenB, base, reserves1)) / totalSupply;

return balanceThis * (_getValue(tokenA, base, reserves0) + _getValue(tokenB, base, reserves1)) / totalSupply;

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L96:96

</details>

## L021 - For loops in `public` or `external` functions should be avoided due to high gas costs and possible DOS:

In Solidity, for loops can potentially cause Denial of Service (DoS) attacks if not handled carefully. DoS attacks can occur when an attacker intentionally exploits the gas cost of a function, causing it to run out of gas or making it too expensive for other users to call. Below are some scenarios where for loops can lead to DoS attacks: Nested for loops can become exceptionally gas expensive and should be used sparingly.


<details>
<summary>Click to show 15 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


548         function retrieveTokensForWithdraw(RetrieveData[] calldata retrieveData) public onlyManager nonReentrant {
549             uint256 amountAskedForWithdraw_temp = 0;
550             uint256 neededAssets = neededAssetsForWithdraw();
551             for (uint256 i = 0; i < retrieveData.length; i++) {
552                 if (!registry.isAnActiveConnector(vaultId, retrieveData[i].connectorAddress)) {
553                     continue;
554                 }
555                 uint256 balanceBefore = baseToken.balanceOf(address(this));
556                 uint256 amount = IConnector(retrieveData[i].connectorAddress).sendTokensToTrustedAddress(
557                     address(baseToken), retrieveData[i].withdrawAmount, address(this), retrieveData[i].data
558                 );
559                 uint256 balanceAfter = baseToken.balanceOf(address(this));
560                 if (balanceBefore + amount > balanceAfter) revert NoyaAccounting_banalceAfterIsNotEnough();
561                 amountAskedForWithdraw_temp += retrieveData[i].withdrawAmount;
562                 emit RetrieveTokensForWithdraw(
563                     retrieveData[i].withdrawAmount,
564                     retrieveData[i].connectorAddress,
565                     amount,
566                     amountAskedForWithdraw + amountAskedForWithdraw_temp
567                 );
568             }
569             amountAskedForWithdraw += amountAskedForWithdraw_temp;
570             if (amountAskedForWithdraw_temp > neededAssets) {
571                 revert NoyaAccounting_INVALID_AMOUNT();
572             }
573         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


106         function addVault(
107             uint256 vaultId,
108             address _accountingManager,
109             address _baseToken,
110             address _governer,
111             address _maintainer,
112             address _maintainerWithoutTimelock,
113             address _keeperContract,
114             address _watcher,
115             address _emergency,
116             address[] calldata _trustedTokens
117         ) external onlyRole(MAINTAINER_ROLE) {
118             if (vaults[vaultId].accountManager != address(0)) revert AlreadyExists();
119             Vault storage vault = vaults[vaultId];
120             require(_governer != address(0));
121             require(_accountingManager != address(0));
122             require(_baseToken != address(0));
123             require(_maintainer != address(0));
124             require(_keeperContract != address(0));
125             require(_watcher != address(0));
126     
127             vault.accountManager = _accountingManager;
128             vault.baseToken = _baseToken;
129             vault.governer = _governer;
130             vault.maintainer = _maintainer;
131             vault.maintainerWithoutTimeLock = _maintainerWithoutTimelock;
132             vault.keeperContract = _keeperContract;
133             vault.watcherContract = _watcher;
134             vault.emergency = _emergency;
135             // Enable the accounting manager connector so the vault can use the "getValue" function of the accounting manager for calculating the value of tokens
136             vault.connectors[vault.accountManager].enabled = true;
137             vault.enabled = true;
138             for (uint256 i = 0; i < _trustedTokens.length; i++) {
139                 vault.connectors[vault.accountManager].trustedTokens[_trustedTokens[i]] = true;
140             }
141             vault.holdingPositions.push(HoldingPI(address(0), address(0), bytes32(0), "", "", type(uint256).max));
142             emit VaultAdded(vaultId, _accountingManager, _baseToken, _trustedTokens);
143             emit VaultAddressesChanged(
144                 vaultId, _governer, _maintainer, _maintainerWithoutTimelock, _keeperContract, _watcher, _emergency
145             );
146         }
188         function addConnector(uint256 vaultId, address[] calldata _connectorAddresses, bool[] calldata _enableds)
189             external
190             onlyVaultMaintainer(vaultId)
191             vaultExists(vaultId)
192         {
193             Vault storage vault = vaults[vaultId];
194             for (uint256 i = 0; i < _connectorAddresses.length; i++) {
195                 vault.connectors[_connectorAddresses[i]].enabled = _enableds[i];
196                 emit ConnectorAdded(vaultId, _connectorAddresses[i]);
197             }
198         }
207         function updateConnectorTrustedTokens(
208             uint256 vaultId,
209             address _connectorAddress,
210             address[] calldata _tokens,
211             bool trusted
212         ) external onlyVaultMaintainer(vaultId) vaultExists(vaultId) {
213             Vault storage vault = vaults[vaultId];
214             for (uint256 i = 0; i < _tokens.length; i++) {
215                 vault.connectors[_connectorAddress].trustedTokens[_tokens[i]] = trusted;
216             }
217             emit ConnectorTrustedTokensUpdated(vaultId, _connectorAddress, _tokens, trusted);
218         }
238         function addTrustedPosition(
239             uint256 vaultId,
240             uint256 _positionTypeId,
241             address calculatorConnector,
242             bool onlyOwner,
243             bool _isDebt,
244             bytes calldata _data,
245             bytes calldata _additionalData
246         ) external onlyVaultMaintainerWithoutTimeLock(vaultId) vaultExists(vaultId) nonReentrant {
247             Vault storage vault = vaults[vaultId];
248             bytes32 positionId = calculatePositionId(calculatorConnector, _positionTypeId, _data);
249             {
250                 if (vault.trustedPositionsBP[positionId].isEnabled) revert AlreadyExists();
251                 if (vault.connectors[calculatorConnector].enabled == false) revert NotExist();
252                 address[] memory usingTokens = IConnector(calculatorConnector).getUnderlyingTokens(_positionTypeId, _data);
253                 for (uint256 i = 0; i < usingTokens.length; i++) {
254                     if (!isTokenTrusted(vaultId, usingTokens[i], calculatorConnector)) {
255                         revert TokenNotTrusted(usingTokens[i]);
256                     }
257                 }
258     
259                 vault.trustedPositionsBP[positionId] =
260                     PositionBP(calculatorConnector, _positionTypeId, onlyOwner, true, _isDebt, _data, _additionalData);
261             }
262             emit TrustedPositionAdded(vaultId, positionId, calculatorConnector, _positionTypeId, onlyOwner, _isDebt, _data);
263         }
266         function removeTrustedPosition(uint256 vaultId, bytes32 _positionId)
267             external
268             onlyVaultMaintainer(vaultId)
269             vaultExists(vaultId)
270         {
271             Vault storage vault = vaults[vaultId];
272             if (!vault.trustedPositionsBP[_positionId].isEnabled) revert NotExist();
273             uint256 length = vault.holdingPositions.length;
274             for (uint256 i = 0; i < length; i++) {
275                 if (vault.holdingPositions[i].positionId == _positionId) {
276                     revert CannotRemovePosition(vaultId, _positionId);
277                 }
278             }
279             emit TrustedPositionRemoved(vaultId, _positionId);
280             delete vault.trustedPositionsBP[_positionId];
281         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


53          function harvestAuraRewards(address[] calldata rewardsPools) public onlyManager nonReentrant {
54              for (uint256 i = 0; i < rewardsPools.length; i++) {
55                  IRewardPool baseRewardPool = IRewardPool(rewardsPools[i]);
56                  baseRewardPool.getReward();
57              }
58              _updateTokenInRegistry(address(AURA));
59          }
64          function openPosition(
65              bytes32 poolId,
66              uint256[] memory amounts,
67              uint256[] memory amountsWithoutBPT,
68              uint256 minBPT,
69              uint256 auraAmount
70          ) public onlyManager nonReentrant {
71              address[] memory tokens;
72              {
73                  (tokens,,) = IBalancerVault(balancerVault).getPoolTokens(poolId);
74              }
75              address pool = IBalancerVault(balancerVault).getPool(poolId);
76      
77              for (uint256 i = 0; i < tokens.length; i++) {
78                  if (amounts[i] > 0) _approveOperations(tokens[i], balancerVault, amounts[i]);
79              }
80      
81              IBalancerVault(balancerVault).joinPool(
82                  poolId,
83                  address(this), // sender
84                  address(this), // recipient
85                  IBalancerVault.JoinPoolRequest(
86                      tokens,
87                      amounts,
88                      abi.encode(
89                          IBalancerVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,
90                          amountsWithoutBPT, //_noBptAmounts,
91                          minBPT // minimumBPT
92                      ),
93                      false
94                  )
95              );
96              bytes32 positionId = registry.calculatePositionId(address(this), BALANCER_LP_POSITION, abi.encode(poolId));
97              registry.updateHoldingPosition(vaultId, positionId, "", "", false);
98      
99              if (auraAmount > 0) {
100                 (PoolInfo memory _poolInfo,) = _getPoolInfo(poolId);
101     
102                 uint256 amount = IERC20(pool).balanceOf(address(this));
103                 _approveOperations(pool, _poolInfo.auraPoolAddress, amount);
104                 IRewardPool(_poolInfo.auraPoolAddress).deposit(auraAmount, address(this));
105             }
106             emit OpenPosition(poolId, amounts, amountsWithoutBPT, minBPT, auraAmount);
107         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


54          function receiveFlashLoan(
55              IERC20[] memory tokens,
56              uint256[] memory amounts,
57              uint256[] memory feeAmounts,
58              bytes memory userData
59          ) external override {
60              emit ReceiveFlashLoan(tokens, amounts, feeAmounts, userData);
61              require(msg.sender == address(vault));
62              (
63                  uint256 vaultId,
64                  address receiver,
65                  address[] memory destinationConnector,
66                  bytes[] memory callingData,
67                  uint256[] memory gas
68              ) = abi.decode(userData, (uint256, address, address[], bytes[], uint256[]));
69              (,,, address keeperContract,, address emergencyManager) = registry.getGovernanceAddresses(vaultId);
70              if (!(caller == keeperContract)) {
71                  revert Unauthorized(caller);
72              }
73              if (registry.isAnActiveConnector(vaultId, receiver)) {
74                  for (uint256 i = 0; i < tokens.length; i++) {
75                      // send the tokens to the receiver
76                      tokens[i].safeTransfer(receiver, amounts[i]);
77                      amounts[i] = amounts[i] + feeAmounts[i];
78                  }
79                  for (uint256 i = 0; i < destinationConnector.length; i++) {
80                      // execute the transactions
81                      (bool success,) = destinationConnector[i].call{ value: 0, gas: gas[i] }(callingData[i]);
82                      require(success, "BalancerFlashLoan: Flash loan failed");
83                  }
84                  for (uint256 i = 0; i < tokens.length; i++) {
85                      // send the tokens back to this contract
86                      BaseConnector(receiver).sendTokensToTrustedAddress(address(tokens[i]), amounts[i], address(this), "");
87                  }
88              }
89              for (uint256 i = 0; i < tokens.length; i++) {
90                  // send the tokens back to the vault
91                  tokens[i].safeTransfer(msg.sender, amounts[i]);
92                  require(tokens[i].balanceOf(address(this)) == 0, "BalancerFlashLoan: Flash loan extra tokens");
93              }
94          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


221         function harvestRewards(address[] calldata gauges) public onlyManager nonReentrant {
222             for (uint256 i = 0; i < gauges.length; i++) {
223                 IRewardsGauge(gauges[i]).claim_rewards(address(this));
224             }
225             _updateTokenInRegistry(CRV);
226             emit HarvestRewards(gauges);
227         }
233         function harvestPrismaRewards(address[] calldata pools) public onlyManager nonReentrant {
234             for (uint256 i = 0; i < pools.length; i++) {
235                 IDepositToken(pools[i]).claimReward(address(this));
236             }
237             _updateTokenInRegistry(PRISMA);
238             _updateTokenInRegistry(CRV);
239             _updateTokenInRegistry(CVX);
240             emit HarvestPrismaRewards(pools);
241         }
247         function harvestConvexRewards(address[] calldata rewardsPools) public onlyManager nonReentrant {
248             for (uint256 i = 0; i < rewardsPools.length; i++) {
249                 IConvexBasicRewards baseRewardPool = IConvexBasicRewards(rewardsPools[i]);
250                 baseRewardPool.getReward(address(this), true);
251             }
252             _updateTokenInRegistry(CVX);
253             _updateTokenInRegistry(CRV);
254             emit HarvestConvexRewards(rewardsPools);
255         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


62          function executeCommands(
63              address facade,
64              address creditAccount,
65              MultiCall[] calldata calls,
66              address approvalToken,
67              uint256 amount
68          ) public onlyManager nonReentrant {
69              for (uint256 i = 0; i < calls.length; i++) {
70                  if (calls[i].target != facade) revert IConnector_InvalidTarget(calls[i].target);
71                  bytes4 method = bytes4(calls[i].callData[:4]);
72      
73                  if (method == ICreditFacadeV3Multicall.enableToken.selector) {
74                      (address token) = abi.decode(calls[i].callData[4:], (address));
75                      _updateTokenInRegistry(token);
76                  }
77              }
78              if (approvalToken != address(0)) {
79                  _approveOperations(approvalToken, ICreditFacadeV3(facade).creditManager(), amount);
80              }
81              ICreditFacadeV3(facade).multicall(creditAccount, calls);
82              if (approvalToken != address(0)) {
83                  _revokeApproval(approvalToken, ICreditFacadeV3(facade).creditManager());
84              }
85              emit ExecuteCommands(facade, creditAccount, calls, approvalToken, amount);
86          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


137         function claimBoostedPositionRewards(IMaverickReward rewardContract) external onlyManager nonReentrant {
138             IMaverickReward.EarnedInfo[] memory earnedInfo = rewardContract.earned(address(this));
139             uint8 tokenIndex;
140             for (uint256 i = 0; i < earnedInfo.length; i++) {
141                 if (earnedInfo[i].earned != 0) {
142                     tokenIndex = rewardContract.tokenIndex(address(earnedInfo[i].rewardToken));
143                     rewardContract.getReward(address(this), tokenIndex);
144                 }
145             }
146             emit ClaimBoostedPositionRewards(rewardContract);
147         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


241         function claimRewards(IPMarket market) external onlyManager nonReentrant {
242             market.redeemRewards(address(this));
243             address[] memory rewardTokens = market.getRewardTokens();
244             for (uint256 i = 0; i < rewardTokens.length; i++) {
245                 _updateTokenInRegistry(rewardTokens[i]);
246             }
247             emit ClaimRewards(address(market));
248         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


101         function collectAllFees(uint256[] memory tokenIds) public onlyManager nonReentrant {
102             for (uint256 i = 0; i < tokenIds.length; i++) {
103                 (, address token0, address token1) = getCurrentLiquidity(tokenIds[i]);
104                 _collectFees(tokenIds[i]);
105                 _updateTokenInRegistry(token0);
106                 _updateTokenInRegistry(token1);
107                 emit CollectFees(tokenIds[i]);
108             }
109         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


42          function updateOwners(address[] memory _owners, bool[] memory addOrRemove) public onlyOwner {
43              uint256 numOwnersTemp = numOwners;
44              for (uint256 i = 0; i < _owners.length; i++) {
45                  if (addOrRemove[i] && !isOwner[_owners[i]]) {
46                      isOwner[_owners[i]] = true;
47                      numOwnersTemp++;
48                  } else if (!addOrRemove[i] && isOwner[_owners[i]]) {
49                      isOwner[_owners[i]] = false;
50                      numOwnersTemp--;
51                  }
52              }
53              require(numOwnersTemp <= 10 && threshold <= numOwnersTemp && threshold > 1);
54              numOwners = numOwnersTemp;
55              emit UpdateOwners(_owners, addOrRemove);
56          }
84          function execute(
85              address destination,
86              bytes calldata data,
87              uint256 gasLimit,
88              address executor,
89              bytes32[] memory sigR,
90              bytes32[] memory sigS,
91              uint8[] memory sigV,
92              uint256 deadline
93          ) public {
94              require(isOwner[msg.sender], "Not an owner");
95              require(sigR.length == threshold, "Not enough signatures");
96              require(sigR.length == sigS.length && sigR.length == sigV.length, "Lengths do not match");
97              require(executor == msg.sender, "Invalid executor");
98              require(block.timestamp <= deadline, "Transaction expired");
99              {
100                 bytes32 txInputHash =
101                     keccak256(abi.encode(TXTYPE_HASH, nonce, destination, data, gasLimit, executor, deadline));
102                 bytes32 totalHash = keccak256(abi.encodePacked("\x19\x01", _domainSeparatorV4(), txInputHash));
103                 address lastAdd = address(0);
104                 for (uint256 i = 0; i < threshold;) {
105                     address recovered = ECDSA.recover(totalHash, sigV[i], sigR[i], sigS[i]);
106                     require(recovered > lastAdd && isOwner[recovered]);
107                     lastAdd = recovered;
108                     unchecked {
109                         ++i;
110                     }
111                 }
112     
113                 nonce++;
114             }
115             emit Execute(destination, data, gasLimit, executor, deadline);
116             (bool success,) = destination.call{ gas: gasLimit }(data);
117             require(success, "Transaction execution reverted.");
118         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


169         function addLiquidity(address[] memory tokens, uint256[] memory amounts, bytes memory data)
170             external
171             override
172             nonReentrant
173         {
174             if (!registry.isAddressTrusted(vaultId, msg.sender)) {
175                 revert IConnector_InvalidAddress(msg.sender);
176             }
177     
178             for (uint256 i = 0; i < tokens.length; i++) {
179                 // gather all of the tokens
180                 uint256 _balance = IERC20(tokens[i]).balanceOf(address(this));
181                 ITokenTransferCallBack(msg.sender).sendTokensToTrustedAddress(tokens[i], amounts[i], msg.sender, "");
182                 uint256 _balanceAfter = IERC20(tokens[i]).balanceOf(address(this));
183                 if (_balanceAfter < amounts[i] + _balance) {
184                     revert IConnector_InsufficientDepositAmount(_balanceAfter - _balance, amounts[i]);
185                 }
186             }
187             _addLiquidity(tokens, amounts, data); // call the specific implementation if the connector needs to do something after the liquidity is added
188     
189             for (uint256 i = 0; i < tokens.length; i++) {
190                 _updateTokenInRegistry(tokens[i]); // update the token in the registry
191             }
192             emit AddLiquidity(tokens, amounts, data);
193         }
204         function swapHoldings(
205             address[] memory tokensIn,
206             address[] memory tokensOut,
207             uint256[] memory amountsIn,
208             bytes[] memory swapData,
209             uint256[] memory routeIds
210         ) external onlyManager nonReentrant {
211             for (uint256 i = 0; i < tokensIn.length; i++) {
212                 _executeSwap(
213                     SwapRequest(address(this), routeIds[i], amountsIn[i], tokensIn[i], tokensOut[i], swapData[i], true, 0)
214                 );
215                 _updateTokenInRegistry(tokensIn[i]);
216                 _updateTokenInRegistry(tokensOut[i]);
217                 emit SwapHoldings(tokensIn[i], tokensOut[i], amountsIn[i], swapData[i]);
218             }
219         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


40          function addLiquidity(address[] memory tokens, uint256[] memory amounts, bytes memory data) external {
41              for (uint256 i = 0; i < tokens.length; i++) {
42                  // gather all of the tokens
43      
44                  ITokenTransferCallBack(msg.sender).sendTokensToTrustedAddress(tokens[i], amounts[i], msg.sender, "");
45              }
46              for (uint256 i = 0; i < tokens.length; i++) {
47                  _updateTokenInRegistry(tokens[i]); // update the token in the registry
48              }
49          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


147         function addRoutes(RouteData[] memory _routes) public onlyMaintainer {
148             for (uint256 i = 0; i < _routes.length;) {
149                 routes.push(_routes[i]);
150                 emit NewRouteAdded(i, _routes[i].route, _routes[i].isEnabled, _routes[i].isBridge);
151                 unchecked {
152                     i++;
153                 }
154             }
155         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


37          function updateDefaultPriceSource(address[] calldata baseCurrencies, INoyaValueOracle[] calldata oracles)
38              public
39              onlyMaintainer
40          {
41              for (uint256 i = 0; i < baseCurrencies.length; i++) {
42                  defaultPriceSource[baseCurrencies[i]] = oracles[i];
43              }
44              emit UpdatedDefaultPriceSource(baseCurrencies, oracles);
45          }
51          function updateAssetPriceSource(address[] calldata asset, address[] calldata baseToken, address[] calldata oracle)
52              external
53              onlyMaintainer
54          {
55              for (uint256 i = 0; i < oracle.length; i++) {
56                  priceSource[asset[i]][baseToken[i]] = INoyaValueOracle(oracle[i]);
57              }
58              emit UpdatedAssetPriceSource(asset, baseToken, oracle);
59          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


70          function setAssetSources(address[] calldata assets, address[] calldata baseTokens, address[] calldata sources)
71              external
72              onlyMaintainer
73          {
74              for (uint256 i = 0; i < assets.length; i++) {
75                  assetsSources[assets[i]][baseTokens[i]] = sources[i];
76                  emit AssetSourceUpdated(assets[i], baseTokens[i], sources[i]);
77              }
78          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

</details>

## L022 - Function calls within for loops:

Making function calls within loops in Solidity can lead to inefficient gas usage, potential bottlenecks, and increased vulnerability to attacks. Each function call or external call consumes gas, and when executed within a loop, the gas cost multiplies, potentially causing the transaction to run out of gas or exceed block gas limits. This can result in transaction failure or unpredictable behavior.


<details>
<summary>Click to show 6 findings</summary>

```solidity
File: contracts/accountingManager/Registry.sol


253                 for (uint256 i = 0; i < usingTokens.length; i++) {
254                     if (!isTokenTrusted(vaultId, usingTokens[i], calculatorConnector)) {
255                         revert TokenNotTrusted(usingTokens[i]);
256                     }
257                 }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


107             for (uint8 i; i < numberOfAssets; ++i) {
108                 if (isInAsset(assetsIn, i)) {
109                     IComet.AssetInfo memory info = comet.getAssetInfo(i);
110     
111                     // Check if we have a collateral balance.
112                     (uint256 collateralBalance,) = comet.userCollateral(address(this), info.asset);
113     
114                     // Get the value of collateral in virtual base.
115                     uint256 collateralPriceInVirtualBase = comet.getPrice(info.priceFeed);
116     
117                     uint256 collateralValueInVirtualBase =
118                         collateralBalance * collateralPriceInVirtualBase * baseScale / info.scale / basePrice;
119                     if (riskAdjusted) CollValue += collateralValueInVirtualBase * info.liquidateCollateralFactor / 1e18;
120                     else CollValue += collateralValueInVirtualBase;
121                 } // else user collateral is zero.
122             }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


102             for (uint256 i = 0; i < tokenIds.length; i++) {
103                 (, address token0, address token1) = getCurrentLiquidity(tokenIds[i]);
104                 _collectFees(tokenIds[i]);
105                 _updateTokenInRegistry(token0);
106                 _updateTokenInRegistry(token1);
107                 emit CollectFees(tokenIds[i]);
108             }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


211             for (uint256 i = 0; i < tokensIn.length; i++) {
212                 _executeSwap(
213                     SwapRequest(address(this), routeIds[i], amountsIn[i], tokensIn[i], tokensOut[i], swapData[i], true, 0)
214                 );
215                 _updateTokenInRegistry(tokensIn[i]);
216                 _updateTokenInRegistry(tokensOut[i]);
217                 emit SwapHoldings(tokensIn[i], tokensOut[i], amountsIn[i], swapData[i]);
218             }
189             for (uint256 i = 0; i < tokens.length; i++) {
190                 _updateTokenInRegistry(tokens[i]); // update the token in the registry
191             }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


46              for (uint256 i = 0; i < tokens.length; i++) {
47                  _updateTokenInRegistry(tokens[i]); // update the token in the registry
48              }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


88              for (uint256 i = 0; i < sources.length; i++) {
89                  initialValue = _getValue(asset, sources[i], initialValue);
90                  quotingToken = sources[i];
91              }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

</details>

## L023 - External calls in an unbounded for-loop may result in a DoS:

Consider limiting the number of iterations in for-loops that make external calls.


<details>
<summary>Click to show 15 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


551             for (uint256 i = 0; i < retrieveData.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


194             for (uint256 i = 0; i < _connectorAddresses.length; i++) {
253                 for (uint256 i = 0; i < usingTokens.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


54              for (uint256 i = 0; i < rewardsPools.length; i++) {
77              for (uint256 i = 0; i < tokens.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


79                  for (uint256 i = 0; i < destinationConnector.length; i++) {
84                  for (uint256 i = 0; i < tokens.length; i++) {
89              for (uint256 i = 0; i < tokens.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


222             for (uint256 i = 0; i < gauges.length; i++) {
234             for (uint256 i = 0; i < pools.length; i++) {
248             for (uint256 i = 0; i < rewardsPools.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


69              for (uint256 i = 0; i < calls.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


244             for (uint256 i = 0; i < rewardTokens.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


116             for (uint256 i = 0; i < assets.length; i++) {
132             for (uint256 i = 0; i < assetsS.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


102             for (uint256 i = 0; i < tokenIds.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


178             for (uint256 i = 0; i < tokens.length; i++) {
211             for (uint256 i = 0; i < tokensIn.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


41              for (uint256 i = 0; i < tokens.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


148             for (uint256 i = 0; i < _routes.length;) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/TVLHelper.sol


18              for (uint256 i = 0; i < positions.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/TVLHelper.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


55              for (uint256 i = 0; i < oracle.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


74              for (uint256 i = 0; i < assets.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

</details>

## L024 - Contracts are not using their OZ Upgradeable counterparts:

The non-upgradeable standard version of OpenZeppelin’s library is inherited/used by the contracts. It would be safer to use the upgradeable versions of the library contracts to avoid unexpected behavior.

Use the contracts from `@openzeppelin/contracts-upgradeable` instead of `@openzeppelin/contracts` where applicable. See https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/tree/master/contracts for a list of available upgradeable contracts


<details>
<summary>Click to show 22 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


4       import "hottings/node_modules/@openzeppelin/contracts-5.0/utils/ReentrancyGuard.sol";
5       import { ERC4626, ERC20 } from "hottings/node_modules/@openzeppelin/contracts-5.0/token/ERC20/extensions/ERC4626.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


5       import "hottings/node_modules/@openzeppelin/contracts-5.0/access/Ownable.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


4       import "hottings/node_modules/@openzeppelin/contracts-5.0/access/AccessControl.sol";
5       import "hottings/node_modules/@openzeppelin/contracts-5.0/utils/ReentrancyGuard.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


8       import "hottings/node_modules/@openzeppelin/contracts-5.0/utils/ReentrancyGuard.sol";
10      import "hottings/node_modules/@openzeppelin/contracts-5.0/token/ERC20/utils/SafeERC20.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


4       import "hottings/node_modules/@openzeppelin/contracts-5.0/token/ERC20/IERC20.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


4       import "hottings/node_modules/@openzeppelin/contracts-5.0/token/ERC20/IERC20.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


6       import "hottings/node_modules/@openzeppelin/contracts-5.0/token/ERC721/IERC721.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


10      import { SafeERC20 } from "hottings/node_modules/@openzeppelin/contracts-5.0/token/ERC20/utils/SafeERC20.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


4       import { SafeERC20 } from "hottings/node_modules/@openzeppelin/contracts-5.0/token/ERC20/utils/SafeERC20.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


4       import "hottings/node_modules/@openzeppelin/contracts-5.0/utils/cryptography/EIP712.sol";
5       import "hottings/node_modules/@openzeppelin/contracts-5.0/access/Ownable2Step.sol";
6       import "hottings/node_modules/@openzeppelin/contracts-5.0/utils/cryptography/ECDSA.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/governance/TimeLock.sol


4       import "hottings/node_modules/@openzeppelin/contracts-5.0/governance/TimelockController.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/TimeLock.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


8       import "hottings/node_modules/@openzeppelin/contracts-5.0/token/ERC721/utils/ERC721Holder.sol";
12      import "hottings/node_modules/@openzeppelin/contracts-5.0/token/ERC721/IERC721Receiver.sol";
7       import "hottings/node_modules/@openzeppelin/contracts-5.0/token/ERC20/utils/SafeERC20.sol";
13      import "hottings/node_modules/@openzeppelin/contracts-5.0/utils/ReentrancyGuard.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


4       import "hottings/node_modules/@openzeppelin/contracts-5.0/token/ERC20/utils/SafeERC20.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


4       import "hottings/node_modules/@openzeppelin/contracts-5.0/access/Ownable.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


4       import "hottings/node_modules/@openzeppelin/contracts-5.0/access/Ownable.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


6       import "hottings/node_modules/@openzeppelin/contracts-5.0/token/ERC20/utils/SafeERC20.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol


4       import "hottings/node_modules/@openzeppelin/contracts-5.0/token/ERC20/utils/SafeERC20.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


8       import "hottings/node_modules/@openzeppelin/contracts-5.0/utils/ReentrancyGuard.sol";
7       import { SafeERC20, IERC20 } from "hottings/node_modules/@openzeppelin/contracts-5.0/token/ERC20/utils/SafeERC20.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


4       import "hottings/node_modules/@openzeppelin/contracts-5.0/access/Ownable2Step.sol";
8       import "hottings/node_modules/@openzeppelin/contracts-5.0/utils/ReentrancyGuard.sol";
5       import { SafeERC20, IERC20 } from "hottings/node_modules/@openzeppelin/contracts-5.0/token/ERC20/utils/SafeERC20.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


4       import "hottings/node_modules/@openzeppelin/contracts-5.0/access/Ownable.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


8       import "hottings/node_modules/@openzeppelin/contracts-5.0/token/ERC20/extensions/IERC20Metadata.sol";
7       import "hottings/node_modules/@openzeppelin/contracts-5.0/access/Ownable.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


6       import "hottings/node_modules/@openzeppelin/contracts-5.0/access/Ownable.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## L025 - Consider implementing two-step procedure for updating protocol addresses:

Lack of two-step procedure for critical operations leaves them error-prone. Consider adding two step procedure on the critical functions. See similar findings in previous Code4rena contests for reference: https://code4rena.com/reports/2022-06-illuminate/#2-critical-changes-should-use-two-step-procedure


<details>
<summary>Click to show 5 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


135         function setFeeReceivers(


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


84          function setFlashLoanAddress(address _flashLoan) external onlyRole(MAINTAINER_ROLE) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


40          function setChainInfo(uint256 chainId, uint32 lzChainId, address lzHelperAddress) public onlyOwner {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


51          function setChainInfo(uint256 chainId, uint32 lzChainId, address lzHelperAddress) public onlyOwner {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


48          function setValueOracle(address _valueOracle) external onlyMaintainerOrEmergency {
68          function setSlippageTolerance(address _inputToken, address _outputToken, uint256 _slippageTolerance)


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

</details>

## L026 - `decimals()` is not a part of the ERC-20 standard:

The `decimals()` function is not a part of the [ERC-20 standard](https://eips.ethereum.org/EIPS/eip-20), and was added later as an [optional extension](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/IERC20Metadata.sol). As such, some valid ERC20 tokens do not support this interface, so it is unsafe to blindly cast all tokens to this interface, and then call this function.


```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


139             uint256 decimals = IERC20Metadata(token).decimals();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

## L027 - Missing checks for address(0x0) in the constructor:

  


```solidity
File: contracts/accountingManager/Registry.sol


76              flashLoan = _flashLoan;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


29              lifi = _lifi;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


32              factory = _factory;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

## L028 - Governance functions should be controlled by time locks:

Governance functions (such as upgrading contracts, setting critical parameters) should be controlled using time locks to introduce a delay between a proposal and its execution. This gives users time to exit before a potentially dangerous or malicious operation is applied.


<details>
<summary>Click to show 16 findings</summary>

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


23          function withdrawShares(uint256 amount) external onlyOwner {

27          function burnShares(uint256 amount) external onlyOwner {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L27:29

```solidity
File: contracts/accountingManager/Registry.sol


106         function addVault(
107             uint256 vaultId,
108             address _accountingManager,
109             address _baseToken,
110             address _governer,
111             address _maintainer,
112             address _maintainerWithoutTimelock,
113             address _keeperContract,
114             address _watcher,
115             address _emergency,
116             address[] calldata _trustedTokens
117         ) external onlyRole(MAINTAINER_ROLE) {

79          function setMaxNumHoldingPositions(uint256 _maxNumHoldingPositions) external onlyRole(MAINTAINER_ROLE) {

84          function setFlashLoanAddress(address _flashLoan) external onlyRole(MAINTAINER_ROLE) {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L84:87

```solidity
File: contracts/governance/Keepers.sol


63          function setThreshold(uint8 _threshold) public onlyOwner {

42          function updateOwners(address[] memory _owners, bool[] memory addOrRemove) public onlyOwner {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L42:56

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


40          function setChainInfo(uint256 chainId, uint32 lzChainId, address lzHelperAddress) public onlyOwner {

52          function addVaultInfo(uint256 vaultId, uint256 baseChainId, address omniChainManager) public onlyOwner {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L52:55

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


63          function addVaultInfo(uint256 vaultId, uint256 baseChainId, address omniChainManager) public onlyOwner {

51          function setChainInfo(uint256 chainId, uint32 lzChainId, address lzHelperAddress) public onlyOwner {

36          function updateMessageSetting(bytes memory _messageSetting) public onlyOwner {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L36:38

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


193         function rescueFunds(address token, address userAddress, uint256 amount) external onlyOwner {

55          function addChain(uint256 _chainId, bool state) external onlyOwner {

65          function addBridgeBlacklist(string memory bridgeName, bool state) external onlyOwner {

45          function addHandler(address _handler, bool state) external onlyOwner {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L45:48

</details>

## L029 - Missing checks for address(0x0) when updating address state variables:

issing checks for address(0x0) when updating address state variables


<details>
<summary>Click to show 5 findings</summary>

```solidity
File: contracts/accountingManager/Registry.sol


76              flashLoan = _flashLoan;
86              flashLoan = _flashLoan;
174             vaults[vaultId].maintainerWithoutTimeLock = _maintainerWithoutTimelock;
177             vaults[vaultId].emergency = _emergency;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


44              caller = address(0);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


36              lzHelper = _lzHelper;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


29              lifi = _lifi;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


32              factory = _factory;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## L030 - approve()/safeApprove() may revert if the current approval is not zero:

Calling approve() without first calling approve(0) if the current approval is non-zero will revert with some tokens, such as Tether (USDT). While Tether is known to do this, it applies to other tokens as well, which are trying to protect against this attack vector. safeApprove() itself also implements this protection.Always reset the approval to zero before changing it to a new value (SafeERC20.forceApprove() does this for you), or use safeIncreaseAllowance()/safeDecreaseAllowance()


```solidity
File: contracts/connectors/LidoConnector.sol


71              ILidoWithdrawal(lidoWithdrawal).approve(lidoWithdrawal, requestId);
71              ILidoWithdrawal(lidoWithdrawal).approve(lidoWithdrawal, requestId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


121             position.approve(maverickRouter, p.tokenId);
121             position.approve(maverickRouter, p.tokenId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

## L031 - Unbounded state array which is iterated upon:

Iterating over an unbounded state array in Solidity can result in excessive gas consumption, especially if the array size exceeds the block gas limit. This issue commonly arises in tasks like token distribution. To address this, it is recommended to limit array sizes for iteration, consider alternative data structures like linked lists, adopt paginated processing for smaller batches over multiple transactions, or use a 'state array' with a separate index-tracking array to manage large datasets and avoid gas-related problems.


<details>
<summary>Click to show 5 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


604                     depositData[i] = depositQueue.queue[items[i]];
609                     withdrawData[i] = withdrawQueue.queue[items[i]];


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


30                  isOwner[_owners[i]] = true;
45                  if (addOrRemove[i] && !isOwner[_owners[i]]) {
46                      isOwner[_owners[i]] = true;
48                  } else if (!addOrRemove[i] && isOwner[_owners[i]]) {
49                      isOwner[_owners[i]] = false;
106                     require(recovered > lastAdd && isOwner[recovered]);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


38                  isEligibleToUse[usersAddresses[i]] = true;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


42                  defaultPriceSource[baseCurrencies[i]] = oracles[i];
56                  priceSource[asset[i]][baseToken[i]] = INoyaValueOracle(oracle[i]);
56                  priceSource[asset[i]][baseToken[i]] = INoyaValueOracle(oracle[i]);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


75                  assetsSources[assets[i]][baseTokens[i]] = sources[i];
75                  assetsSources[assets[i]][baseTokens[i]] = sources[i];


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

</details>

## L032 - Prefer continue over revert model in iteration:

Preferably, it's better to skip operations on array indices when a condition is not met instead of reverting the entire transaction. Reverting could be exploited by malicious actors who might intentionally introduce array objects failing conditional checks, disrupting group operations. It's advisable to skip array indices rather than revert, unless there are valid security or logic reasons for doing otherwise


<details>
<summary>Click to show 6 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


551             for (uint256 i = 0; i < retrieveData.length; i++) {
552                 if (!registry.isAnActiveConnector(vaultId, retrieveData[i].connectorAddress)) {
553                     continue;
554                 }
555                 uint256 balanceBefore = baseToken.balanceOf(address(this));
556                 uint256 amount = IConnector(retrieveData[i].connectorAddress).sendTokensToTrustedAddress(
557                     address(baseToken), retrieveData[i].withdrawAmount, address(this), retrieveData[i].data
558                 );
559                 uint256 balanceAfter = baseToken.balanceOf(address(this));
560                 if (balanceBefore + amount > balanceAfter) revert NoyaAccounting_banalceAfterIsNotEnough();
561                 amountAskedForWithdraw_temp += retrieveData[i].withdrawAmount;
562                 emit RetrieveTokensForWithdraw(
563                     retrieveData[i].withdrawAmount,
564                     retrieveData[i].connectorAddress,
565                     amount,
566                     amountAskedForWithdraw + amountAskedForWithdraw_temp
567                 );
568             }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


253                 for (uint256 i = 0; i < usingTokens.length; i++) {
254                     if (!isTokenTrusted(vaultId, usingTokens[i], calculatorConnector)) {
255                         revert TokenNotTrusted(usingTokens[i]);
256                     }
257                 }
274             for (uint256 i = 0; i < length; i++) {
275                 if (vault.holdingPositions[i].positionId == _positionId) {
276                     revert CannotRemovePosition(vaultId, _positionId);
277                 }
278             }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


79                  for (uint256 i = 0; i < destinationConnector.length; i++) {
80                      // execute the transactions
81                      (bool success,) = destinationConnector[i].call{ value: 0, gas: gas[i] }(callingData[i]);
82                      require(success, "BalancerFlashLoan: Flash loan failed");
83                  }
89              for (uint256 i = 0; i < tokens.length; i++) {
90                  // send the tokens back to the vault
91                  tokens[i].safeTransfer(msg.sender, amounts[i]);
92                  require(tokens[i].balanceOf(address(this)) == 0, "BalancerFlashLoan: Flash loan extra tokens");
93              }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


69              for (uint256 i = 0; i < calls.length; i++) {
70                  if (calls[i].target != facade) revert IConnector_InvalidTarget(calls[i].target);
71                  bytes4 method = bytes4(calls[i].callData[:4]);
72      
73                  if (method == ICreditFacadeV3Multicall.enableToken.selector) {
74                      (address token) = abi.decode(calls[i].callData[4:], (address));
75                      _updateTokenInRegistry(token);
76                  }
77              }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


104                 for (uint256 i = 0; i < threshold;) {
105                     address recovered = ECDSA.recover(totalHash, sigV[i], sigR[i], sigS[i]);
106                     require(recovered > lastAdd && isOwner[recovered]);
107                     lastAdd = recovered;
108                     unchecked {
109                         ++i;
110                     }
111                 }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


178             for (uint256 i = 0; i < tokens.length; i++) {
179                 // gather all of the tokens
180                 uint256 _balance = IERC20(tokens[i]).balanceOf(address(this));
181                 ITokenTransferCallBack(msg.sender).sendTokensToTrustedAddress(tokens[i], amounts[i], msg.sender, "");
182                 uint256 _balanceAfter = IERC20(tokens[i]).balanceOf(address(this));
183                 if (_balanceAfter < amounts[i] + _balance) {
184                     revert IConnector_InsufficientDepositAmount(_balanceAfter - _balance, amounts[i]);
185                 }
186             }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

</details>

## L033 - Consider disallowing minting/transfers to address(this):

A tranfer to the token contract itself is unlikely to be correct and more likely to be a common user error due to a copy & paste mistake. Proceeding with such a transfer will result in the permanent loss of user tokens.


```solidity
File: contracts/accountingManager/AccountingManager.sol


693         function mint(uint256 shares, address receiver) public override returns (uint256) {
694             revert NoyaAccounting_NOT_ALLOWED();
695         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

## L034 - External calls in modifiers should be avoided:

Using external calls within modifiers can introduce reentrancy risks and make a contract's logic less transparent. Modifiers are meant for pre-execution checks, and external calls can lead to unpredictable flow and potential reentrancy issues. Avoiding external calls in modifiers and placing them directly in the function body enhances code clarity, aids in auditing, and minimizes unexpected behaviors. This practice ensures a more explicit execution order and clearer understanding of the code's effects.


<details>
<summary>Click to show 4 findings</summary>

```solidity
File: contracts/governance/NoyaGovernanceBase.sol


32              (,,, address keeperContract,, address emergencyManager) = registry.getGovernanceAddresses(vaultId);
33              if (!(msg.sender == keeperContract || msg.sender == emergencyManager || msg.sender == registry.flashLoan())) {
44              (,,,,, address emergencyManager) = registry.getGovernanceAddresses(vaultId);
54              (,,,, address watcherContract, address emergencyManager) = registry.getGovernanceAddresses(vaultId);
66              (, address maintainer,,,, address emergencyManager) = registry.getGovernanceAddresses(vaultId);
76              (, address maintainer,,,,) = registry.getGovernanceAddresses(vaultId);
86              (address governer,,,,,) = registry.getGovernanceAddresses(vaultId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


25              if (!registry.hasRole(registry.MAINTAINER_ROLE(), msg.sender)) revert INoyaValueOracle_Unauthorized(msg.sender);
25              if (!registry.hasRole(registry.MAINTAINER_ROLE(), msg.sender)) revert INoyaValueOracle_Unauthorized(msg.sender);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


42              if (!registry.hasRole(registry.MAINTAINER_ROLE(), msg.sender)) revert INoyaValueOracle_Unauthorized(msg.sender);
42              if (!registry.hasRole(registry.MAINTAINER_ROLE(), msg.sender)) revert INoyaValueOracle_Unauthorized(msg.sender);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


25              if (!registry.hasRole(registry.MAINTAINER_ROLE(), msg.sender)) revert INoyaValueOracle_Unauthorized(msg.sender);
25              if (!registry.hasRole(registry.MAINTAINER_ROLE(), msg.sender)) revert INoyaValueOracle_Unauthorized(msg.sender);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## NC001 - TODO Left in the code:

TODOs may signal that a feature is missing or not ready for audit, consider resolving the issue and removing the TODO comment


```solidity
File: contracts/connectors/MaverickConnector.sol


_approveOperations(p.pool.tokenA(), maverickRouter, p.tokenARequiredAllowance); // TODO: check token A is eth

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L93:93

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


_lzSend(lzChainId, data, messageSetting, MessagingFee(address(this).balance, 0), payable(address(this))); // TODO: send event here

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L80:80

## NC002 - The `nonReentrant` `modifier` should occur before all other modifiers:

This is a best-practice to protect against reentrancy in other modifiers.


<details>
<summary>Click to show 23 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


226         function calculateDepositShares(uint256 maxIterations) public onlyManager nonReentrant whenNotPaused {
227             uint256 middleTemp = depositQueue.middle;
228             uint64 i = 0;
229     
230             uint256 oldestUpdateTime = TVLHelper.getLatestUpdateTime(vaultId, registry);
231     
232             while (
233                 depositQueue.last > middleTemp && depositQueue.queue[middleTemp].recordTime <= oldestUpdateTime
234                     && i < maxIterations
235             ) {
236                 i += 1;
237                 DepositRequest storage data = depositQueue.queue[middleTemp];
238     
239                 uint256 shares = previewDeposit(data.amount);
240                 data.shares = shares;
241                 data.calculationTime = block.timestamp;
242                 emit CalculateDeposit(
243                     middleTemp, data.receiver, block.timestamp, shares, data.amount, shares * 1e18 / data.amount
244                 );
245     
246                 middleTemp += 1;
247             }
248     
249             depositQueue.middle = middleTemp;
250         }
257         function executeDeposit(uint256 maxI, address connector, bytes memory addLPdata)
258             public
259             onlyManager
260             whenNotPaused
261             nonReentrant
262         {
263             uint256 firstTemp = depositQueue.first;
264             uint64 i = 0;
265             uint256 processedBaseTokenAmount = 0;
266     
267             while (
268                 depositQueue.middle > firstTemp
269                     && depositQueue.queue[firstTemp].calculationTime + depositWaitingTime <= block.timestamp && i < maxI
270             ) {
271                 i += 1;
272                 DepositRequest memory data = depositQueue.queue[firstTemp];
273     
274                 emit ExecuteDeposit(
275                     firstTemp, data.receiver, block.timestamp, data.shares, data.amount, data.shares * 1e18 / data.amount
276                 );
277                 // minting shares for receiver address
278                 _mint(data.receiver, data.shares);
279     
280                 processedBaseTokenAmount += data.amount;
281                 delete depositQueue.queue[firstTemp];
282                 firstTemp += 1;
283             }
284             depositQueue.totalAWFDeposit -= processedBaseTokenAmount;
285     
286             totalDepositedAmount += processedBaseTokenAmount;
287     
288             if (registry.isAnActiveConnector(vaultId, connector) && processedBaseTokenAmount > 0) {
289                 uint256[] memory amounts = new uint256[](1);
290                 amounts[0] = processedBaseTokenAmount;
291                 address[] memory tokens = new address[](1);
292                 tokens[0] = address(baseToken);
293                 IConnector(connector).addLiquidity(tokens, amounts, addLPdata);
294             } else {
295                 revert NoyaAccounting_INVALID_CONNECTOR();
296             }
297     
298             depositQueue.first = firstTemp;
299         }
328         function calculateWithdrawShares(uint256 maxIterations) public onlyManager nonReentrant whenNotPaused {
329             uint256 middleTemp = withdrawQueue.middle;
330             uint64 i = 0;
331             uint256 processedShares = 0;
332             uint256 assetsNeededForWithdraw = 0;
333             uint256 oldestUpdateTime = TVLHelper.getLatestUpdateTime(vaultId, registry);
334     
335             if (currentWithdrawGroup.isFullfilled == false && currentWithdrawGroup.isStarted == true) {
336                 revert NoyaAccounting_ThereIsAnActiveWithdrawGroup();
337             }
338             while (
339                 withdrawQueue.last > middleTemp && withdrawQueue.queue[middleTemp].recordTime <= oldestUpdateTime
340                     && i < maxIterations
341             ) {
342                 i += 1;
343                 WithdrawRequest storage data = withdrawQueue.queue[middleTemp];
344                 uint256 assets = previewRedeem(data.shares);
345                 data.amount = assets;
346                 data.calculationTime = block.timestamp;
347                 assetsNeededForWithdraw += assets;
348                 processedShares += data.shares;
349                 emit CalculateWithdraw(middleTemp, data.owner, data.receiver, data.shares, assets, block.timestamp);
350     
351                 middleTemp += 1;
352             }
353             currentWithdrawGroup.totalCBAmount += assetsNeededForWithdraw;
354             withdrawQueue.middle = middleTemp;
355         }
360         function startCurrentWithdrawGroup() public onlyManager nonReentrant whenNotPaused {
361             require(currentWithdrawGroup.isStarted == false && currentWithdrawGroup.isFullfilled == false);
362             currentWithdrawGroup.isStarted = true;
363             currentWithdrawGroup.lastId = withdrawQueue.middle;
364             emit WithdrawGroupStarted(currentWithdrawGroup.lastId, currentWithdrawGroup.totalCBAmount);
365         }
370         function fulfillCurrentWithdrawGroup() public onlyManager nonReentrant whenNotPaused {
371             require(currentWithdrawGroup.isStarted == true && currentWithdrawGroup.isFullfilled == false);
372             uint256 neededAssets = neededAssetsForWithdraw();
373     
374             if (neededAssets != 0 && amountAskedForWithdraw != currentWithdrawGroup.totalCBAmount) {
375                 revert NoyaAccounting_NOT_READY_TO_FULFILL();
376             }
377             currentWithdrawGroup.isFullfilled = true;
378             amountAskedForWithdraw = 0;
379             uint256 availableAssets = baseToken.balanceOf(address(this)) - depositQueue.totalAWFDeposit;
380             if (availableAssets >= currentWithdrawGroup.totalCBAmount) {
381                 currentWithdrawGroup.totalABAmount = currentWithdrawGroup.totalCBAmount;
382             } else {
383                 currentWithdrawGroup.totalABAmount = availableAssets;
384             }
385             currentWithdrawGroup.totalCBAmountFullfilled = currentWithdrawGroup.totalCBAmount;
386             currentWithdrawGroup.totalCBAmount = 0;
387             emit WithdrawGroupFulfilled(
388                 currentWithdrawGroup.lastId, currentWithdrawGroup.totalCBAmount, currentWithdrawGroup.totalABAmount
389             );
390         }
396         function executeWithdraw(uint256 maxIterations) public onlyManager nonReentrant whenNotPaused {
397             if (currentWithdrawGroup.isFullfilled == false) {
398                 revert NoyaAccounting_ThereIsAnActiveWithdrawGroup();
399             }
400             uint64 i = 0;
401             uint256 firstTemp = withdrawQueue.first;
402     
403             uint256 withdrawFeeAmount = 0;
404             uint256 processedBaseTokenAmount = 0;
405             // loop through the withdraw queue and execute the withdraws
406             while (
407                 currentWithdrawGroup.lastId > firstTemp
408                     && withdrawQueue.queue[firstTemp].calculationTime + withdrawWaitingTime <= block.timestamp
409                     && i < maxIterations
410             ) {
411                 i += 1;
412                 WithdrawRequest memory data = withdrawQueue.queue[firstTemp];
413                 uint256 shares = data.shares;
414                 // calculate the base token amount that the user will receive based on the total available amount
415                 uint256 baseTokenAmount =
416                     data.amount * currentWithdrawGroup.totalABAmount / currentWithdrawGroup.totalCBAmountFullfilled;
417     
418                 withdrawRequestsByAddress[data.owner] -= shares;
419                 _burn(data.owner, shares);
420     
421                 processedBaseTokenAmount += data.amount;
422                 {
423                     uint256 feeAmount = baseTokenAmount * withdrawFee / FEE_PRECISION;
424                     withdrawFeeAmount += feeAmount;
425                     baseTokenAmount = baseTokenAmount - feeAmount;
426                 }
427     
428                 baseToken.safeTransfer(data.receiver, baseTokenAmount);
429                 emit ExecuteWithdraw(
430                     firstTemp, data.owner, data.receiver, shares, data.amount, baseTokenAmount, block.timestamp
431                 );
432                 delete withdrawQueue.queue[firstTemp];
433                 // increment the first index of the withdraw queue
434                 firstTemp += 1;
435             }
436             totalWithdrawnAmount += processedBaseTokenAmount;
437     
438             if (withdrawFeeAmount > 0) {
439                 baseToken.safeTransfer(withdrawFeeReceiver, withdrawFeeAmount);
440             }
441             withdrawQueue.first = firstTemp;
442             // if the withdraw group is fullfilled and there are no withdraws that are waiting for execution, we delete the withdraw group
443             if (currentWithdrawGroup.lastId == firstTemp) {
444                 delete currentWithdrawGroup;
445             }
446         }
475         function recordProfitForFee() public onlyManager nonReentrant {
476             storedProfitForFee = getProfit();
477             profitStoredTime = block.timestamp;
478     
479             if (storedProfitForFee < totalProfitCalculated) {
480                 return;
481             }
482     
483             preformanceFeeSharesWaitingForDistribution =
484                 previewDeposit(((storedProfitForFee - totalProfitCalculated) * performanceFee) / FEE_PRECISION);
485             emit RecordProfit(
486                 storedProfitForFee, totalProfitCalculated, preformanceFeeSharesWaitingForDistribution, block.timestamp
487             );
488         }
505         function collectManagementFees() public onlyManager nonReentrant returns (uint256, uint256) {
506             if (block.timestamp - lastFeeDistributionTime < 1 days) {
507                 return (0, 0);
508             }
509             uint256 timePassed = block.timestamp - lastFeeDistributionTime;
510             if (timePassed > 10 days) {
511                 timePassed = 10 days;
512             }
513             uint256 totalShares = totalSupply();
514             uint256 currentFeeShares = balanceOf(managementFeeReceiver) + balanceOf(performanceFeeReceiver)
515                 + preformanceFeeSharesWaitingForDistribution;
516     
517             uint256 managementFeeAmount =
518                 (timePassed * managementFee * (totalShares - currentFeeShares)) / FEE_PRECISION / 365 days;
519             _mint(managementFeeReceiver, managementFeeAmount);
520             emit CollectManagementFee(managementFeeAmount, timePassed, totalShares, currentFeeShares);
521             lastFeeDistributionTime = block.timestamp;
522             return (managementFeeAmount, timePassed);
523         }
526         function collectPerformanceFees() public onlyManager nonReentrant {
527             if (
528                 preformanceFeeSharesWaitingForDistribution == 0 || block.timestamp - profitStoredTime < 12 hours
529                     || block.timestamp - profitStoredTime > 48 hours
530             ) {
531                 return;
532             }
533     
534             _mint(performanceFeeReceiver, preformanceFeeSharesWaitingForDistribution);
535     
536             totalProfitCalculated = storedProfitForFee;
537     
538             emit CollectPerformanceFee(preformanceFeeSharesWaitingForDistribution);
539     
540             preformanceFeeSharesWaitingForDistribution = 0;
541         }
548         function retrieveTokensForWithdraw(RetrieveData[] calldata retrieveData) public onlyManager nonReentrant {
549             uint256 amountAskedForWithdraw_temp = 0;
550             uint256 neededAssets = neededAssetsForWithdraw();
551             for (uint256 i = 0; i < retrieveData.length; i++) {
552                 if (!registry.isAnActiveConnector(vaultId, retrieveData[i].connectorAddress)) {
553                     continue;
554                 }
555                 uint256 balanceBefore = baseToken.balanceOf(address(this));
556                 uint256 amount = IConnector(retrieveData[i].connectorAddress).sendTokensToTrustedAddress(
557                     address(baseToken), retrieveData[i].withdrawAmount, address(this), retrieveData[i].data
558                 );
559                 uint256 balanceAfter = baseToken.balanceOf(address(this));
560                 if (balanceBefore + amount > balanceAfter) revert NoyaAccounting_banalceAfterIsNotEnough();
561                 amountAskedForWithdraw_temp += retrieveData[i].withdrawAmount;
562                 emit RetrieveTokensForWithdraw(
563                     retrieveData[i].withdrawAmount,
564                     retrieveData[i].connectorAddress,
565                     amount,
566                     amountAskedForWithdraw + amountAskedForWithdraw_temp
567                 );
568             }
569             amountAskedForWithdraw += amountAskedForWithdraw_temp;
570             if (amountAskedForWithdraw_temp > neededAssets) {
571                 revert NoyaAccounting_INVALID_AMOUNT();
572             }
573         }
683         function rescue(address token, uint256 amount) public onlyEmergency nonReentrant {
684             if (token == address(0)) {
685                 (bool success,) = payable(msg.sender).call{ value: amount }("");
686                 require(success, "Transfer failed.");
687             } else {
688                 IERC20(token).safeTransfer(msg.sender, amount);
689             }
690             emit Rescue(msg.sender, token, amount);
691         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


238         function addTrustedPosition(
239             uint256 vaultId,
240             uint256 _positionTypeId,
241             address calculatorConnector,
242             bool onlyOwner,
243             bool _isDebt,
244             bytes calldata _data,
245             bytes calldata _additionalData
246         ) external onlyVaultMaintainerWithoutTimeLock(vaultId) vaultExists(vaultId) nonReentrant {
247             Vault storage vault = vaults[vaultId];
248             bytes32 positionId = calculatePositionId(calculatorConnector, _positionTypeId, _data);
249             {
250                 if (vault.trustedPositionsBP[positionId].isEnabled) revert AlreadyExists();
251                 if (vault.connectors[calculatorConnector].enabled == false) revert NotExist();
252                 address[] memory usingTokens = IConnector(calculatorConnector).getUnderlyingTokens(_positionTypeId, _data);
253                 for (uint256 i = 0; i < usingTokens.length; i++) {
254                     if (!isTokenTrusted(vaultId, usingTokens[i], calculatorConnector)) {
255                         revert TokenNotTrusted(usingTokens[i]);
256                     }
257                 }
258     
259                 vault.trustedPositionsBP[positionId] =
260                     PositionBP(calculatorConnector, _positionTypeId, onlyOwner, true, _isDebt, _data, _additionalData);
261             }
262             emit TrustedPositionAdded(vaultId, positionId, calculatorConnector, _positionTypeId, onlyOwner, _isDebt, _data);
263         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


46          function supply(address supplyToken, uint256 amount) external onlyManager nonReentrant {
47              _approveOperations(supplyToken, pool, amount);
48              IPool(pool).supply(supplyToken, amount, address(this), 0);
49              registry.updateHoldingPosition(
50                  vaultId, registry.calculatePositionId(address(this), AAVE_POSITION_ID, ""), "", "", false
51              );
52              _updateTokenInRegistry(supplyToken);
53              emit Supply(supplyToken, amount);
54          }
62          function borrow(uint256 _amount, uint256 _interestRateMode, address _borrowAsset)
63              external
64              onlyManager
65              nonReentrant
66          {
67              if (!registry.isTokenTrusted(vaultId, _borrowAsset, address(this))) {
68                  revert IConnector_UntrustedToken(_borrowAsset);
69              }
70              IPool(pool).borrow(_borrowAsset, _amount, _interestRateMode, 0, address(this));
71              // get the health factor
72              (,,,,, uint256 healthFactor) = IPool(pool).getUserAccountData(address(this));
73              if (healthFactor < minimumHealthFactor) revert IConnector_LowHealthFactor(healthFactor);
74              _updateTokenInRegistry(_borrowAsset);
75              emit Borrow(_borrowAsset, _amount);
76          }
81          function repay(address asset, uint256 amount, uint256 i) external onlyManager nonReentrant {
82              _approveOperations(asset, pool, amount);
83              IPool(pool).repay(asset, amount, i, address(this));
84              _updateTokenInRegistry(asset);
85              emit Repay(asset, amount, i);
86          }
100         function withdrawCollateral(uint256 _collateralAmount, address _collateral) external onlyManager nonReentrant {
101             IPool(pool).withdraw(_collateral, _collateralAmount, address(this));
102             // get the health factor
103             (uint256 totalCollateralBase,,,,, uint256 healthFactor) = IPool(pool).getUserAccountData(address(this));
104             if (healthFactor < minimumHealthFactor) revert IConnector_LowHealthFactor(healthFactor);
105             _updateTokenInRegistry(_collateral);
106             if (totalCollateralBase <= DUST_LEVEL * 1e7) {
107                 registry.updateHoldingPosition(
108                     vaultId, registry.calculatePositionId(address(this), AAVE_POSITION_ID, ""), "", "", true
109                 );
110             }
111             emit WithdrawCollateral(_collateral, _collateralAmount);
112         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


53          function supply(DepositData memory data) public onlyManager nonReentrant {
54              bytes32 positionId = registry.calculatePositionId(address(this), AERODROME_POSITION_TYPE, abi.encode(data.pool));
55              _approveOperations(IPool(data.pool).token0(), address(aerodromeRouter), data.amount0);
56              _approveOperations(IPool(data.pool).token1(), address(aerodromeRouter), data.amount1);
57              aerodromeRouter.addLiquidity(
58                  IPool(data.pool).token0(),
59                  IPool(data.pool).token1(),
60                  IPool(data.pool).stable(),
61                  data.amount0,
62                  data.amount1,
63                  data.min0Min,
64                  data.min1Min,
65                  address(this),
66                  data.deadline
67              );
68              registry.updateHoldingPosition(vaultId, positionId, "", "", false);
69              _updateTokenInRegistry(IPool(data.pool).token0());
70              _updateTokenInRegistry(IPool(data.pool).token1());
71      
72              emit Supply(data.pool, data.amount0, data.amount1);
73          }
79          function withdraw(WithdrawData memory data) public onlyManager nonReentrant {
80              bytes32 positionId = registry.calculatePositionId(address(this), AERODROME_POSITION_TYPE, abi.encode(data.pool));
81              _approveOperations(data.pool, address(aerodromeRouter), data.amountLiquidity);
82              aerodromeRouter.removeLiquidity(
83                  IPool(data.pool).token0(),
84                  IPool(data.pool).token1(),
85                  IPool(data.pool).stable(),
86                  data.amountLiquidity,
87                  data.min0Min,
88                  data.min1Min,
89                  address(this),
90                  data.deadline
91              );
92              if (IERC20(data.pool).balanceOf(address(this)) == 0) {
93                  registry.updateHoldingPosition(vaultId, positionId, "", "", true);
94              }
95              _updateTokenInRegistry(IPool(data.pool).token0());
96              _updateTokenInRegistry(IPool(data.pool).token1());
97              emit Withdraw(data.pool, data.amountLiquidity);
98          }
100         function stake(address pool, uint256 liquidity) public onlyManager nonReentrant {
101             address gauge = voter.gauges(pool);
102             IERC20(pool).forceApprove(address(gauge), liquidity);
103             IGauge(gauge).deposit(liquidity, address(this));
104         }
106         function unstake(address pool, uint256 liquidity) public onlyManager nonReentrant {
107             address gauge = voter.gauges(pool);
108             IGauge(gauge).withdraw(liquidity);
109         }
111         function claim(address pool) public onlyManager nonReentrant {
112             address gauge = voter.gauges(pool);
113             IGauge(gauge).getReward(address(this));
114             _updateTokenInRegistry(IGauge(gauge).rewardToken());
115         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


53          function harvestAuraRewards(address[] calldata rewardsPools) public onlyManager nonReentrant {
54              for (uint256 i = 0; i < rewardsPools.length; i++) {
55                  IRewardPool baseRewardPool = IRewardPool(rewardsPools[i]);
56                  baseRewardPool.getReward();
57              }
58              _updateTokenInRegistry(address(AURA));
59          }
64          function openPosition(
65              bytes32 poolId,
66              uint256[] memory amounts,
67              uint256[] memory amountsWithoutBPT,
68              uint256 minBPT,
69              uint256 auraAmount
70          ) public onlyManager nonReentrant {
71              address[] memory tokens;
72              {
73                  (tokens,,) = IBalancerVault(balancerVault).getPoolTokens(poolId);
74              }
75              address pool = IBalancerVault(balancerVault).getPool(poolId);
76      
77              for (uint256 i = 0; i < tokens.length; i++) {
78                  if (amounts[i] > 0) _approveOperations(tokens[i], balancerVault, amounts[i]);
79              }
80      
81              IBalancerVault(balancerVault).joinPool(
82                  poolId,
83                  address(this), // sender
84                  address(this), // recipient
85                  IBalancerVault.JoinPoolRequest(
86                      tokens,
87                      amounts,
88                      abi.encode(
89                          IBalancerVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,
90                          amountsWithoutBPT, //_noBptAmounts,
91                          minBPT // minimumBPT
92                      ),
93                      false
94                  )
95              );
96              bytes32 positionId = registry.calculatePositionId(address(this), BALANCER_LP_POSITION, abi.encode(poolId));
97              registry.updateHoldingPosition(vaultId, positionId, "", "", false);
98      
99              if (auraAmount > 0) {
100                 (PoolInfo memory _poolInfo,) = _getPoolInfo(poolId);
101     
102                 uint256 amount = IERC20(pool).balanceOf(address(this));
103                 _approveOperations(pool, _poolInfo.auraPoolAddress, amount);
104                 IRewardPool(_poolInfo.auraPoolAddress).deposit(auraAmount, address(this));
105             }
106             emit OpenPosition(poolId, amounts, amountsWithoutBPT, minBPT, auraAmount);
107         }
109         function depositIntoAuraBooster(bytes32 poolId, uint256 _amount) public onlyManager nonReentrant {
110             (PoolInfo memory _poolInfo,) = _getPoolInfo(poolId);
111             _approveOperations(_poolInfo.pool, _poolInfo.auraPoolAddress, _amount);
112             IRewardPool(_poolInfo.auraPoolAddress).deposit(_amount, address(this));
113         }
115         function decreasePosition(DecreasePositionParams memory p) public onlyManager nonReentrant {
116             if (p._auraAmount > 0) {
117                 (PoolInfo memory _poolInfo, bytes32 positionId) = _getPoolInfo(p.poolId);
118     
119                 IRewardPool(_poolInfo.auraPoolAddress).withdrawAndUnwrap(p._auraAmount, true);
120             }
121     
122             if (p._lpAmount > 0) {
123                 address[] memory tokens;
124                 {
125                     (tokens,,) = IBalancerVault(balancerVault).getPoolTokens(p.poolId);
126                 }
127                 uint256[] memory _amounts = new uint256[](tokens.length);
128                 _amounts[p.outerIndex] = p.minAmount;
129     
130                 IBalancerVault(balancerVault).exitPool(
131                     p.poolId,
132                     address(this), // sender
133                     payable(address(this)), // recipient
134                     IBalancerVault.ExitPoolRequest(
135                         tokens,
136                         _amounts,
137                         abi.encode(
138                             IBalancerVault.ExitKind.EXACT_BPT_IN_FOR_ONE_TOKEN_OUT,
139                             p._lpAmount,
140                             p.withdrawIndex // enterTokenIndex
141                         ),
142                         false
143                     )
144                 );
145     
146                 if (totalLpBalanceOf(p.poolId) == 0) {
147                     registry.updateHoldingPosition(
148                         vaultId,
149                         registry.calculatePositionId(address(this), BALANCER_LP_POSITION, abi.encode(p.poolId)),
150                         "",
151                         "",
152                         true
153                     );
154                 }
155                 _updateTokenInRegistry(tokens[p.outerIndex]);
156             }
157             _updateTokenInRegistry(AURA);
158             _updateTokenInRegistry(BAL);
159             emit DecreasePosition(p);
160         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


43          function addLiquidityInCamelotPool(CamelotAddLiquidityParams calldata p) external onlyManager nonReentrant {
44              _approveOperations(p.tokenA, address(router), p.amountA);
45              _approveOperations(p.tokenB, address(router), p.amountB);
46              router.addLiquidity(
47                  p.tokenA, p.tokenB, p.amountA, p.amountB, p.minAmountA, p.minAmountB, address(this), p.deadline
48              );
49              _updateTokenInRegistry(p.tokenA);
50              _updateTokenInRegistry(p.tokenB);
51              registry.updateHoldingPosition(
52                  vaultId,
53                  registry.calculatePositionId(address(this), CAMELOT_POSITION_ID, abi.encode(p.tokenA, p.tokenB)),
54                  "",
55                  "",
56                  false
57              );
58          }
65          function removeLiquidityFromCamelotPool(CamelotRemoveLiquidityParams calldata p)
66              external
67              onlyManager
68              nonReentrant
69          {
70              address pool = factory.getPair(p.tokenA, p.tokenB);
71              _approveOperations(pool, address(router), p.amountLiquidty);
72              router.removeLiquidity(
73                  p.tokenA, p.tokenB, p.amountLiquidty, p.minAmountA, p.minAmountB, address(this), p.deadline
74              );
75              _updateTokenInRegistry(p.tokenA);
76              _updateTokenInRegistry(p.tokenB);
77              if (IERC20(pool).balanceOf(address(this)) == 0) {
78                  registry.updateHoldingPosition(
79                      vaultId,
80                      registry.calculatePositionId(address(this), CAMELOT_POSITION_ID, abi.encode(p.tokenA, p.tokenB)),
81                      "",
82                      "",
83                      true
84                  );
85              }
86          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


29          function supply(address market, address asset, uint256 amount) external onlyManager nonReentrant {
30              _approveOperations(asset, market, amount);
31              if (!registry.isTokenTrusted(vaultId, asset, address(this))) revert IConnector_UntrustedToken(asset);
32              IComet(market).supply(asset, amount);
33              registry.updateHoldingPosition(
34                  vaultId, registry.calculatePositionId(address(this), COMPOUND_LP, abi.encode(market)), "", "", false
35              );
36              _updateTokenInRegistry(asset);
37              emit Supply(market, asset, amount);
38          }
48          function withdrawOrBorrow(address _market, address asset, uint256 amount) external onlyManager nonReentrant {
49              IComet(_market).withdraw(asset, amount);
50              if (!registry.isTokenTrusted(vaultId, asset, address(this))) revert IConnector_UntrustedToken(asset);
51              uint256 healthFactor = getAccountHealthFactor(IComet(_market));
52              if (healthFactor < minimumHealthFactor) revert IConnector_LowHealthFactor(healthFactor);
53              if (getCollBlanace(IComet(_market), false) == 0) {
54                  registry.updateHoldingPosition(
55                      vaultId, registry.calculatePositionId(address(this), COMPOUND_LP, abi.encode(_market)), "", "", true
56                  );
57              }
58              _updateTokenInRegistry(asset);
59              emit WithdrawOrBorrow(_market, asset, amount);
60          }
63          function claimRewards(address rewardContract, address market) external onlyManager nonReentrant {
64              address rewardToken = IRewards(rewardContract).rewardConfig(market).token;
65              IRewards(rewardContract).claim(address(market), address(this), true);
66              _updateTokenInRegistry(rewardToken);
67              emit ClaimRewards(rewardContract, market);
68          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


68          function depositIntoGauge(address pool, uint256 amount) public onlyManager nonReentrant {
69              PoolInfo memory poolInfo = _getPoolInfo(pool);
70      
71              _approveOperations(poolInfo.lpToken, poolInfo.gauge, amount);
72              IRewardsGauge(poolInfo.gauge).deposit(amount);
73          }
81          function depositIntoPrisma(address pool, uint256 amount, bool curveOrConvex) public onlyManager nonReentrant {
82              PoolInfo memory poolInfo = _getPoolInfo(pool);
83      
84              // approve depositToken to spend lpToken
85              address lpToken = poolInfo.lpToken;
86              address depostiToken = poolInfo.prismaCurvePool;
87              if (!curveOrConvex) {
88                  depostiToken = poolInfo.prismaConvexPool;
89              }
90              _approveOperations(lpToken, depostiToken, amount);
91      
92              // stake LP in Prisma
93              IDepositToken(depostiToken).deposit(address(this), amount);
94          }
117         function openCurvePosition(address pool, uint256 depositIndex, uint256 amount, uint256 minAmount)
118             public
119             onlyManager
120             nonReentrant
121         {
122             bytes32 positionId = registry.calculatePositionId(address(this), CURVE_LP_POSITION, abi.encode(pool));
123             PositionBP memory p = registry.getPositionBP(vaultId, positionId);
124             PoolInfo memory poolInfo = abi.decode(p.additionalData, (PoolInfo));
125             address token = poolInfo.tokens[depositIndex];
126             address poolAddress = (poolInfo.tokens.length > 2 && poolInfo.zap != address(0)) ? poolInfo.zap : pool;
127             _approveOperations(token, poolAddress, amount);
128             if (poolInfo.tokens.length == 2) {
129                 uint256[2] memory amounts;
130                 amounts[depositIndex] = amount;
131                 ICurveSwap(poolAddress).add_liquidity(amounts, minAmount);
132             } else if (poolInfo.tokens.length == 3) {
133                 uint256[3] memory amounts;
134                 amounts[depositIndex] = amount;
135                 ICurveSwap(poolAddress).add_liquidity(amounts, minAmount);
136             } else if (poolInfo.tokens.length == 4) {
137                 uint256[4] memory amounts;
138                 amounts[depositIndex] = amount;
139                 ICurveSwap(poolAddress).add_liquidity(amounts, minAmount);
140             } else if (poolInfo.tokens.length == 5) {
141                 uint256[5] memory amounts;
142                 amounts[depositIndex] = amount;
143                 ICurveSwap(poolAddress).add_liquidity(amounts, minAmount);
144             } else if (poolInfo.tokens.length == 6) {
145                 uint256[6] memory amounts;
146                 amounts[depositIndex] = amount;
147                 ICurveSwap(poolAddress).add_liquidity(amounts, minAmount);
148             }
149             emit OpenCurvePosition(pool, depositIndex, amount, minAmount);
150             registry.updateHoldingPosition(vaultId, positionId, "", "", false);
151         }
160         function decreaseCurvePosition(address pool, uint256 withdrawIndex, uint256 amount, uint256 minAmount)
161             public
162             onlyManager
163             nonReentrant
164         {
165             PoolInfo memory poolInfo = _getPoolInfo(pool);
166             address token = poolInfo.tokens[withdrawIndex];
167             bytes32 positionId = registry.calculatePositionId(address(this), CURVE_LP_POSITION, abi.encode(pool));
168     
169             ICurveSwap(poolInfo.pool).remove_liquidity_one_coin(amount, int128(uint128(withdrawIndex)), minAmount);
170             _updateTokenInRegistry(token);
171             if (totalLpBalanceOf(poolInfo) == 0) {
172                 registry.updateHoldingPosition(vaultId, positionId, "", "", true);
173             }
174             emit DecreaseCurvePosition(pool, withdrawIndex, amount, minAmount);
175         }
221         function harvestRewards(address[] calldata gauges) public onlyManager nonReentrant {
222             for (uint256 i = 0; i < gauges.length; i++) {
223                 IRewardsGauge(gauges[i]).claim_rewards(address(this));
224             }
225             _updateTokenInRegistry(CRV);
226             emit HarvestRewards(gauges);
227         }
233         function harvestPrismaRewards(address[] calldata pools) public onlyManager nonReentrant {
234             for (uint256 i = 0; i < pools.length; i++) {
235                 IDepositToken(pools[i]).claimReward(address(this));
236             }
237             _updateTokenInRegistry(PRISMA);
238             _updateTokenInRegistry(CRV);
239             _updateTokenInRegistry(CVX);
240             emit HarvestPrismaRewards(pools);
241         }
247         function harvestConvexRewards(address[] calldata rewardsPools) public onlyManager nonReentrant {
248             for (uint256 i = 0; i < rewardsPools.length; i++) {
249                 IConvexBasicRewards baseRewardPool = IConvexBasicRewards(rewardsPools[i]);
250                 baseRewardPool.getReward(address(this), true);
251             }
252             _updateTokenInRegistry(CVX);
253             _updateTokenInRegistry(CRV);
254             emit HarvestConvexRewards(rewardsPools);
255         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


30          function deposit(uint256 marketId, uint256 _amount) public onlyManager nonReentrant {
31              // get market token
32              address token = dolomiteMargin.getMarketTokenAddress(marketId);
33              // approve
34              _approveOperations(token, address(dolomiteMargin), _amount);
35              depositWithdrawalProxy.depositWeiIntoDefaultAccount(marketId, _amount);
36              // Update token
37              _updateTokenInRegistry(token);
38              registry.updateHoldingPosition(
39                  vaultId, registry.calculatePositionId(address(this), DOL_POSITION_ID, ""), abi.encode(0), "", false
40              );
41          }
43          function withdraw(uint256 marketId, uint256 _amount) public onlyManager nonReentrant {
44              address token = dolomiteMargin.getMarketTokenAddress(marketId);
45              depositWithdrawalProxy.withdrawWeiFromDefaultAccount(
46                  marketId, _amount, AccountBalanceHelper.BalanceCheckFlag.None
47              );
48              // Update token
49              _updateTokenInRegistry(token);
50              (uint256[] memory markets,,,) = dolomiteMargin.getAccountBalances(Info(address(this), 0));
51              if (markets.length == 0) {
52                  registry.updateHoldingPosition(
53                      vaultId, registry.calculatePositionId(address(this), DOL_POSITION_ID, ""), abi.encode(0), "", true
54                  );
55              }
56          }
58          function openBorrowPosition(uint256 marketId, uint256 _amountWei, uint256 accountId)
59              public
60              onlyManager
61              nonReentrant
62          {
63              address token = dolomiteMargin.getMarketTokenAddress(marketId);
64      
65              if (!registry.isTokenTrusted(vaultId, token, address(this))) {
66                  revert IConnector_UntrustedToken(token);
67              }
68              // borrow
69              borrowPositionProxy.openBorrowPosition(
70                  0, accountId, marketId, _amountWei, AccountBalanceHelper.BalanceCheckFlag.None
71              );
72              registry.updateHoldingPosition(
73                  vaultId, registry.calculatePositionId(address(this), DOL_POSITION_ID, ""), abi.encode(accountId), "", true
74              );
75          }
77          function transferBetweenAccounts(uint256 accountId, uint256 marketId, uint256 _amountWei, bool borrowOrRepay)
78              public
79              onlyManager
80              nonReentrant
81          {
82              address token = dolomiteMargin.getMarketTokenAddress(marketId);
83      
84              if (!registry.isTokenTrusted(vaultId, token, address(this))) {
85                  revert IConnector_UntrustedToken(token);
86              }
87              if (borrowOrRepay) {
88                  borrowPositionProxy.transferBetweenAccounts(
89                      accountId, 0, marketId, _amountWei, AccountBalanceHelper.BalanceCheckFlag.None
90                  );
91              } else {
92                  borrowPositionProxy.transferBetweenAccounts(
93                      0, accountId, marketId, _amountWei, AccountBalanceHelper.BalanceCheckFlag.None
94                  );
95              }
96          }
98          function closeBorrowPosition(uint256[] memory marketIds, uint256 accountId) public onlyManager nonReentrant {
99              // repay
100             borrowPositionProxy.closeBorrowPosition(accountId, 0, marketIds);
101             registry.updateHoldingPosition(
102                 vaultId, registry.calculatePositionId(address(this), DOL_POSITION_ID, ""), abi.encode(accountId), "", true
103             );
104         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


38          function borrowAndSupply(IFraxPair pool, uint256 borrowAmount, uint256 collateralAmount)
39              external
40              onlyManager
41              nonReentrant
42          {
43              bytes32 positionId =
44                  registry.calculatePositionId(address(this), COLLATERAL_AND_DEBT_POSITION_TYPE, abi.encode(pool));
45              IERC20 token = IERC20(pool.collateralContract());
46              if (collateralAmount > 0) {
47                  _approveOperations(address(token), address(pool), collateralAmount);
48              }
49              if (borrowAmount > 0) {
50                  pool.borrowAsset(borrowAmount, collateralAmount, address(this));
51                  _updateTokenInRegistry(pool.asset());
52              } else if (collateralAmount > 0) {
53                  pool.addCollateral(collateralAmount, address(this));
54              }
55              if (collateralAmount > 0) {
56                  _updateTokenInRegistry(address(token));
57              }
58              registry.updateHoldingPosition(vaultId, positionId, "", "", false);
59              verifyHealthFactor(pool);
60              emit BorrowAndSupply(address(pool), borrowAmount, collateralAmount);
61          }
68          function withdraw(IFraxPair pool, uint256 withdrawAmount) public onlyManager nonReentrant {
69              uint256 currentCollateral = pool.userCollateralBalance(address(this));
70              if (withdrawAmount == currentCollateral) {
71                  bytes32 positionId =
72                      registry.calculatePositionId(address(this), COLLATERAL_AND_DEBT_POSITION_TYPE, abi.encode(pool));
73      
74                  registry.updateHoldingPosition(vaultId, positionId, "", "", true);
75              }
76              pool.removeCollateral(withdrawAmount, address(this));
77              _updateTokenInRegistry(pool.collateralContract());
78              verifyHealthFactor(pool);
79              emit Withdraw(address(pool), withdrawAmount);
80          }
87          function repay(IFraxPair pool, uint256 sharesToRepay) public onlyManager nonReentrant {
88              uint256 repayTokenAmount = pool.toBorrowAmount(sharesToRepay, true);
89              uint256 sharesOwed = pool.userBorrowShares(address(this));
90              address asset = pool.asset();
91              if (sharesToRepay > sharesOwed) {
92                  revert IConnector_InvalidInput();
93              }
94              _approveOperations(asset, address(pool), repayTokenAmount);
95              IFraxPair(pool).repayAsset(sharesToRepay, address(this));
96              _updateTokenInRegistry(asset);
97              emit Repay(address(pool), sharesToRepay);
98          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


41          function closeAccount(address facade, address creditAccount) public onlyManager nonReentrant {
42              ICreditFacadeV3(facade).closeCreditAccount(creditAccount, new MultiCall[](0));
43      
44              registry.updateHoldingPosition(
45                  vaultId,
46                  registry.calculatePositionId(address(this), GEARBOX_POSITION_ID, abi.encode(facade)),
47                  abi.encode(creditAccount),
48                  "",
49                  true
50              );
51              emit CloseAccount(facade, creditAccount);
52          }
62          function executeCommands(
63              address facade,
64              address creditAccount,
65              MultiCall[] calldata calls,
66              address approvalToken,
67              uint256 amount
68          ) public onlyManager nonReentrant {
69              for (uint256 i = 0; i < calls.length; i++) {
70                  if (calls[i].target != facade) revert IConnector_InvalidTarget(calls[i].target);
71                  bytes4 method = bytes4(calls[i].callData[:4]);
72      
73                  if (method == ICreditFacadeV3Multicall.enableToken.selector) {
74                      (address token) = abi.decode(calls[i].callData[4:], (address));
75                      _updateTokenInRegistry(token);
76                  }
77              }
78              if (approvalToken != address(0)) {
79                  _approveOperations(approvalToken, ICreditFacadeV3(facade).creditManager(), amount);
80              }
81              ICreditFacadeV3(facade).multicall(creditAccount, calls);
82              if (approvalToken != address(0)) {
83                  _revokeApproval(approvalToken, ICreditFacadeV3(facade).creditManager());
84              }
85              emit ExecuteCommands(facade, creditAccount, calls, approvalToken, amount);
86          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


37          function deposit(uint256 amountIn) external onlyManager nonReentrant {
38              IWETH(weth).withdraw(amountIn);
39              // deposit recieved eth into Lido
40              // refferal address can be different
41              ILido(lido).submit{ value: amountIn }(address(0));
42              _updateTokenInRegistry(steth);
43              _updateTokenInRegistry(weth);
44              emit Deposit(amountIn);
45          }
51          function requestWithdrawals(uint256 amount) public onlyManager nonReentrant {
52              _approveOperations(steth, lidoWithdrawal, amount);
53              // prepare inputs for requestWithdrawals
54              uint256[] memory amounts = new uint256[](1);
55              amounts[0] = amount;
56              // request for withdrawal
57              uint256[] memory requestIds = ILidoWithdrawal(lidoWithdrawal).requestWithdrawals(amounts, address(this));
58              bytes32 positionId = registry.calculatePositionId(address(this), LIDO_WITHDRAWAL_REQUEST_ID, "");
59              registry.updateHoldingPosition(vaultId, positionId, abi.encode(requestIds[0]), abi.encode(amount), false);
60      
61              _updateTokenInRegistry(steth);
62              emit RequestWithdrawals(amount);
63          }
69          function claimWithdrawal(uint256 requestId) public onlyManager nonReentrant {
70              // approve to lidoWithdrawal to spend withdrawal NFT
71              ILidoWithdrawal(lidoWithdrawal).approve(lidoWithdrawal, requestId);
72              // eth balance before claim
73              uint256 beforeClaimBalance = address(this).balance;
74              // claim request withdrawal
75              ILidoWithdrawal(lidoWithdrawal).claimWithdrawal(requestId);
76              // emit ClaimWithdrawal event
77              IWETH(weth).deposit{ value: address(this).balance - beforeClaimBalance }();
78              registry.updateHoldingPosition(
79                  vaultId,
80                  registry.calculatePositionId(address(this), LIDO_WITHDRAWAL_REQUEST_ID, ""),
81                  abi.encode(requestId),
82                  "",
83                  true
84              );
85              _updateTokenInRegistry(weth);
86              emit ClaimWithdrawal(requestId);
87          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


64          function stake(uint256 amount, uint256 duration, bool doDelegation) external onlyManager nonReentrant {
65              // approve veMav to spend mav
66              _approveOperations(mav, veMav, amount);
67              // stake mav
68              IveMAV(veMav).stake(amount, duration, doDelegation);
69              _updateTokenInRegistry(mav);
70              _updateTokenInRegistry(veMav);
71              emit Stake(amount, duration, doDelegation);
72          }
78          function unstake(uint256 lockupId) external onlyManager nonReentrant {
79              // unstake veMav
80              IveMAV(veMav).unstake(lockupId);
81              _updateTokenInRegistry(mav);
82              _updateTokenInRegistry(veMav);
83              emit Unstake(lockupId);
84          }
91          function addLiquidityInMaverickPool(MavericAddLiquidityParams calldata p) external onlyManager nonReentrant {
92              uint256 sendEthAmount = p.ethPoolIncluded ? p.tokenARequiredAllowance : 0;
93              _approveOperations(p.pool.tokenA(), maverickRouter, p.tokenARequiredAllowance); // TODO: check token A is eth
94              _approveOperations(p.pool.tokenB(), maverickRouter, p.tokenBRequiredAllowance);
95              // add liquidity
96              uint256 tokenId;
97              {
98                  (tokenId,,,) = IMaverickRouter(maverickRouter).addLiquidityToPool{ value: sendEthAmount }(
99                      p.pool, 0, p.params, p.minTokenAAmount, p.minTokenBAmount, p.deadline
100                 );
101             }
102             registry.updateHoldingPosition(
103                 vaultId, registry.calculatePositionId(address(this), MAVERICK_LP, abi.encode(p.pool)), "", "", false
104             );
105             _updateTokenInRegistry(p.pool.tokenA());
106             _updateTokenInRegistry(p.pool.tokenB());
107             emit AddLiquidityInMaverickPool(p);
108         }
115         function removeLiquidityFromMaverickPool(MavericRemoveLiquidityParams calldata p)
116             external
117             onlyManager
118             nonReentrant
119         {
120             IMaverickPosition position = IMaverickRouter(maverickRouter).position();
121             position.approve(maverickRouter, p.tokenId);
122             IMaverickRouter(maverickRouter).removeLiquidity(
123                 p.pool, address(this), p.tokenId, p.params, p.minTokenAAmount, p.minTokenBAmount, p.deadline
124             );
125             registry.updateHoldingPosition(
126                 vaultId, registry.calculatePositionId(address(this), MAVERICK_LP, abi.encode(p.pool)), "", "", true
127             );
128             _updateTokenInRegistry(p.pool.tokenA());
129             _updateTokenInRegistry(p.pool.tokenB());
130             emit RemoveLiquidityFromMaverickPool(p);
131         }
137         function claimBoostedPositionRewards(IMaverickReward rewardContract) external onlyManager nonReentrant {
138             IMaverickReward.EarnedInfo[] memory earnedInfo = rewardContract.earned(address(this));
139             uint8 tokenIndex;
140             for (uint256 i = 0; i < earnedInfo.length; i++) {
141                 if (earnedInfo[i].earned != 0) {
142                     tokenIndex = rewardContract.tokenIndex(address(earnedInfo[i].rewardToken));
143                     rewardContract.getReward(address(this), tokenIndex);
144                 }
145             }
146             emit ClaimBoostedPositionRewards(rewardContract);
147         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


35          function supply(uint256 amount, Id id, bool sOrC) external onlyManager nonReentrant {
36              MarketParams memory params = morphoBlue.idToMarketParams(id);
37              if (sOrC) {
38                  _approveOperations(params.loanToken, address(morphoBlue), amount);
39                  morphoBlue.supply(params, amount, 0, address(this), "");
40                  _updateTokenInRegistry(params.loanToken);
41              } else {
42                  _approveOperations(params.collateralToken, address(morphoBlue), amount);
43                  morphoBlue.supplyCollateral(params, amount, address(this), "");
44                  _updateTokenInRegistry(params.collateralToken);
45              }
46              registry.updateHoldingPosition(
47                  vaultId, registry.calculatePositionId(address(this), MORPHO_POSITION_ID, abi.encode(id)), "", "", false
48              );
49              emit Supply(amount, id, sOrC);
50          }
58          function withdraw(uint256 amount, Id id, bool sOrC) external onlyManager nonReentrant {
59              MarketParams memory params = morphoBlue.idToMarketParams(id);
60              if (sOrC) {
61                  morphoBlue.withdraw(params, amount, 0, address(this), address(this));
62              } else {
63                  morphoBlue.withdrawCollateral(params, amount, address(this), address(this));
64              }
65              Position memory p = morphoBlue.position(id, address(this));
66              if (p.collateral == 0 && p.supplyShares == 0) {
67                  registry.updateHoldingPosition(
68                      vaultId, registry.calculatePositionId(address(this), MORPHO_POSITION_ID, abi.encode(id)), "", "", true
69                  );
70              }
71              _updateTokenInRegistry(params.collateralToken);
72              emit Withdraw(amount, id, sOrC);
73          }
80          function borrow(uint256 amount, Id id) external onlyManager nonReentrant {
81              MarketParams memory market = morphoBlue.idToMarketParams(id);
82              morphoBlue.borrow(market, amount, 0, address(this), address(this));
83              if (getHealthFactor(id, morphoBlue.market(id)) < minimumHealthFactor) {
84                  revert IConnector_LowHealthFactor(getHealthFactor(id, morphoBlue.market(id)));
85              }
86              _updateTokenInRegistry(market.loanToken);
87              emit Borrow(amount, id);
88          }
95          function repay(uint256 amount, Id id) public onlyManager nonReentrant {
96              MarketParams memory params = morphoBlue.idToMarketParams(id);
97              _approveOperations(params.loanToken, address(morphoBlue), amount);
98              morphoBlue.repay(params, amount, 0, address(this), "");
99              _updateTokenInRegistry(params.loanToken);
100             emit Repay(amount, id);
101         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


31          function sendPositionToMasterChef(uint256 tokenId) external onlyManager nonReentrant {
32              IERC721(address(positionManager)).safeTransferFrom(address(this), address(masterchef), tokenId);
33              emit SendPositionToMasterChef(tokenId);
34          }
40          function updatePosition(uint256 tokenId) public onlyManager nonReentrant {
41              masterchef.updateLiquidity(tokenId);
42              _updateTokenInRegistry(masterchef.CAKE());
43              emit UpdatePosition(tokenId);
44          }
50          function withdraw(uint256 tokenId) public onlyManager nonReentrant {
51              masterchef.withdraw(tokenId, address(this));
52              _updateTokenInRegistry(masterchef.CAKE());
53              emit Withdraw(tokenId);
54          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


78          function supply(address market, uint256 amount) external onlyManager nonReentrant {
79              (IPStandardizedYield _SY, IPPrincipalToken _PT,) = IPMarket(market).readTokens();
80      
81              (, address _underlyingToken,) = _SY.assetInfo();
82      
83              _approveOperations(_underlyingToken, address(_SY), amount);
84              // Mint SY from underlying token
85              uint256 syMinted = _SY.deposit(address(this), _underlyingToken, amount, 1);
86      
87              bytes32 positionId = registry.calculatePositionId(address(this), PENDLE_POSITION_ID, abi.encode(market));
88              registry.updateHoldingPosition(vaultId, positionId, "", "", false);
89              emit Supply(market, syMinted);
90          }
97          function mintPTAndYT(address market, uint256 syAmount) external onlyManager nonReentrant {
98              (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
99              IERC20(address(_SY)).safeTransfer(address(_YT), syAmount);
100             _YT.mintPY(address(this), address(this));
101             emit MintPTAndYT(market, syAmount);
102         }
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
113             (IPStandardizedYield _SY, IPPrincipalToken _PT,) = IPMarket(market).readTokens();
114             IERC20(address(_SY)).safeTransfer(address(market), SYamount);
115             IERC20(address(_PT)).safeTransfer(address(market), PTamount);
116             market.mint(address(this), SYamount, PTamount);
117             market.skim();
118             emit DepositIntoMarket(address(market), SYamount, PTamount);
119         }
126         function depositIntoPenpie(address _market, uint256 _amount) public onlyManager nonReentrant {
127             _approveOperations(_market, pendleMarketDepositHelper.pendleStaking(), _amount);
128             pendleMarketDepositHelper.depositMarket(_market, _amount);
129             emit DepositIntoPenpie(_market, _amount);
130         }
137         function withdrawFromPenpie(address _market, uint256 _amount) public onlyManager nonReentrant {
138             pendleMarketDepositHelper.withdrawMarketWithClaim(_market, _amount, true);
139             emit WithdrawFromPenpie(_market, _amount);
140         }
183         function swapExactPTForSY(IPMarket market, uint256 exactPTIn, bytes calldata swapData, uint256 minSY)
184             external
185             onlyManager
186             nonReentrant
187         {
188             (IPStandardizedYield _SY, IPPrincipalToken _PT,) = IPMarket(market).readTokens();
189             IERC20(address(_PT)).safeTransfer(address(market), exactPTIn);
190             (uint256 netSyOut, uint256 netSyFee) = market.swapExactPtForSy(address(this), exactPTIn, swapData);
191             if (netSyOut < minSY) {
192                 revert InsufficientSyOut(netSyOut, minSY);
193             }
194             market.skim();
195             emit SwapExactPTForSY(address(market), exactPTIn, swapData, minSY);
196         }
203         function burnLP(IPMarket market, uint256 amount) external onlyManager nonReentrant {
204             IERC20(address(market)).safeTransfer(address(market), amount);
205             market.burn(address(this), address(market), amount);
206             market.skim();
207             emit BurnLP(address(market), amount);
208         }
216         function decreasePosition(IPMarket market, uint256 _amount, bool closePosition) external onlyManager nonReentrant {
217             (IPStandardizedYield SY,,) = market.readTokens();
218             (, address _underlyingToken,) = SY.assetInfo();
219     
220             // redeems an amount of base tokens by burning SY
221             IERC20(address(SY)).safeTransfer(address(SY), _amount);
222             IPStandardizedYield(address(SY)).redeem(address(this), _amount, _underlyingToken, 1, true);
223             if (closePosition && isMarketEmpty(market)) {
224                 registry.updateHoldingPosition(
225                     vaultId,
226                     registry.calculatePositionId(address(this), PENDLE_POSITION_ID, abi.encode(market)),
227                     "",
228                     "",
229                     true
230                 );
231             }
232             emit DecreasePosition(address(market), _amount, closePosition);
233         }
241         function claimRewards(IPMarket market) external onlyManager nonReentrant {
242             market.redeemRewards(address(this));
243             address[] memory rewardTokens = market.getRewardTokens();
244             for (uint256 i = 0; i < rewardTokens.length; i++) {
245                 _updateTokenInRegistry(rewardTokens[i]);
246             }
247             emit ClaimRewards(address(market));
248         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


33          function approveZap(IStakeNTroveZap zap, address tm, bool approve) public onlyManager nonReentrant {
34              if (approve) {
35                  bytes32 positionId = registry.calculatePositionId(address(this), PRISMA_POSITION_ID, abi.encode(zap, tm));
36      
37                  if (!registry.isPositionTrustedForConnector(vaultId, positionId, address(this))) {
38                      revert IConnector_InvalidPosition(positionId);
39                  }
40              }
41              IBorrowerOperations(zap.borrowerOps()).setDelegateApproval(address(zap), approve);
42          }
52          function openTrove(IStakeNTroveZap zap, address tm, uint256 maxFee, uint256 dAmount, uint256 bAmount)
53              public
54              onlyManager
55              nonReentrant
56          {
57              bytes32 positionId = registry.calculatePositionId(address(this), PRISMA_POSITION_ID, abi.encode(zap, tm));
58              PositionBP memory positionInfo = registry.getPositionBP(vaultId, positionId);
59              address collateral = abi.decode(positionInfo.additionalData, (address));
60              address debTtoken = ITroveManager(tm).debtToken();
61              _approveOperations(collateral, address(zap), dAmount);
62              zap.openTrove(tm, maxFee, dAmount, bAmount, address(this), address(this));
63              registry.updateHoldingPosition(vaultId, positionId, "", "", false);
64              _updateTokenInRegistry(collateral);
65              _updateTokenInRegistry(debTtoken);
66              emit OpenTrove(address(zap), tm, maxFee, dAmount, bAmount);
67          }
75          function addColl(IStakeNTroveZap zapContract, address tm, uint256 amountIn) public onlyManager nonReentrant {
76              bytes32 positionId =
77                  registry.calculatePositionId(address(this), PRISMA_POSITION_ID, abi.encode(zapContract, tm));
78              PositionBP memory positionInfo = registry.getPositionBP(vaultId, positionId);
79              if (registry.getHoldingPositionIndex(vaultId, positionId, address(this), "") == 0) {
80                  revert IConnector_InvalidPosition(positionId);
81              }
82              address collateral = abi.decode(positionInfo.additionalData, (address));
83              _approveOperations(collateral, address(zapContract), amountIn);
84              zapContract.addColl(tm, amountIn, address(this), address(this));
85              emit AddColl(address(zapContract), tm, amountIn);
86          }
97          function adjustTrove(
98              IStakeNTroveZap zapContract,
99              address tm,
100             uint256 mFee,
101             uint256 wAmount,
102             uint256 bAmount,
103             bool isBorrowing
104         ) public onlyManager nonReentrant {
105             bytes32 positionId =
106                 registry.calculatePositionId(address(this), PRISMA_POSITION_ID, abi.encode(zapContract, tm));
107             if (registry.getHoldingPositionIndex(vaultId, positionId, address(this), "") == 0) {
108                 revert IConnector_InvalidPosition(positionId);
109             }
110             IBorrowerOperations borrowerOps = zapContract.borrowerOps();
111             if (bAmount > 0 && !isBorrowing) {
112                 _approveOperations(ITroveManager(tm).debtToken(), address(borrowerOps), bAmount);
113             }
114             borrowerOps.adjustTrove(tm, address(this), mFee, 0, wAmount, bAmount, isBorrowing, address(this), address(this));
115             _updateTokenInRegistry(ITroveManager(tm).debtToken());
116             // get health factor
117             uint256 healthFactor = ITroveManager(tm).getNominalICR(address(this));
118             if (minimumHealthFactor > healthFactor) {
119                 revert IConnector_LowHealthFactor(healthFactor);
120             }
121             emit AdjustTrove(address(zapContract), tm, mFee, wAmount, bAmount, isBorrowing);
122         }
129         function closeTrove(IStakeNTroveZap zapContract, address troveManager) public onlyManager nonReentrant {
130             bytes32 positionId =
131                 registry.calculatePositionId(address(this), PRISMA_POSITION_ID, abi.encode(zapContract, troveManager));
132             IBorrowerOperations borrowerOperations = zapContract.borrowerOps();
133             borrowerOperations.closeTrove(troveManager, address(this));
134             registry.updateHoldingPosition(vaultId, positionId, "", "", true);
135             emit CloseTrove(address(zapContract), troveManager);
136         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


33          function deposit(address siloToken, address dToken, uint256 amount, bool oC) external onlyManager nonReentrant {
34              ISilo silo = ISilo(siloRepository.getSilo(siloToken));
35              _approveOperations(dToken, address(silo), amount);
36              silo.deposit(dToken, amount, oC);
37              _updateTokenInRegistry(dToken);
38              registry.updateHoldingPosition(
39                  vaultId, registry.calculatePositionId(address(this), SILO_LP_ID, abi.encode(siloToken)), "", "", false
40              );
41              emit Deposit(siloToken, dToken, amount, oC);
42          }
52          function withdraw(address siloToken, address wToken, uint256 amount, bool oC, bool closePosition)
53              external
54              onlyManager
55              nonReentrant
56          {
57              ISilo silo = ISilo(siloRepository.getSilo(siloToken));
58              silo.withdraw(wToken, amount, oC);
59              _updateTokenInRegistry(wToken);
60              if (closePosition && isSiloEmpty(silo)) {
61                  registry.updateHoldingPosition(
62                      vaultId, registry.calculatePositionId(address(this), SILO_LP_ID, abi.encode(siloToken)), "", "", true
63                  );
64              }
65              if (!SolvencyV2.isSolvent(silo, address(this), minimumHealthFactor)) {
66                  revert IConnector_LowHealthFactor(0);
67              }
68              emit Withdraw(siloToken, wToken, amount, oC, closePosition);
69          }
85          function borrow(address siloToken, address bToken, uint256 amount) external onlyManager nonReentrant {
86              ISilo silo = ISilo(siloRepository.getSilo(siloToken));
87              silo.borrow(bToken, amount);
88              _updateTokenInRegistry(bToken);
89              emit Borrow(siloToken, bToken, amount);
90          }
98          function repay(address siloToken, address rToken, uint256 amount) external onlyManager nonReentrant {
99              ISilo silo = ISilo(siloRepository.getSilo(siloToken));
100             _approveOperations(rToken, address(silo), amount);
101             silo.repay(rToken, amount);
102             _updateTokenInRegistry(rToken);
103             if (!SolvencyV2.isSolvent(silo, address(this), minimumHealthFactor)) {
104                 revert IConnector_LowHealthFactor(0);
105             }
106             emit Repay(siloToken, rToken, amount);
107         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


49          function depositIntoStargatePool(StargateRequest calldata depositRequest) external onlyManager nonReentrant {
50              address lpAddress = LPStaking.poolInfo(depositRequest.poolId).lpToken;
51              address underlyingToken = IStargatePool(lpAddress).token();
52              if (depositRequest.routerAmount > 0) {
53                  _approveOperations(underlyingToken, address(stargateRouter), depositRequest.routerAmount);
54                  stargateRouter.addLiquidity(depositRequest.poolId, depositRequest.routerAmount, address(this));
55                  _updateTokenInRegistry(underlyingToken);
56              }
57              if (depositRequest.LPStakingAmount > 0) {
58                  uint256 stakingAmount = depositRequest.LPStakingAmount;
59                  if (depositRequest.LPStakingAmount == type(uint256).max) {
60                      stakingAmount = IERC20(lpAddress).balanceOf(address(this));
61                  }
62                  _approveOperations(lpAddress, address(LPStaking), stakingAmount);
63                  LPStaking.deposit(depositRequest.poolId, stakingAmount);
64              }
65              _updateTokenInRegistry(rewardToken);
66              bytes32 positionId =
67                  registry.calculatePositionId(address(this), STARGATE_LP_POSITION_TYPE, abi.encode(depositRequest.poolId));
68              registry.updateHoldingPosition(vaultId, positionId, "", "", false);
69              emit DepositIntoStargatePool(depositRequest);
70          }
76          function withdrawFromStargatePool(StargateRequest calldata withdrawRequest) external onlyManager nonReentrant {
77              address lpAddress = LPStaking.poolInfo(withdrawRequest.poolId).lpToken;
78              address underlyingToken = IStargatePool(lpAddress).token();
79              if (withdrawRequest.LPStakingAmount > 0) {
80                  IStargateLPStaking(LPStaking).withdraw(withdrawRequest.poolId, withdrawRequest.LPStakingAmount);
81              }
82              if (withdrawRequest.routerAmount > 0) {
83                  stargateRouter.instantRedeemLocal(
84                      uint16(withdrawRequest.poolId), withdrawRequest.routerAmount, address(this)
85                  );
86                  _updateTokenInRegistry(underlyingToken);
87              }
88              uint256 LPAmount = LPStaking.userInfo(withdrawRequest.poolId, address(this)).amount;
89              if (IERC20(lpAddress).balanceOf(address(this)) + LPAmount == 0) {
90                  bytes32 positionId = registry.calculatePositionId(
91                      address(this), STARGATE_LP_POSITION_TYPE, abi.encode(withdrawRequest.poolId)
92                  );
93                  registry.updateHoldingPosition(vaultId, positionId, "", "", true);
94              }
95              _updateTokenInRegistry(rewardToken);
96              emit WithdrawFromStargatePool(withdrawRequest);
97          }
103         function claimStargateRewards(uint256 poolId) external onlyManager nonReentrant {
104             LPStaking.deposit(poolId, 0);
105             _updateTokenInRegistry(rewardToken);
106             emit ClaimStargateRewards(poolId);
107         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


40          function openPosition(MintParams memory p) external onlyManager nonReentrant returns (uint256 tokenId) {
41              bytes32 positionId =
42                  registry.calculatePositionId(address(this), UNI_LP_POSITION_TYPE, abi.encode(p.token0, p.token1));
43              p.recipient = address(this);
44              // Approve NonfungiblePositionManager to spend `token0` and `token1`.
45              _approveOperations(p.token0, address(positionManager), p.amount0Desired);
46              _approveOperations(p.token1, address(positionManager), p.amount1Desired);
47      
48              // Supply liquidity to pool.
49              (tokenId,,,) = positionManager.mint(p);
50              bytes memory positionData = abi.encode(tokenId);
51              registry.updateHoldingPosition(
52                  vaultId, positionId, positionData, abi.encode(p.tickLower, p.tickUpper, p.fee), false
53              );
54              _updateTokenInRegistry(p.token0);
55              _updateTokenInRegistry(p.token1);
56              emit OpenPosition(p, tokenId);
57          }
63          function decreasePosition(DecreaseLiquidityParams memory p) external onlyManager nonReentrant {
64              (uint128 currentLiquidity, address token0, address token1) = getCurrentLiquidity(p.tokenId);
65              if (p.liquidity > currentLiquidity) {
66                  revert IConnector_InvalidAmount();
67              }
68              positionManager.decreaseLiquidity(p);
69              _collectFees(p.tokenId);
70              _updateTokenInRegistry(token0);
71              _updateTokenInRegistry(token1);
72      
73              if (currentLiquidity == p.liquidity) {
74                  positionManager.burn(p.tokenId);
75                  bytes32 positionId =
76                      registry.calculatePositionId(address(this), UNI_LP_POSITION_TYPE, abi.encode(token0, token1));
77                  bytes memory positionData = abi.encode(p.tokenId);
78                  registry.updateHoldingPosition(vaultId, positionId, positionData, "", true);
79              }
80              emit DecreasePosition(p);
81          }
87          function increasePosition(IncreaseLiquidityParams memory p) external onlyManager nonReentrant {
88              (, address token0, address token1) = getCurrentLiquidity(p.tokenId);
89              // Approve NonfungiblePositionManager to spend `token0` and `token1`.
90              _approveOperations(token0, address(positionManager), p.amount0Desired);
91              _approveOperations(token1, address(positionManager), p.amount1Desired);
92              positionManager.increaseLiquidity(p);
93              _updateTokenInRegistry(token0);
94              _updateTokenInRegistry(token1);
95              emit IncreasePosition(p);
96          }
101         function collectAllFees(uint256[] memory tokenIds) public onlyManager nonReentrant {
102             for (uint256 i = 0; i < tokenIds.length; i++) {
103                 (, address token0, address token1) = getCurrentLiquidity(tokenIds[i]);
104                 _collectFees(tokenIds[i]);
105                 _updateTokenInRegistry(token0);
106                 _updateTokenInRegistry(token1);
107                 emit CollectFees(tokenIds[i]);
108             }
109         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


122         function transferPositionToAnotherConnector(
123             address[] memory tokens,
124             uint256[] memory amounts,
125             bytes memory data,
126             address connector
127         ) external onlyManager nonReentrant {
128             emit TransferPositionToConnector(tokens, amounts, connector, data);
129             if (registry.isAnActiveConnector(vaultId, connector)) {
130                 IConnector(connector).addLiquidity(tokens, amounts, data);
131             }
132         }
204         function swapHoldings(
205             address[] memory tokensIn,
206             address[] memory tokensOut,
207             uint256[] memory amountsIn,
208             bytes[] memory swapData,
209             uint256[] memory routeIds
210         ) external onlyManager nonReentrant {
211             for (uint256 i = 0; i < tokensIn.length; i++) {
212                 _executeSwap(
213                     SwapRequest(address(this), routeIds[i], amountsIn[i], tokensIn[i], tokensOut[i], swapData[i], true, 0)
214                 );
215                 _updateTokenInRegistry(tokensIn[i]);
216                 _updateTokenInRegistry(tokensOut[i]);
217                 emit SwapHoldings(tokensIn[i], tokensOut[i], amountsIn[i], swapData[i]);
218             }
219         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


68          function startBridgeTransaction(BridgeRequest memory bridgeRequest) public onlyManager nonReentrant {
69              bytes32 txn = keccak256(abi.encode(bridgeRequest));
70              emit StartBridgeTransaction(bridgeRequest, txn);
71              if (approvedBridgeTXN[txn] == 0 || approvedBridgeTXN[txn] + BRIDGE_TXN_WAITING_TIME > block.timestamp) {
72                  revert IConnector_BridgeTransactionNotApproved(txn);
73              }
74              if (bridgeRequest.from != address(this)) revert IConnector_InvalidInput();
75              if (
76                  destChainAddress[bridgeRequest.destChainId] == address(0)
77                      || destChainAddress[bridgeRequest.destChainId] != bridgeRequest.receiverAddress
78              ) {
79                  revert IConnector_InvalidDestinationChain();
80              }
81              approvedBridgeTXN[txn] = 0;
82              swapHandler.executeBridge(bridgeRequest);
83              _updateTokenInRegistry(bridgeRequest.inputToken);
84          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


90          function executeSwap(SwapRequest memory _swapRequest)
91              external
92              payable
93              onlyEligibleUser
94              onlyExistingRoute(_swapRequest.routeId)
95              nonReentrant
96              returns (uint256 _amountOut)
97          {
98              if (_swapRequest.amount == 0) revert InvalidAmount();
99              RouteData memory swapImplInfo = routes[_swapRequest.routeId];
100             if (swapImplInfo.isBridge) revert RouteNotAllowedForThisAction();
101     
102             if (_swapRequest.checkForSlippage && _swapRequest.minAmount == 0) {
103                 // set minAmount so that slippage can be checked
104                 uint256 _slippageTolerance = slippageTolerance[_swapRequest.inputToken][_swapRequest.outputToken];
105                 if (_slippageTolerance == 0) {
106                     _slippageTolerance = genericSlippageTolerance;
107                 }
108                 INoyaValueOracle _priceOracle = INoyaValueOracle(valueOracle);
109                 uint256 _outputTokenValue =
110                     _priceOracle.getValue(_swapRequest.inputToken, _swapRequest.outputToken, _swapRequest.amount);
111     
112                 _swapRequest.minAmount = (((1e6 - _slippageTolerance) * _outputTokenValue) / 1e6);
113             }
114     
115             _amountOut = ISwapAndBridgeImplementation(swapImplInfo.route).performSwapAction(msg.sender, _swapRequest);
116     
117             emit ExecutionCompleted(
118                 _swapRequest.routeId, _swapRequest.amount, _amountOut, _swapRequest.inputToken, _swapRequest.outputToken
119             );
120         }
126         function executeBridge(BridgeRequest calldata _bridgeRequest)
127             external
128             payable
129             onlyEligibleUser
130             onlyExistingRoute(_bridgeRequest.routeId)
131             nonReentrant
132         {
133             RouteData memory bridgeImplInfo = routes[_bridgeRequest.routeId];
134     
135             if (!bridgeImplInfo.isBridge) revert RouteNotAllowedForThisAction();
136     
137             ISwapAndBridgeImplementation(bridgeImplInfo.route).performBridgeAction(msg.sender, _bridgeRequest);
138     
139             emit BridgeExecutionCompleted(_bridgeRequest);
140         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

</details>

## NC003 - `require()`/`revert()` statements should have descriptive reason strings:

Ensure that `require()` and `revert()` statements include a reason string for better error reporting.


<details>
<summary>Click to show 26 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


106             require(p._baseTokenAddress != address(0));
107             require(p._valueOracle != address(0));
108             require(p._withdrawFeeReceiver != address(0));
109             require(p._performanceFeeReceiver != address(0));
110             require(p._managementFeeReceiver != address(0));
125             require(address(_valueOracle) != address(0));
140             require(_withdrawFeeReceiver != address(0));
141             require(_performanceFeeReceiver != address(0));
142             require(_managementFeeReceiver != address(0));
361             require(currentWithdrawGroup.isStarted == false && currentWithdrawGroup.isFullfilled == false);
371             require(currentWithdrawGroup.isStarted == true && currentWithdrawGroup.isFullfilled == false);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


15              require(_accountingManager != address(0));
16              require(_baseToken != address(0));
17              require(_receiver != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


67              require(_governer != address(0));
68              require(_maintainer != address(0));
69              require(_emergency != address(0));
80              require(_maxNumHoldingPositions <= MAX_NUM_HOLDING_POSITIONS);
120             require(_governer != address(0));
121             require(_accountingManager != address(0));
122             require(_baseToken != address(0));
123             require(_maintainer != address(0));
124             require(_keeperContract != address(0));
125             require(_watcher != address(0));
167             require(_governer != address(0));
168             require(_maintainer != address(0));
169             require(_keeperContract != address(0));
170             require(_watcher != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


36              require(_pool != address(0));
37              require(_poolBaseToken != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


43              require(_router != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


45              require(_balancerVault != address(0));
46              require(bal != address(0));
47              require(aura != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


25              require(_balancerVault != address(0));
26              require(address(_registry) != address(0));
61              require(msg.sender == address(vault));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


37              require(_router != address(0));
38              require(_factory != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


52              require(_convexBooster != address(0));
53              require(cvx != address(0));
54              require(crv != address(0));
55              require(prisma != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


24              require(_depositWithdrawalProxy != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


23              require(_lido != address(0));
24              require(_lidoW != address(0));
25              require(_steth != address(0));
26              require(w != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


46              require(_mav != address(0));
47              require(_veMav != address(0));
48              require(mr != address(0));
49              require(pi != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


24              require(MB != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


22              require(MC != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


60              require(_pendleMarketDepositHelper != address(0));
61              require(_pendleRouter != address(0));
62              require(SR != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


21              require(_SNXCoreProxy != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


18              require(SR != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


36              require(lpStacking != address(0));
37              require(_stargateRouter != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


28              require(_owners.length <= 10 && _threshold <= _owners.length && _threshold > 1);
53              require(numOwnersTemp <= 10 && threshold <= numOwnersTemp && threshold > 1);
64              require(_threshold <= numOwners && _threshold > 1);
106                     require(recovered > lastAdd && isOwner[recovered]);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/governance/NoyaGovernanceBase.sol


22              require(address(_registry) != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


41              require(lzHelperAddress != address(0));
53              require(omniChainManager != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


52              require(lzHelperAddress != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


37              require(_lzHelper != address(0));
47              require(destinationAddress != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


41              require(_valueOracle != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


30              require(address(_registry) != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


47              require(_reg != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

</details>

## NC004 - Constants should be defined rather than using magic numbers:

Even assembly can benefit from using readable constants instead of hex/numeric literals.


<details>
<summary>Click to show 15 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


82          uint256 public depositWaitingTime = 30 minutes;
84          uint256 public withdrawWaitingTime = 6 hours;
87          uint256 public depositLimitTotalAmount = 1e6 * 200_000;
89          uint256 public depositLimitPerTransaction = 1e6 * 2000;
243                     middleTemp, data.receiver, block.timestamp, shares, data.amount, shares * 1e18 / data.amount
275                     firstTemp, data.receiver, block.timestamp, data.shares, data.amount, data.shares * 1e18 / data.amount
518                 (timePassed * managementFee * (totalShares - currentFeeShares)) / FEE_PRECISION / 365 days;
528                 preformanceFeeSharesWaitingForDistribution == 0 || block.timestamp - profitStoredTime < 12 hours
529                     || block.timestamp - profitStoredTime > 48 hours


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


23          uint256 public maxNumHoldingPositions = 20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


106             if (totalCollateralBase <= DUST_LEVEL * 1e7) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


172             return (((1e18 * token1bal * lpBalance) / _weight) / _totalSupply);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


78              return getCollBlanace(comet, true) * 1e18 / borrowBalanceInBase;
119                     if (riskAdjusted) CollValue += collateralValueInVirtualBase * info.liquidateCollateralFactor / 1e18;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


132             } else if (poolInfo.tokens.length == 3) {
133                 uint256[3] memory amounts;
136             } else if (poolInfo.tokens.length == 4) {
137                 uint256[4] memory amounts;
140             } else if (poolInfo.tokens.length == 5) {
141                 uint256[5] memory amounts;
144             } else if (poolInfo.tokens.length == 6) {
145                 uint256[6] memory amounts;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


136             uint256 currentHF = (fraxlendPairMaxLTV * 1e18) / currentPositionLTV;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


71                  bytes4 method = bytes4(calls[i].callData[:4]);
74                      (address token) = abi.decode(calls[i].callData[4:], (address));
103             return _getValue(address(840), base, (d.totalValueUSD - d.totalDebtUSD));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


271                     SYAmount += lpBalance * IPMarket(market).getLpToAssetRate(10) / 1e18;
275                 if (PTAmount > 0) SYAmount += PTAmount * IPMarket(market).getPtToAssetRate(10) / 1e18;
280                 if (SYAmount > 0) underlyingBalance += SYAmount * _SY.exchangeRate() / 1e18;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


21              MINIMUM_HEALTH_FACTOR = 5e17;
123                 uint256 price = _getValue(assets[i], base, 1e18);
124                 totalDepositAmount += depositAmount * price / 1e18;
125                 totalBAmount += borrowAmount * price / 1e18;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


28          uint256 public MINIMUM_HEALTH_FACTOR = 15e17;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


16          uint256 public genericSlippageTolerance = 50_000; // 5% slippage tolerance
112                 _swapRequest.minAmount = (((1e6 - _slippageTolerance) * _outputTokenValue) / 1e6);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


111             bytes4 selector = bytes4(_request.data[:4]);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


19          uint32 public period = 1800;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/WETH_Oracle.sol


10              return (0, 1e18, 0, block.timestamp, 0);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/WETH_Oracle.sol#L0:0

</details>

## NC005 - Use scientific notation (e.g. 1e18) rather than exponentiation (e.g. 10**18):

While the compiler knows to optimize away the exponentiation, it's still better coding practice to use idioms that do not require compiler optimization, if they exist.


```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


140             return 10 ** decimals;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

## NC006 - Event is not properly indexed:

Index event fields make the field more quickly accessible to off-chain tools that parse events. This is especially useful when it comes to filtering based on an address. However, note that each index field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (three fields). Where applicable, each event should use three indexed fields if there are three or more fields, and gas usage is not particularly of concern for the events in question. If there are fewer than three applicable fields, all of the applicable fields should be indexed.


<details>
<summary>Click to show 13 findings</summary>

```solidity
File: contracts/connectors/AaveConnector.sol


26          event Supply(address supplyToken, uint256 amount);
27          event Borrow(address borrowToken, uint256 amount);
28          event Repay(address repayToken, uint256 amount, uint256 i);
29          event RepayWithCollateral(address repayToken, uint256 amount, uint256 i);
30          event WithdrawCollateral(address collateral, uint256 amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


36          event Supply(address pool, uint256 amount0, uint256 amount1);
37          event Withdraw(address pool, uint256 amountLiquidity);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


10          event Supply(address market, address asset, uint256 amount);
11          event WithdrawOrBorrow(address market, address asset, uint256 amount);
12          event ClaimRewards(address rewardContract, address market);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


33          event OpenCurvePosition(address pool, uint256 depositIndex, uint256 amount, uint256 minAmount);
34          event DecreaseCurvePosition(address pool, uint256 withdrawIndex, uint256 amount, uint256 minAmount);
36          event WithdrawFromConvexRewardPool(address pool, uint256 amount);
37          event WithdrawFromGauge(address pool, uint256 amount);
38          event WithdrawFromPrisma(address depostiToken, uint256 amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


24          event BorrowAndSupply(address pool, uint256 borrowAmount, uint256 collateralAmount);
25          event Withdraw(address pool, uint256 withdrawAmount);
26          event Repay(address pool, uint256 sharesToRepay);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


11          event OpenAccount(address facade, uint256 ref);
12          event CloseAccount(address facade, address creditAccount);
13          event ExecuteCommands(
14              address facade, address creditAccount, MultiCall[] calls, address approvalToken, uint256 amount
15          );


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


35          event Supply(address market, uint256 amount);
36          event MintPTAndYT(address market, uint256 syAmount);
37          event DepositIntoMarket(address market, uint256 SYamount, uint256 PTamount);
38          event DepositIntoPenpie(address market, uint256 amount);
39          event WithdrawFromPenpie(address market, uint256 amount);
40          event SwapYTForPT(address market, uint256 exactYTIn, uint256 min, ApproxParams guess);
41          event SwapYTForSY(address market, uint256 exactYTIn, uint256 min, LimitOrderData orderData);
42          event SwapExactPTForSY(address market, uint256 exactPTIn, bytes swapData, uint256 minSY);
43          event BurnLP(address market, uint256 amount);
44          event DecreasePosition(address market, uint256 amount, bool closePosition);
45          event ClaimRewards(address market);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


16          event OpenTrove(address zap, address tm, uint256 maxFee, uint256 dAmount, uint256 bAmount);
17          event AddColl(address zap, address tm, uint256 amountIn);
18          event AdjustTrove(address zap, address tm, uint256 mFee, uint256 wAmount, uint256 bAmount, bool isBorrowing);
19          event CloseTrove(address zap, address troveManager);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


12          event Deposit(address siloToken, address dToken, uint256 amount, bool oC);
13          event Withdraw(address siloToken, address wToken, uint256 amount, bool oC, bool closePosition);
14          event Borrow(address siloToken, address bToken, uint256 amount);
15          event Repay(address siloToken, address rToken, uint256 amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


24          event UpdateChainInfo(uint256 chainId, address destinationAddress);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


19          event SetValueOracle(address _valueOracle);
20          event SetSlippageTolerance(address _inputToken, address _outputToken, uint256 _slippageTolerance);
21          event AddEligibleUser(address _user);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


20          event AddedHandler(address _handler, bool state);
23          event Bridged(address bridge, address token, uint256 amount, bytes data);
24          event Rescued(address token, address userAddress, uint256 amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


22          event UpdatedPriceRoute(address asset, address baseToken, address[] s);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

</details>

## NC007 - Function ordering does not follow the Solidity style guide:

According to the [Solidity style guide](https://docs.soliditylang.org/en/v0.8.17/style-guide.html#order-of-functions), functions should be laid out in the following order :`constructor()`, `receive()`, `fallback()`, `external`, `public`, `internal`, `private`, but the cases below do not follow this pattern.


<details>
<summary>Click to show 15 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


/// @auditbase public functions should not come before external functions
    function sendTokensToTrustedAddress(address token, uint256 amount, address _caller, bytes calldata _data)
        external
        returns (uint256)
    {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L150:153

```solidity
File: contracts/accountingManager/Registry.sol


/// @auditbase public functions should not come before external functions
    function addTrustedPosition(
        uint256 vaultId,
        uint256 _positionTypeId,
        address calculatorConnector,
        bool onlyOwner,
        bool _isDebt,
        bytes calldata _data,
        bytes calldata _additionalData
    ) external onlyVaultMaintainerWithoutTimeLock(vaultId) vaultExists(vaultId) nonReentrant {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L238:246

```solidity
File: contracts/connectors/CurveConnector.sol


/// @auditbase internal functions should not come before public functions
    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L265:265

```solidity
File: contracts/connectors/FraxConnector.sol


/// @auditbase internal functions should not come before public functions
    function _getUnderlyingTokens(uint256 p, bytes memory data) public view override returns (address[] memory) {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L142:142

```solidity
File: contracts/connectors/LidoConnector.sol


/// @auditbase public functions should not come before external functions
    receive() external payable { }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L89:89

```solidity
File: contracts/connectors/PendleConnector.sol


/// @auditbase public functions should not come before external functions
    function swapYTForPT(address market, uint256 exactYTIn, uint256 min, ApproxParams memory guess)
        external
        onlyManager
    {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L149:152

```solidity
File: contracts/connectors/SNXConnector.sol


/// @auditbase public functions should not come before external functions
    function onERC721Received(address, address, uint256, bytes memory) external pure override returns (bytes4) {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L64:64

```solidity
File: contracts/connectors/SiloConnector.sol


/// @auditbase public functions should not come before external functions
    function borrow(address siloToken, address bToken, uint256 amount) external onlyManager nonReentrant {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L85:85

```solidity
File: contracts/connectors/UNIv3Connector.sol


/// @auditbase internal functions should not come before public functions
    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L127:127

```solidity
File: contracts/helpers/BaseConnector.sol


/// @auditbase internal functions should not come before public functions
    function updateTokenInRegistry(address token) public onlyManager {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L153:153

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


/// @auditbase internal functions should not come before public functions
    function setChainInfo(uint256 chainId, uint32 lzChainId, address lzHelperAddress) public onlyOwner {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L51:51

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol


/// @auditbase public functions should not come before external functions
    function updateTVLInfo() external onlyManager {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol#L28:28

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


/// @auditbase public functions should not come before external functions
    function setEnableRoute(uint256 _routeId, bool enable) external onlyMaintainerOrEmergency {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L158:158

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


/// @auditbase public functions should not come before external functions
    function performBridgeAction(address caller, BridgeRequest calldata _request)
        external
        payable
        override
        onlyHandler
    {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L133:138

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


/// @auditbase public functions should not come before external functions
    function updateAssetPriceSource(address[] calldata asset, address[] calldata baseToken, address[] calldata oracle)
        external
        onlyMaintainer
    {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L51:54

</details>

## NC008 - Imports could be organized more systematically:

This issue arises when the contract's interface is not imported first, followed by each of the interfaces it uses, followed by all other files.


<details>
<summary>Click to show 27 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


6       import "../interface/Accounting/IAccountingManager.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


6       import "../interface/IPositionRegistry.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


5       import { IPool } from "../external/interfaces/Aave/IPool.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


5       import "../external/interfaces/Aerodrome/IPool.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


5       import "../external/interfaces/Balancer/IBalancerVault.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


7       import "../external/interfaces/Camelot/ICamelotRouter.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


5       import { IComet, IRewards } from "../external/interfaces/Compound/ICompound.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


5       import "../external/interfaces/Curve/IRewardsGauge.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


5       import "../external/interfaces/Dolomite/IDepositWithdrawalProxy.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


5       import "../external/interfaces/Frax/IFraxPair.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


5       import "../external/interfaces/Gearbox/ICreditManagerV3.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


5       import "../external/interfaces/Morpho/IMorpho.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


5       import "../external/interfaces/Pancakeswap/IMasterChefV3.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


7       import { IPendleMarketDepositHelper } from "../external/interfaces/Pendle/IPendleMarketDepositHelper.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


6       import { IBorrowerOperations } from "../external/interfaces/Prisma/IBorrowerOperations.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


5       import "../external/interfaces/SNXV3/IV3CoreProxy.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


5       import "../external/interfaces/Silo/ISilo.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


5       import "../external/interfaces/Stargate/IStargateRouter.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


10      import "../interface/valueOracle/INoyaValueOracle.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


10      import { ITokenTransferCallBack } from "hottings/contracts/interface/ITokenTransferCallBack.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


5       import "../../interface/IConnector.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


6       import "../../interface/SwapHandler/ISwapAndBridgeHandler.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


6       import "../../../interface/SwapHandler/ISwapAndBridgeHandler.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/TVLHelper.sol


5       import { IConnector } from "../interface/IConnector.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/TVLHelper.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


5       import "../../interface/valueOracle/INoyaValueOracle.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


8       import "hottings/node_modules/@openzeppelin/contracts-5.0/token/ERC20/extensions/IERC20Metadata.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


7       import "../../../interface/valueOracle/INoyaValueOracle.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## NC009 - Constants in comparisons should appear on the left side:

This issue arises when constants in comparisons appear on the right side, which can lead to typo bugs.


<details>
<summary>Click to show 28 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


201             if (amount == 0) {
288             if (registry.isAnActiveConnector(vaultId, connector) && processedBaseTokenAmount > 0) {
335             if (currentWithdrawGroup.isFullfilled == false && currentWithdrawGroup.isStarted == true) {
361             require(currentWithdrawGroup.isStarted == false && currentWithdrawGroup.isFullfilled == false);
371             require(currentWithdrawGroup.isStarted == true && currentWithdrawGroup.isFullfilled == false);
374             if (neededAssets != 0 && amountAskedForWithdraw != currentWithdrawGroup.totalCBAmount) {
397             if (currentWithdrawGroup.isFullfilled == false) {
438             if (withdrawFeeAmount > 0) {
506             if (block.timestamp - lastFeeDistributionTime < 1 days) {
510             if (timePassed > 10 days) {
528                 preformanceFeeSharesWaitingForDistribution == 0 || block.timestamp - profitStoredTime < 12 hours
529                     || block.timestamp - profitStoredTime > 48 hours
619                 currentWithdrawGroup.isStarted == false || currentWithdrawGroup.isFullfilled == true
634             if (p.positionTypeId == 0) {
650             if (positionTypeId == 0) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


33              if (msg.sender != vaults[_vaultId].maintainer || hasRole(EMERGENCY_ROLE, msg.sender) == false) {
40              if (msg.sender != vaults[_vaultId].maintainerWithoutTimeLock && hasRole(EMERGENCY_ROLE, msg.sender) == false) {
47              if (msg.sender != vaults[_vaultId].governer && hasRole(EMERGENCY_ROLE, msg.sender) == false) {
251                 if (vault.connectors[calculatorConnector].enabled == false) revert NotExist();
304             if (index == 0) {
347             if (positionIndex == 0 && removePosition) return type(uint256).max;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


92              if (IERC20(data.pool).balanceOf(address(this)) == 0) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


78                  if (amounts[i] > 0) _approveOperations(tokens[i], balancerVault, amounts[i]);
99              if (auraAmount > 0) {
116             if (p._auraAmount > 0) {
122             if (p._lpAmount > 0) {
146                 if (totalLpBalanceOf(p.poolId) == 0) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


92                  require(tokens[i].balanceOf(address(this)) == 0, "BalancerFlashLoan: Flash loan extra tokens");


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


77              if (IERC20(pool).balanceOf(address(this)) == 0) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


53              if (getCollBlanace(IComet(_market), false) == 0) {
77              if (borrowBalanceInBase == 0) return type(uint256).max;
86              if (borrowBalanceInBase == 0) return 0;
100             if (userBasic.principal > 0) {
142             return (assetsIn & (uint16(1) << assetOffset) != 0);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


126             address poolAddress = (poolInfo.tokens.length > 2 && poolInfo.zap != address(0)) ? poolInfo.zap : pool;
128             if (poolInfo.tokens.length == 2) {
132             } else if (poolInfo.tokens.length == 3) {
136             } else if (poolInfo.tokens.length == 4) {
140             } else if (poolInfo.tokens.length == 5) {
144             } else if (poolInfo.tokens.length == 6) {
171             if (totalLpBalanceOf(poolInfo) == 0) {
280             if (balance == 0) return (0, info.tokens[info.defaultWithdrawIndex]);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


51              if (markets.length == 0) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


46              if (collateralAmount > 0) {
49              if (borrowAmount > 0) {
52              } else if (collateralAmount > 0) {
55              if (collateralAmount > 0) {
124             if (_borrowerAmount == 0) return type(uint256).max;
126             if (_collateralAmount == 0) return 0;
133             if (currentPositionLTV == 0) return type(uint256).max; // loan is small


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


141                 if (earnedInfo[i].earned != 0) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


66              if (p.collateral == 0 && p.supplyShares == 0) {
112             if (borrowAmount == 0) return type(uint256).max;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


270                 if (lpBalance > 0) {
275                 if (PTAmount > 0) SYAmount += PTAmount * IPMarket(market).getPtToAssetRate(10) / 1e18;
278                 if (YTBalance > 0) SYAmount += getYTValue(market, YTBalance);
280                 if (SYAmount > 0) underlyingBalance += SYAmount * _SY.exchangeRate() / 1e18;
306                 _SY.balanceOf(address(this)) == 0 && _PT.balanceOf(address(this)) == 0 && _YT.balanceOf(address(this)) == 0
307                     && market.balanceOf(address(this)) == 0


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


79              if (registry.getHoldingPositionIndex(vaultId, positionId, address(this), "") == 0) {
107             if (registry.getHoldingPositionIndex(vaultId, positionId, address(this), "") == 0) {
111             if (bAmount > 0 && !isBorrowing) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


51              if (c == 0) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


120                 if (depositAmount == 0 && borrowAmount == 0) {
134                     IERC20(assetsS[i].collateralToken).balanceOf(address(this))


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


52              if (depositRequest.routerAmount > 0) {
57              if (depositRequest.LPStakingAmount > 0) {
79              if (withdrawRequest.LPStakingAmount > 0) {
82              if (withdrawRequest.routerAmount > 0) {
89              if (IERC20(lpAddress).balanceOf(address(this)) + LPAmount == 0) {
115             if (lpAmount == 0) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


28              require(_owners.length <= 10 && _threshold <= _owners.length && _threshold > 1);
53              require(numOwnersTemp <= 10 && threshold <= numOwnersTemp && threshold > 1);
64              require(_threshold <= numOwners && _threshold > 1);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


142             if ((positionIndex == 0 && !remove) || (positionIndex > 0 && remove)) {
159             _updateTokenInRegistry(token, IERC20(token).balanceOf(address(this)) == 0);
233             if (positionTypeId == 0) {
257             if (amount == 0) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


31              if (data.length == 0) {
86              if ((positionIndex == 0 && !remove) || (positionIndex > 0 && remove)) {
92              _updateTokenInRegistry(token, IERC20(token).balanceOf(address(this)) == 0);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


58              if (approvedBridgeTXN[transactionHash] != 0) delete approvedBridgeTXN[transactionHash];
71              if (approvedBridgeTXN[txn] == 0 || approvedBridgeTXN[txn] + BRIDGE_TXN_WAITING_TIME > block.timestamp) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol


35              if (bp.positionTypeId == 0) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


98              if (_swapRequest.amount == 0) revert InvalidAmount();
102             if (_swapRequest.checkForSlippage && _swapRequest.minAmount == 0) {
105                 if (_slippageTolerance == 0) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


35              require(isHandler[msg.sender] == true, "LifiImplementation: INVALID_SENDER");
153             if (isBridgeWhiteListed[bridgeData.bridge] == false) revert BridgeBlacklisted();
154             if (isChainSupported[bridgeData.destinationChainId] == false) revert InvalidChainId();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/TVLHelper.sol


45                  if (latestUpdateTime == 0 || positions[i].positionTimestamp < latestUpdateTime) {
49              if (latestUpdateTime == 0) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/TVLHelper.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


72              if (asset == baseToken || amount == 0) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


57              if (_chainlinkPriceAgeThreshold <= 1 hours || _chainlinkPriceAgeThreshold >= 10 days) {
128             if (price <= 0) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


39              if (_period == 0) revert INoyaValueOracle_InvalidInput();
82              if (tickCumulativesDelta < 0 && (tickCumulativesDelta % int56(int32(period)) != 0)) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## NC010 - else-block not required:

One level of nesting can be removed by not having an else block when the if-block returns


```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


144             if (assetsSources[asset][baseToken] != address(0)) {
145                 return (assetsSources[asset][baseToken], false);
146             } else if (assetsSources[baseToken][asset] != address(0)) {
147                 return (assetsSources[baseToken][asset], true);
148             }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

## NC011 - Events may be emitted out of order due to reentrancy:

Ensure that events follow the best practice of check-effects-interaction, and are emitted before external calls


<details>
<summary>Click to show 13 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


/// @audit safeTransfer() called before event
690             emit Rescue(msg.sender, token, amount);


/// @audit safeTransferFrom() called before event
216             emit RecordDeposit(depositQueue.last, receiver, block.timestamp, amount, referrer);


/// @audit safeTransfer() called before event
154             emit TransferTokensToTrustedAddress(token, amount, _caller, _data);


/// @audit safeTransfer() called before event
429                 emit ExecuteWithdraw(
430                     firstTemp, data.owner, data.receiver, shares, data.amount, baseTokenAmount, block.timestamp
431                 );


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L429:431

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


/// @audit safeTransfer() called before event
60              emit ReceiveFlashLoan(tokens, amounts, feeAmounts, userData);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L60:60

```solidity
File: contracts/connectors/PancakeswapConnector.sol


/// @audit safeTransferFrom() called before event
33              emit SendPositionToMasterChef(tokenId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L33:33

```solidity
File: contracts/connectors/PendleConnector.sol


/// @audit safeTransfer() called before event
232             emit DecreasePosition(address(market), _amount, closePosition);


/// @audit safeTransfer() called before event
195             emit SwapExactPTForSY(address(market), exactPTIn, swapData, minSY);


/// @audit safeTransfer() called before event
207             emit BurnLP(address(market), amount);


/// @audit safeTransfer() called before event
118             emit DepositIntoMarket(address(market), SYamount, PTamount);


/// @audit safeTransfer() called before event
101             emit MintPTAndYT(market, syAmount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L101:101

```solidity
File: contracts/helpers/BaseConnector.sol


/// @audit safeTransfer() called before event
88              emit TransferTokensToTrustedAddress(token, amount, caller, data);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L88:88

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


/// @audit safeTransfer() called before event
200             emit Rescued(token, userAddress, amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L200:200

</details>

## NC012 - If-statement can be converted to a ternary:

The code can be made more compact while also increasing readability by converting the following if-statements to ternaries (e.g. foo += (x > y) ? a : b)


```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


86              if (_request.outputToken == address(0)) {
87                  balanceOut0 = address(_request.from).balance;
88              } else {
89                  balanceOut0 = IERC20(_request.outputToken).balanceOf(_request.from);
90              }
93              if (_request.outputToken == address(0)) {
94                  balanceOut1 = address(_request.from).balance;
95              } else {
96                  balanceOut1 = IERC20(_request.outputToken).balanceOf(_request.from);
97              }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

## NC013 - Import declarations should import specific identifiers, rather than the whole file:

Using import declarations of the form import {<identifier_name>} from 'some/file.sol' avoids polluting the symbol namespace making flattened files smaller, and speeds up compilation


<details>
<summary>Click to show 21 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


4       import "hottings/node_modules/@openzeppelin/contracts-5.0/utils/ReentrancyGuard.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


5       import "hottings/node_modules/@openzeppelin/contracts-5.0/access/Ownable.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


4       import "hottings/node_modules/@openzeppelin/contracts-5.0/access/AccessControl.sol";
5       import "hottings/node_modules/@openzeppelin/contracts-5.0/utils/ReentrancyGuard.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


8       import "hottings/node_modules/@openzeppelin/contracts-5.0/utils/ReentrancyGuard.sol";
10      import "hottings/node_modules/@openzeppelin/contracts-5.0/token/ERC20/utils/SafeERC20.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


4       import "hottings/node_modules/@openzeppelin/contracts-5.0/token/ERC20/IERC20.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


4       import "hottings/node_modules/@openzeppelin/contracts-5.0/token/ERC20/IERC20.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


6       import "hottings/node_modules/@openzeppelin/contracts-5.0/token/ERC721/IERC721.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


5       import "../external/interfaces/UNIv3/IUniswapV3Factory.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


4       import "hottings/node_modules/@openzeppelin/contracts-5.0/utils/cryptography/EIP712.sol";
5       import "hottings/node_modules/@openzeppelin/contracts-5.0/access/Ownable2Step.sol";
6       import "hottings/node_modules/@openzeppelin/contracts-5.0/utils/cryptography/ECDSA.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/governance/TimeLock.sol


4       import "hottings/node_modules/@openzeppelin/contracts-5.0/governance/TimelockController.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/TimeLock.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


7       import "hottings/node_modules/@openzeppelin/contracts-5.0/token/ERC20/utils/SafeERC20.sol";
8       import "hottings/node_modules/@openzeppelin/contracts-5.0/token/ERC721/utils/ERC721Holder.sol";
12      import "hottings/node_modules/@openzeppelin/contracts-5.0/token/ERC721/IERC721Receiver.sol";
13      import "hottings/node_modules/@openzeppelin/contracts-5.0/utils/ReentrancyGuard.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


4       import "hottings/node_modules/@openzeppelin/contracts-5.0/token/ERC20/utils/SafeERC20.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


4       import "hottings/node_modules/@openzeppelin/contracts-5.0/access/Ownable.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


4       import "hottings/node_modules/@openzeppelin/contracts-5.0/access/Ownable.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


6       import "hottings/node_modules/@openzeppelin/contracts-5.0/token/ERC20/utils/SafeERC20.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol


4       import "hottings/node_modules/@openzeppelin/contracts-5.0/token/ERC20/utils/SafeERC20.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


8       import "hottings/node_modules/@openzeppelin/contracts-5.0/utils/ReentrancyGuard.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


4       import "hottings/node_modules/@openzeppelin/contracts-5.0/access/Ownable2Step.sol";
8       import "hottings/node_modules/@openzeppelin/contracts-5.0/utils/ReentrancyGuard.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


4       import "hottings/node_modules/@openzeppelin/contracts-5.0/access/Ownable.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


7       import "hottings/node_modules/@openzeppelin/contracts-5.0/access/Ownable.sol";
8       import "hottings/node_modules/@openzeppelin/contracts-5.0/token/ERC20/extensions/IERC20Metadata.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


4       import "hottings/@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol";
5       import "../../../external/libraries/uniswap/OracleLibrary.sol";
6       import "hottings/node_modules/@openzeppelin/contracts-5.0/access/Ownable.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## NC014 - Adding a return statement when the function defines a named return variable, is redundant:

If a function defines a named return variable, it is not necessary to explicitly return it. It will automatically be returned at the end of the function.


```solidity
File: contracts/connectors/FraxConnector.sol


162             return tvl;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


284             return tvl;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

## NC015 - Public functions not called by the contract should be declared external instead:

Contracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`.


<details>
<summary>Click to show 34 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


124         function updateValueOracle(INoyaValueOracle _valueOracle) public onlyMaintainer {
125             require(address(_valueOracle) != address(0));
126             valueOracle = _valueOracle;
127             emit ValueOracleUpdated(address(_valueOracle));
128         }
135         function setFeeReceivers(
136             address _withdrawFeeReceiver,
137             address _performanceFeeReceiver,
138             address _managementFeeReceiver
139         ) public onlyMaintainer {
140             require(_withdrawFeeReceiver != address(0));
141             require(_performanceFeeReceiver != address(0));
142             require(_managementFeeReceiver != address(0));
143             withdrawFeeReceiver = _withdrawFeeReceiver;
144             performanceFeeReceiver = _performanceFeeReceiver;
145             managementFeeReceiver = _managementFeeReceiver;
146             emit FeeRecepientsChanged(_withdrawFeeReceiver, _performanceFeeReceiver, _managementFeeReceiver);
147         }
170         function setFees(uint256 _withdrawFee, uint256 _performanceFee, uint256 _managementFee) public onlyMaintainer {
171             if (
172                 _withdrawFee > WITHDRAWAL_MAX_FEE || _performanceFee > PERFORMANCE_MAX_FEE
173                     || _managementFee > MANAGEMENT_MAX_FEE
174             ) {
175                 revert NoyaAccounting_INVALID_FEE();
176             }
177             withdrawFee = _withdrawFee;
178             performanceFee = _performanceFee;
179             managementFee = _managementFee;
180             emit FeeRatesChanged(_withdrawFee, _performanceFee, _managementFee);
181         }
200         function deposit(address receiver, uint256 amount, address referrer) public nonReentrant whenNotPaused {
201             if (amount == 0) {
202                 revert NoyaAccounting_INVALID_AMOUNT();
203             }
204     
205             baseToken.safeTransferFrom(msg.sender, address(this), amount);
206     
207             if (amount > depositLimitPerTransaction) {
208                 revert NoyaAccounting_DepositLimitPerTransactionExceeded();
209             }
210     
211             if (TVL() > depositLimitTotalAmount) {
212                 revert NoyaAccounting_TotalDepositLimitExceeded();
213             }
214     
215             depositQueue.queue[depositQueue.last] = DepositRequest(receiver, block.timestamp, 0, amount, 0);
216             emit RecordDeposit(depositQueue.last, receiver, block.timestamp, amount, referrer);
217             depositQueue.last += 1;
218             depositQueue.totalAWFDeposit += amount;
219         }
226         function calculateDepositShares(uint256 maxIterations) public onlyManager nonReentrant whenNotPaused {
227             uint256 middleTemp = depositQueue.middle;
228             uint64 i = 0;
229     
230             uint256 oldestUpdateTime = TVLHelper.getLatestUpdateTime(vaultId, registry);
231     
232             while (
233                 depositQueue.last > middleTemp && depositQueue.queue[middleTemp].recordTime <= oldestUpdateTime
234                     && i < maxIterations
235             ) {
236                 i += 1;
237                 DepositRequest storage data = depositQueue.queue[middleTemp];
238     
239                 uint256 shares = previewDeposit(data.amount);
240                 data.shares = shares;
241                 data.calculationTime = block.timestamp;
242                 emit CalculateDeposit(
243                     middleTemp, data.receiver, block.timestamp, shares, data.amount, shares * 1e18 / data.amount
244                 );
245     
246                 middleTemp += 1;
247             }
248     
249             depositQueue.middle = middleTemp;
250         }
257         function executeDeposit(uint256 maxI, address connector, bytes memory addLPdata)
258             public
259             onlyManager
260             whenNotPaused
261             nonReentrant
262         {
263             uint256 firstTemp = depositQueue.first;
264             uint64 i = 0;
265             uint256 processedBaseTokenAmount = 0;
266     
267             while (
268                 depositQueue.middle > firstTemp
269                     && depositQueue.queue[firstTemp].calculationTime + depositWaitingTime <= block.timestamp && i < maxI
270             ) {
271                 i += 1;
272                 DepositRequest memory data = depositQueue.queue[firstTemp];
273     
274                 emit ExecuteDeposit(
275                     firstTemp, data.receiver, block.timestamp, data.shares, data.amount, data.shares * 1e18 / data.amount
276                 );
277                 // minting shares for receiver address
278                 _mint(data.receiver, data.shares);
279     
280                 processedBaseTokenAmount += data.amount;
281                 delete depositQueue.queue[firstTemp];
282                 firstTemp += 1;
283             }
284             depositQueue.totalAWFDeposit -= processedBaseTokenAmount;
285     
286             totalDepositedAmount += processedBaseTokenAmount;
287     
288             if (registry.isAnActiveConnector(vaultId, connector) && processedBaseTokenAmount > 0) {
289                 uint256[] memory amounts = new uint256[](1);
290                 amounts[0] = processedBaseTokenAmount;
291                 address[] memory tokens = new address[](1);
292                 tokens[0] = address(baseToken);
293                 IConnector(connector).addLiquidity(tokens, amounts, addLPdata);
294             } else {
295                 revert NoyaAccounting_INVALID_CONNECTOR();
296             }
297     
298             depositQueue.first = firstTemp;
299         }
304         function withdraw(uint256 share, address receiver) public nonReentrant whenNotPaused {
305             if (balanceOf(msg.sender) < share + withdrawRequestsByAddress[msg.sender]) {
306                 revert NoyaAccounting_INSUFFICIENT_FUNDS(
307                     balanceOf(msg.sender), share, withdrawRequestsByAddress[msg.sender]
308                 );
309             }
310             withdrawRequestsByAddress[msg.sender] += share;
311     
312             // adding the withdraw request to the withdraw queue
313             withdrawQueue.queue[withdrawQueue.last] = WithdrawRequest(msg.sender, receiver, block.timestamp, 0, share, 0);
314             emit RecordWithdraw(withdrawQueue.last, msg.sender, receiver, share, block.timestamp);
315             withdrawQueue.last += 1;
316         }
328         function calculateWithdrawShares(uint256 maxIterations) public onlyManager nonReentrant whenNotPaused {
329             uint256 middleTemp = withdrawQueue.middle;
330             uint64 i = 0;
331             uint256 processedShares = 0;
332             uint256 assetsNeededForWithdraw = 0;
333             uint256 oldestUpdateTime = TVLHelper.getLatestUpdateTime(vaultId, registry);
334     
335             if (currentWithdrawGroup.isFullfilled == false && currentWithdrawGroup.isStarted == true) {
336                 revert NoyaAccounting_ThereIsAnActiveWithdrawGroup();
337             }
338             while (
339                 withdrawQueue.last > middleTemp && withdrawQueue.queue[middleTemp].recordTime <= oldestUpdateTime
340                     && i < maxIterations
341             ) {
342                 i += 1;
343                 WithdrawRequest storage data = withdrawQueue.queue[middleTemp];
344                 uint256 assets = previewRedeem(data.shares);
345                 data.amount = assets;
346                 data.calculationTime = block.timestamp;
347                 assetsNeededForWithdraw += assets;
348                 processedShares += data.shares;
349                 emit CalculateWithdraw(middleTemp, data.owner, data.receiver, data.shares, assets, block.timestamp);
350     
351                 middleTemp += 1;
352             }
353             currentWithdrawGroup.totalCBAmount += assetsNeededForWithdraw;
354             withdrawQueue.middle = middleTemp;
355         }
360         function startCurrentWithdrawGroup() public onlyManager nonReentrant whenNotPaused {
361             require(currentWithdrawGroup.isStarted == false && currentWithdrawGroup.isFullfilled == false);
362             currentWithdrawGroup.isStarted = true;
363             currentWithdrawGroup.lastId = withdrawQueue.middle;
364             emit WithdrawGroupStarted(currentWithdrawGroup.lastId, currentWithdrawGroup.totalCBAmount);
365         }
370         function fulfillCurrentWithdrawGroup() public onlyManager nonReentrant whenNotPaused {
371             require(currentWithdrawGroup.isStarted == true && currentWithdrawGroup.isFullfilled == false);
372             uint256 neededAssets = neededAssetsForWithdraw();
373     
374             if (neededAssets != 0 && amountAskedForWithdraw != currentWithdrawGroup.totalCBAmount) {
375                 revert NoyaAccounting_NOT_READY_TO_FULFILL();
376             }
377             currentWithdrawGroup.isFullfilled = true;
378             amountAskedForWithdraw = 0;
379             uint256 availableAssets = baseToken.balanceOf(address(this)) - depositQueue.totalAWFDeposit;
380             if (availableAssets >= currentWithdrawGroup.totalCBAmount) {
381                 currentWithdrawGroup.totalABAmount = currentWithdrawGroup.totalCBAmount;
382             } else {
383                 currentWithdrawGroup.totalABAmount = availableAssets;
384             }
385             currentWithdrawGroup.totalCBAmountFullfilled = currentWithdrawGroup.totalCBAmount;
386             currentWithdrawGroup.totalCBAmount = 0;
387             emit WithdrawGroupFulfilled(
388                 currentWithdrawGroup.lastId, currentWithdrawGroup.totalCBAmount, currentWithdrawGroup.totalABAmount
389             );
390         }
396         function executeWithdraw(uint256 maxIterations) public onlyManager nonReentrant whenNotPaused {
397             if (currentWithdrawGroup.isFullfilled == false) {
398                 revert NoyaAccounting_ThereIsAnActiveWithdrawGroup();
399             }
400             uint64 i = 0;
401             uint256 firstTemp = withdrawQueue.first;
402     
403             uint256 withdrawFeeAmount = 0;
404             uint256 processedBaseTokenAmount = 0;
405             // loop through the withdraw queue and execute the withdraws
406             while (
407                 currentWithdrawGroup.lastId > firstTemp
408                     && withdrawQueue.queue[firstTemp].calculationTime + withdrawWaitingTime <= block.timestamp
409                     && i < maxIterations
410             ) {
411                 i += 1;
412                 WithdrawRequest memory data = withdrawQueue.queue[firstTemp];
413                 uint256 shares = data.shares;
414                 // calculate the base token amount that the user will receive based on the total available amount
415                 uint256 baseTokenAmount =
416                     data.amount * currentWithdrawGroup.totalABAmount / currentWithdrawGroup.totalCBAmountFullfilled;
417     
418                 withdrawRequestsByAddress[data.owner] -= shares;
419                 _burn(data.owner, shares);
420     
421                 processedBaseTokenAmount += data.amount;
422                 {
423                     uint256 feeAmount = baseTokenAmount * withdrawFee / FEE_PRECISION;
424                     withdrawFeeAmount += feeAmount;
425                     baseTokenAmount = baseTokenAmount - feeAmount;
426                 }
427     
428                 baseToken.safeTransfer(data.receiver, baseTokenAmount);
429                 emit ExecuteWithdraw(
430                     firstTemp, data.owner, data.receiver, shares, data.amount, baseTokenAmount, block.timestamp
431                 );
432                 delete withdrawQueue.queue[firstTemp];
433                 // increment the first index of the withdraw queue
434                 firstTemp += 1;
435             }
436             totalWithdrawnAmount += processedBaseTokenAmount;
437     
438             if (withdrawFeeAmount > 0) {
439                 baseToken.safeTransfer(withdrawFeeReceiver, withdrawFeeAmount);
440             }
441             withdrawQueue.first = firstTemp;
442             // if the withdraw group is fullfilled and there are no withdraws that are waiting for execution, we delete the withdraw group
443             if (currentWithdrawGroup.lastId == firstTemp) {
444                 delete currentWithdrawGroup;
445             }
446         }
453         function resetMiddle(uint256 newMiddle, bool depositOrWithdraw) public onlyManager {
454             if (depositOrWithdraw) {
455                 emit ResetMiddle(newMiddle, depositQueue.middle, depositOrWithdraw);
456     
457                 if (newMiddle > depositQueue.middle || newMiddle < depositQueue.first) {
458                     revert NoyaAccounting_INVALID_AMOUNT();
459                 }
460                 depositQueue.middle = newMiddle;
461             } else {
462                 emit ResetMiddle(newMiddle, withdrawQueue.middle, depositOrWithdraw);
463     
464                 if (newMiddle > withdrawQueue.middle || newMiddle < withdrawQueue.first || currentWithdrawGroup.isStarted) {
465                     revert NoyaAccounting_INVALID_AMOUNT();
466                 }
467                 withdrawQueue.middle = newMiddle;
468             }
469         }
475         function recordProfitForFee() public onlyManager nonReentrant {
476             storedProfitForFee = getProfit();
477             profitStoredTime = block.timestamp;
478     
479             if (storedProfitForFee < totalProfitCalculated) {
480                 return;
481             }
482     
483             preformanceFeeSharesWaitingForDistribution =
484                 previewDeposit(((storedProfitForFee - totalProfitCalculated) * performanceFee) / FEE_PRECISION);
485             emit RecordProfit(
486                 storedProfitForFee, totalProfitCalculated, preformanceFeeSharesWaitingForDistribution, block.timestamp
487             );
488         }
493         function checkIfTVLHasDroped() public nonReentrant {
494             uint256 currentProfit = getProfit();
495             if (currentProfit < storedProfitForFee) {
496                 emit ResetFee(currentProfit, storedProfitForFee, block.timestamp);
497                 preformanceFeeSharesWaitingForDistribution = 0;
498                 profitStoredTime = 0;
499             }
500         }
505         function collectManagementFees() public onlyManager nonReentrant returns (uint256, uint256) {
506             if (block.timestamp - lastFeeDistributionTime < 1 days) {
507                 return (0, 0);
508             }
509             uint256 timePassed = block.timestamp - lastFeeDistributionTime;
510             if (timePassed > 10 days) {
511                 timePassed = 10 days;
512             }
513             uint256 totalShares = totalSupply();
514             uint256 currentFeeShares = balanceOf(managementFeeReceiver) + balanceOf(performanceFeeReceiver)
515                 + preformanceFeeSharesWaitingForDistribution;
516     
517             uint256 managementFeeAmount =
518                 (timePassed * managementFee * (totalShares - currentFeeShares)) / FEE_PRECISION / 365 days;
519             _mint(managementFeeReceiver, managementFeeAmount);
520             emit CollectManagementFee(managementFeeAmount, timePassed, totalShares, currentFeeShares);
521             lastFeeDistributionTime = block.timestamp;
522             return (managementFeeAmount, timePassed);
523         }
526         function collectPerformanceFees() public onlyManager nonReentrant {
527             if (
528                 preformanceFeeSharesWaitingForDistribution == 0 || block.timestamp - profitStoredTime < 12 hours
529                     || block.timestamp - profitStoredTime > 48 hours
530             ) {
531                 return;
532             }
533     
534             _mint(performanceFeeReceiver, preformanceFeeSharesWaitingForDistribution);
535     
536             totalProfitCalculated = storedProfitForFee;
537     
538             emit CollectPerformanceFee(preformanceFeeSharesWaitingForDistribution);
539     
540             preformanceFeeSharesWaitingForDistribution = 0;
541         }
543         function burnShares(uint256 amount) public {
544             _burn(msg.sender, amount);
545         }
548         function retrieveTokensForWithdraw(RetrieveData[] calldata retrieveData) public onlyManager nonReentrant {
549             uint256 amountAskedForWithdraw_temp = 0;
550             uint256 neededAssets = neededAssetsForWithdraw();
551             for (uint256 i = 0; i < retrieveData.length; i++) {
552                 if (!registry.isAnActiveConnector(vaultId, retrieveData[i].connectorAddress)) {
553                     continue;
554                 }
555                 uint256 balanceBefore = baseToken.balanceOf(address(this));
556                 uint256 amount = IConnector(retrieveData[i].connectorAddress).sendTokensToTrustedAddress(
557                     address(baseToken), retrieveData[i].withdrawAmount, address(this), retrieveData[i].data
558                 );
559                 uint256 balanceAfter = baseToken.balanceOf(address(this));
560                 if (balanceBefore + amount > balanceAfter) revert NoyaAccounting_banalceAfterIsNotEnough();
561                 amountAskedForWithdraw_temp += retrieveData[i].withdrawAmount;
562                 emit RetrieveTokensForWithdraw(
563                     retrieveData[i].withdrawAmount,
564                     retrieveData[i].connectorAddress,
565                     amount,
566                     amountAskedForWithdraw + amountAskedForWithdraw_temp
567                 );
568             }
569             amountAskedForWithdraw += amountAskedForWithdraw_temp;
570             if (amountAskedForWithdraw_temp > neededAssets) {
571                 revert NoyaAccounting_INVALID_AMOUNT();
572             }
573         }
591         function totalAssets() public view override returns (uint256) {
592             return TVL();
593         }
596         function getQueueItems(bool depositOrWithdraw, uint256[] memory items)
597             public
598             view
599             returns (DepositRequest[] memory depositData, WithdrawRequest[] memory withdrawData)
600         {
601             if (depositOrWithdraw) {
602                 depositData = new DepositRequest[](items.length);
603                 for (uint256 i = 0; i < items.length; i++) {
604                     depositData[i] = depositQueue.queue[items[i]];
605                 }
606             } else {
607                 withdrawData = new WithdrawRequest[](items.length);
608                 for (uint256 i = 0; i < items.length; i++) {
609                     withdrawData[i] = withdrawQueue.queue[items[i]];
610                 }
611             }
612             return (depositData, withdrawData);
613         }
632         function getPositionTVL(HoldingPI memory position, address base) public view returns (uint256) {
633             PositionBP memory p = registry.getPositionBP(vaultId, position.positionId);
634             if (p.positionTypeId == 0) {
635                 address token = abi.decode(p.data, (address));
636                 uint256 amount = IERC20(token).balanceOf(abi.decode(position.data, (address)));
637                 return _getValue(token, base, amount);
638             }
639             return 0;
640         }
649         function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {
650             if (positionTypeId == 0) {
651                 address[] memory tokens = new address[](1);
652                 tokens[0] = abi.decode(data, (address));
653                 return tokens;
654             }
655             return new address[](0);
656         }
659         function emergencyStop() public whenNotPaused onlyEmergency {
660             _pause();
661         }
663         function unpause() public whenPaused onlyEmergency {
664             _unpause();
665         }
667         function setDepositLimits(uint256 _depositLimitPerTransaction, uint256 _depositTotalAmount) public onlyMaintainer {
668             depositLimitPerTransaction = _depositLimitPerTransaction;
669             depositLimitTotalAmount = _depositTotalAmount;
670             emit SetDepositLimits(_depositLimitPerTransaction, _depositTotalAmount);
671         }
673         function changeDepositWaitingTime(uint256 _depositWaitingTime) public onlyMaintainer {
674             depositWaitingTime = _depositWaitingTime;
675             emit SetDepositWaitingTime(_depositWaitingTime);
676         }
678         function changeWithdrawWaitingTime(uint256 _withdrawWaitingTime) public onlyMaintainer {
679             withdrawWaitingTime = _withdrawWaitingTime;
680             emit SetWithdrawWaitingTime(_withdrawWaitingTime);
681         }
683         function rescue(address token, uint256 amount) public onlyEmergency nonReentrant {
684             if (token == address(0)) {
685                 (bool success,) = payable(msg.sender).call{ value: amount }("");
686                 require(success, "Transfer failed.");
687             } else {
688                 IERC20(token).safeTransfer(msg.sender, amount);
689             }
690             emit Rescue(msg.sender, token, amount);
691         }
693         function mint(uint256 shares, address receiver) public override returns (uint256) {
694             revert NoyaAccounting_NOT_ALLOWED();
695         }
697         function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256) {
698             revert NoyaAccounting_NOT_ALLOWED();
699         }
701         function redeem(uint256 shares, address receiver, address shareOwner) public override returns (uint256) {
702             revert NoyaAccounting_NOT_ALLOWED();
703         }
705         function deposit(uint256 assets, address receiver) public override returns (uint256) {
706             revert NoyaAccounting_NOT_ALLOWED();
707         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


224         function getPositionBP(uint256 vaultId, bytes32 _positionId) public view returns (PositionBP memory) {
225             return vaults[vaultId].trustedPositionsBP[_positionId];
226         }
394         function getHoldingPositionIndex(uint256 vaultId, bytes32 _positionId, address _connector, bytes memory data)
395             public
396             view
397             returns (uint256)
398         {
399             bytes32 holdingPositionId = keccak256(abi.encode(_connector, _positionId, data));
400             return vaults[vaultId].isPositionUsed[holdingPositionId];
401         }
408         function getHoldingPosition(uint256 vaultId, uint256 i) public view returns (HoldingPI memory) {
409             return vaults[vaultId].holdingPositions[i];
410         }
416         function getHoldingPositions(uint256 vaultId) public view returns (HoldingPI[] memory) {
417             return vaults[vaultId].holdingPositions;
418         }
426         function isPositionTrusted(uint256 vaultId, bytes32 _positionId) public view returns (bool) {
427             return vaults[vaultId].trustedPositionsBP[_positionId].isEnabled;
428         }
449         function getGovernanceAddresses(uint256 vaultId)
450             public
451             view
452             returns (address, address, address, address, address, address)
453         {
454             return (
455                 vaults[vaultId].governer,
456                 vaults[vaultId].maintainer,
457                 vaults[vaultId].maintainerWithoutTimeLock,
458                 vaults[vaultId].keeperContract,
459                 vaults[vaultId].watcherContract,
460                 vaults[vaultId].emergency
461             );
462         }
508         function isPositionDebt(uint256 vaultId, bytes32 _positionId) public view returns (bool) {
509             return vaults[vaultId].trustedPositionsBP[_positionId].isDebt;
510         }
516         function getVaultAddresses(uint256 vaultId) public view returns (address, address) {
517             return (vaults[vaultId].accountManager, vaults[vaultId].baseToken);
518         }
525         function isAddressTrusted(uint256 vaultId, address addr) public view returns (bool) {
526             if (addr == vaults[vaultId].accountManager) return true;
527             return isAnActiveConnector(vaultId, addr);
528         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


114         function _getPositionTVL(HoldingPI memory, address base) public view override returns (uint256 tvl) {
115             (uint256 totalCollateralBase, uint256 totalDebtBase,,,,) = IPool(pool).getUserAccountData(address(this));
116             uint256 poolBaseAmount = totalCollateralBase - totalDebtBase;
117             return valueOracle.getValue(poolBaseToken, base, poolBaseAmount);
118         }
120         function _getUnderlyingTokens(uint256, bytes memory) public pure override returns (address[] memory) {
121             return new address[](0);
122         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


53          function supply(DepositData memory data) public onlyManager nonReentrant {
54              bytes32 positionId = registry.calculatePositionId(address(this), AERODROME_POSITION_TYPE, abi.encode(data.pool));
55              _approveOperations(IPool(data.pool).token0(), address(aerodromeRouter), data.amount0);
56              _approveOperations(IPool(data.pool).token1(), address(aerodromeRouter), data.amount1);
57              aerodromeRouter.addLiquidity(
58                  IPool(data.pool).token0(),
59                  IPool(data.pool).token1(),
60                  IPool(data.pool).stable(),
61                  data.amount0,
62                  data.amount1,
63                  data.min0Min,
64                  data.min1Min,
65                  address(this),
66                  data.deadline
67              );
68              registry.updateHoldingPosition(vaultId, positionId, "", "", false);
69              _updateTokenInRegistry(IPool(data.pool).token0());
70              _updateTokenInRegistry(IPool(data.pool).token1());
71      
72              emit Supply(data.pool, data.amount0, data.amount1);
73          }
100         function stake(address pool, uint256 liquidity) public onlyManager nonReentrant {
101             address gauge = voter.gauges(pool);
102             IERC20(pool).forceApprove(address(gauge), liquidity);
103             IGauge(gauge).deposit(liquidity, address(this));
104         }
106         function unstake(address pool, uint256 liquidity) public onlyManager nonReentrant {
107             address gauge = voter.gauges(pool);
108             IGauge(gauge).withdraw(liquidity);
109         }
111         function claim(address pool) public onlyManager nonReentrant {
112             address gauge = voter.gauges(pool);
113             IGauge(gauge).getReward(address(this));
114             _updateTokenInRegistry(IGauge(gauge).rewardToken());
115         }
117         function _getUnderlyingTokens(uint256 p, bytes memory data) public view override returns (address[] memory) {
118             address[] memory tokens = new address[](2);
119             (address pool) = abi.decode(data, (address));
120             tokens[0] = IPool(pool).token0();
121             tokens[1] = IPool(pool).token1();
122             return tokens;
123         }
125         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {
126             PositionBP memory pBP = registry.getPositionBP(vaultId, p.positionId);
127             (address pool) = abi.decode(pBP.data, (address));
128             uint256 balance = IERC20(pool).balanceOf(address(this));
129             uint256 totalSupply = IERC20(pool).totalSupply();
130             (uint256 reserve0, uint256 reserve1,) = IPool(pool).getReserves();
131             uint256 amount0 = balance * reserve0 / totalSupply;
132             uint256 amount1 = balance * reserve1 / totalSupply;
133             return _getValue(IPool(pool).token0(), base, amount0) + _getValue(IPool(pool).token1(), base, amount1);
134         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


53          function harvestAuraRewards(address[] calldata rewardsPools) public onlyManager nonReentrant {
54              for (uint256 i = 0; i < rewardsPools.length; i++) {
55                  IRewardPool baseRewardPool = IRewardPool(rewardsPools[i]);
56                  baseRewardPool.getReward();
57              }
58              _updateTokenInRegistry(address(AURA));
59          }
64          function openPosition(
65              bytes32 poolId,
66              uint256[] memory amounts,
67              uint256[] memory amountsWithoutBPT,
68              uint256 minBPT,
69              uint256 auraAmount
70          ) public onlyManager nonReentrant {
71              address[] memory tokens;
72              {
73                  (tokens,,) = IBalancerVault(balancerVault).getPoolTokens(poolId);
74              }
75              address pool = IBalancerVault(balancerVault).getPool(poolId);
76      
77              for (uint256 i = 0; i < tokens.length; i++) {
78                  if (amounts[i] > 0) _approveOperations(tokens[i], balancerVault, amounts[i]);
79              }
80      
81              IBalancerVault(balancerVault).joinPool(
82                  poolId,
83                  address(this), // sender
84                  address(this), // recipient
85                  IBalancerVault.JoinPoolRequest(
86                      tokens,
87                      amounts,
88                      abi.encode(
89                          IBalancerVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,
90                          amountsWithoutBPT, //_noBptAmounts,
91                          minBPT // minimumBPT
92                      ),
93                      false
94                  )
95              );
96              bytes32 positionId = registry.calculatePositionId(address(this), BALANCER_LP_POSITION, abi.encode(poolId));
97              registry.updateHoldingPosition(vaultId, positionId, "", "", false);
98      
99              if (auraAmount > 0) {
100                 (PoolInfo memory _poolInfo,) = _getPoolInfo(poolId);
101     
102                 uint256 amount = IERC20(pool).balanceOf(address(this));
103                 _approveOperations(pool, _poolInfo.auraPoolAddress, amount);
104                 IRewardPool(_poolInfo.auraPoolAddress).deposit(auraAmount, address(this));
105             }
106             emit OpenPosition(poolId, amounts, amountsWithoutBPT, minBPT, auraAmount);
107         }
109         function depositIntoAuraBooster(bytes32 poolId, uint256 _amount) public onlyManager nonReentrant {
110             (PoolInfo memory _poolInfo,) = _getPoolInfo(poolId);
111             _approveOperations(_poolInfo.pool, _poolInfo.auraPoolAddress, _amount);
112             IRewardPool(_poolInfo.auraPoolAddress).deposit(_amount, address(this));
113         }
115         function decreasePosition(DecreasePositionParams memory p) public onlyManager nonReentrant {
116             if (p._auraAmount > 0) {
117                 (PoolInfo memory _poolInfo, bytes32 positionId) = _getPoolInfo(p.poolId);
118     
119                 IRewardPool(_poolInfo.auraPoolAddress).withdrawAndUnwrap(p._auraAmount, true);
120             }
121     
122             if (p._lpAmount > 0) {
123                 address[] memory tokens;
124                 {
125                     (tokens,,) = IBalancerVault(balancerVault).getPoolTokens(p.poolId);
126                 }
127                 uint256[] memory _amounts = new uint256[](tokens.length);
128                 _amounts[p.outerIndex] = p.minAmount;
129     
130                 IBalancerVault(balancerVault).exitPool(
131                     p.poolId,
132                     address(this), // sender
133                     payable(address(this)), // recipient
134                     IBalancerVault.ExitPoolRequest(
135                         tokens,
136                         _amounts,
137                         abi.encode(
138                             IBalancerVault.ExitKind.EXACT_BPT_IN_FOR_ONE_TOKEN_OUT,
139                             p._lpAmount,
140                             p.withdrawIndex // enterTokenIndex
141                         ),
142                         false
143                     )
144                 );
145     
146                 if (totalLpBalanceOf(p.poolId) == 0) {
147                     registry.updateHoldingPosition(
148                         vaultId,
149                         registry.calculatePositionId(address(this), BALANCER_LP_POSITION, abi.encode(p.poolId)),
150                         "",
151                         "",
152                         true
153                     );
154                 }
155                 _updateTokenInRegistry(tokens[p.outerIndex]);
156             }
157             _updateTokenInRegistry(AURA);
158             _updateTokenInRegistry(BAL);
159             emit DecreasePosition(p);
160         }
162         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {
163             PositionBP memory PTI = registry.getPositionBP(vaultId, p.positionId);
164             PoolInfo memory pool = abi.decode(PTI.additionalData, (PoolInfo));
165             uint256 lpBalance = totalLpBalanceOf(pool);
166             (, uint256[] memory _tokenBalances,) = IBalancerVault(balancerVault).getPoolTokens(pool.poolId);
167             uint256 _totalSupply = IERC20(pool.pool).totalSupply();
168     
169             uint256 _weight = pool.weights[pool.tokenIndex];
170     
171             uint256 token1bal = valueOracle.getValue(pool.tokens[pool.tokenIndex], base, _tokenBalances[pool.tokenIndex]);
172             return (((1e18 * token1bal * lpBalance) / _weight) / _totalSupply);
173         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


88          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
89              (address tokenA, address tokenB) =
90                  abi.decode(registry.getPositionBP(vaultId, p.positionId).data, (address, address));
91              address pool = factory.getPair(tokenA, tokenB);
92              uint256 totalSupply = IERC20(pool).totalSupply();
93              (uint256 reserves0, uint256 reserves1,,) = ICamelotPair(pool).getReserves();
94      
95              uint256 balanceThis = IERC20(pool).balanceOf(address(this));
96              return balanceThis * (_getValue(tokenA, base, reserves0) + _getValue(tokenB, base, reserves1)) / totalSupply;
97          }
99          function _getUnderlyingTokens(uint256 id, bytes memory data) public view override returns (address[] memory) {
100             (address tokenA, address tokenB) = abi.decode(data, (address, address));
101             address[] memory tokens = new address[](2);
102             tokens[0] = tokenA;
103             tokens[1] = tokenB;
104             return tokens;
105         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


125         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {
126             address market = abi.decode(registry.getPositionBP(vaultId, p.positionId).data, (address));
127     
128             uint256 positiveBalance = getCollBlanace(IComet(market), false);
129             uint256 negativeBalance = getBorrowBalanceInBase(IComet(market));
130             uint256 balance = positiveBalance - negativeBalance;
131             return (valueOracle.getValue(IComet(market).baseToken(), base, balance));
132         }
134         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {
135             return new address[](0);
136         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


68          function depositIntoGauge(address pool, uint256 amount) public onlyManager nonReentrant {
69              PoolInfo memory poolInfo = _getPoolInfo(pool);
70      
71              _approveOperations(poolInfo.lpToken, poolInfo.gauge, amount);
72              IRewardsGauge(poolInfo.gauge).deposit(amount);
73          }
81          function depositIntoPrisma(address pool, uint256 amount, bool curveOrConvex) public onlyManager nonReentrant {
82              PoolInfo memory poolInfo = _getPoolInfo(pool);
83      
84              // approve depositToken to spend lpToken
85              address lpToken = poolInfo.lpToken;
86              address depostiToken = poolInfo.prismaCurvePool;
87              if (!curveOrConvex) {
88                  depostiToken = poolInfo.prismaConvexPool;
89              }
90              _approveOperations(lpToken, depostiToken, amount);
91      
92              // stake LP in Prisma
93              IDepositToken(depostiToken).deposit(address(this), amount);
94          }
103         function depositIntoConvexBooster(address pool, uint256 pid, uint256 amount, bool stake) public onlyManager {
104             PoolInfo memory poolInfo = _getPoolInfo(pool);
105     
106             _approveOperations(poolInfo.lpToken, address(convexBooster), amount);
107             convexBooster.deposit(pid, amount, stake);
108         }
117         function openCurvePosition(address pool, uint256 depositIndex, uint256 amount, uint256 minAmount)
118             public
119             onlyManager
120             nonReentrant
121         {
122             bytes32 positionId = registry.calculatePositionId(address(this), CURVE_LP_POSITION, abi.encode(pool));
123             PositionBP memory p = registry.getPositionBP(vaultId, positionId);
124             PoolInfo memory poolInfo = abi.decode(p.additionalData, (PoolInfo));
125             address token = poolInfo.tokens[depositIndex];
126             address poolAddress = (poolInfo.tokens.length > 2 && poolInfo.zap != address(0)) ? poolInfo.zap : pool;
127             _approveOperations(token, poolAddress, amount);
128             if (poolInfo.tokens.length == 2) {
129                 uint256[2] memory amounts;
130                 amounts[depositIndex] = amount;
131                 ICurveSwap(poolAddress).add_liquidity(amounts, minAmount);
132             } else if (poolInfo.tokens.length == 3) {
133                 uint256[3] memory amounts;
134                 amounts[depositIndex] = amount;
135                 ICurveSwap(poolAddress).add_liquidity(amounts, minAmount);
136             } else if (poolInfo.tokens.length == 4) {
137                 uint256[4] memory amounts;
138                 amounts[depositIndex] = amount;
139                 ICurveSwap(poolAddress).add_liquidity(amounts, minAmount);
140             } else if (poolInfo.tokens.length == 5) {
141                 uint256[5] memory amounts;
142                 amounts[depositIndex] = amount;
143                 ICurveSwap(poolAddress).add_liquidity(amounts, minAmount);
144             } else if (poolInfo.tokens.length == 6) {
145                 uint256[6] memory amounts;
146                 amounts[depositIndex] = amount;
147                 ICurveSwap(poolAddress).add_liquidity(amounts, minAmount);
148             }
149             emit OpenCurvePosition(pool, depositIndex, amount, minAmount);
150             registry.updateHoldingPosition(vaultId, positionId, "", "", false);
151         }
160         function decreaseCurvePosition(address pool, uint256 withdrawIndex, uint256 amount, uint256 minAmount)
161             public
162             onlyManager
163             nonReentrant
164         {
165             PoolInfo memory poolInfo = _getPoolInfo(pool);
166             address token = poolInfo.tokens[withdrawIndex];
167             bytes32 positionId = registry.calculatePositionId(address(this), CURVE_LP_POSITION, abi.encode(pool));
168     
169             ICurveSwap(poolInfo.pool).remove_liquidity_one_coin(amount, int128(uint128(withdrawIndex)), minAmount);
170             _updateTokenInRegistry(token);
171             if (totalLpBalanceOf(poolInfo) == 0) {
172                 registry.updateHoldingPosition(vaultId, positionId, "", "", true);
173             }
174             emit DecreaseCurvePosition(pool, withdrawIndex, amount, minAmount);
175         }
182         function withdrawFromConvexBooster(uint256 pid, uint256 amount) public onlyManager {
183             convexBooster.withdraw(pid, amount);
184             emit WithdrawFromConvexBooster(pid, amount);
185         }
192         function withdrawFromConvexRewardPool(address pool, uint256 amount) public onlyManager {
193             IConvexBasicRewards(pool).withdraw(amount, true);
194             emit WithdrawFromConvexRewardPool(pool, amount);
195         }
202         function withdrawFromGauge(address pool, uint256 amount) public onlyManager {
203             IRewardsGauge(pool).withdraw(amount);
204             emit WithdrawFromGauge(pool, amount);
205         }
212         function withdrawFromPrisma(address depostiToken, uint256 amount) public onlyManager {
213             IDepositToken(depostiToken).withdraw(address(this), amount);
214             emit WithdrawFromPrisma(depostiToken, amount);
215         }
221         function harvestRewards(address[] calldata gauges) public onlyManager nonReentrant {
222             for (uint256 i = 0; i < gauges.length; i++) {
223                 IRewardsGauge(gauges[i]).claim_rewards(address(this));
224             }
225             _updateTokenInRegistry(CRV);
226             emit HarvestRewards(gauges);
227         }
233         function harvestPrismaRewards(address[] calldata pools) public onlyManager nonReentrant {
234             for (uint256 i = 0; i < pools.length; i++) {
235                 IDepositToken(pools[i]).claimReward(address(this));
236             }
237             _updateTokenInRegistry(PRISMA);
238             _updateTokenInRegistry(CRV);
239             _updateTokenInRegistry(CVX);
240             emit HarvestPrismaRewards(pools);
241         }
247         function harvestConvexRewards(address[] calldata rewardsPools) public onlyManager nonReentrant {
248             for (uint256 i = 0; i < rewardsPools.length; i++) {
249                 IConvexBasicRewards baseRewardPool = IConvexBasicRewards(rewardsPools[i]);
250                 baseRewardPool.getReward(address(this), true);
251             }
252             _updateTokenInRegistry(CVX);
253             _updateTokenInRegistry(CRV);
254             emit HarvestConvexRewards(rewardsPools);
255         }
265         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
266             PositionBP memory PTI = registry.getPositionBP(vaultId, p.positionId);
267             PoolInfo memory poolInfo = abi.decode(PTI.additionalData, (PoolInfo));
268             uint256 lpBalance = totalLpBalanceOf(poolInfo);
269             (uint256 amount, address token) = LPToUnder(poolInfo, lpBalance);
270             return _getValue(token, base, amount);
271         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


30          function deposit(uint256 marketId, uint256 _amount) public onlyManager nonReentrant {
31              // get market token
32              address token = dolomiteMargin.getMarketTokenAddress(marketId);
33              // approve
34              _approveOperations(token, address(dolomiteMargin), _amount);
35              depositWithdrawalProxy.depositWeiIntoDefaultAccount(marketId, _amount);
36              // Update token
37              _updateTokenInRegistry(token);
38              registry.updateHoldingPosition(
39                  vaultId, registry.calculatePositionId(address(this), DOL_POSITION_ID, ""), abi.encode(0), "", false
40              );
41          }
43          function withdraw(uint256 marketId, uint256 _amount) public onlyManager nonReentrant {
44              address token = dolomiteMargin.getMarketTokenAddress(marketId);
45              depositWithdrawalProxy.withdrawWeiFromDefaultAccount(
46                  marketId, _amount, AccountBalanceHelper.BalanceCheckFlag.None
47              );
48              // Update token
49              _updateTokenInRegistry(token);
50              (uint256[] memory markets,,,) = dolomiteMargin.getAccountBalances(Info(address(this), 0));
51              if (markets.length == 0) {
52                  registry.updateHoldingPosition(
53                      vaultId, registry.calculatePositionId(address(this), DOL_POSITION_ID, ""), abi.encode(0), "", true
54                  );
55              }
56          }
106         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
107             uint256 accountId = abi.decode(p.data, (uint256));
108     
109             (uint256[] memory markets, address[] memory tokens,, Types.Wei[] memory amounts) =
110                 dolomiteMargin.getAccountBalances(Info(address(this), accountId));
111             uint256 totalDebt = 0;
112             uint256 totalCollateral = 0;
113             for (uint256 i = 0; i < markets.length; i++) {
114                 uint256 value = valueOracle.getValue(tokens[i], base, amounts[i].value);
115                 if (amounts[i].sign) {
116                     totalCollateral += value;
117                 } else {
118                     totalDebt += value;
119                 }
120             }
121             return totalCollateral - totalDebt;
122         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


68          function withdraw(IFraxPair pool, uint256 withdrawAmount) public onlyManager nonReentrant {
69              uint256 currentCollateral = pool.userCollateralBalance(address(this));
70              if (withdrawAmount == currentCollateral) {
71                  bytes32 positionId =
72                      registry.calculatePositionId(address(this), COLLATERAL_AND_DEBT_POSITION_TYPE, abi.encode(pool));
73      
74                  registry.updateHoldingPosition(vaultId, positionId, "", "", true);
75              }
76              pool.removeCollateral(withdrawAmount, address(this));
77              _updateTokenInRegistry(pool.collateralContract());
78              verifyHealthFactor(pool);
79              emit Withdraw(address(pool), withdrawAmount);
80          }
87          function repay(IFraxPair pool, uint256 sharesToRepay) public onlyManager nonReentrant {
88              uint256 repayTokenAmount = pool.toBorrowAmount(sharesToRepay, true);
89              uint256 sharesOwed = pool.userBorrowShares(address(this));
90              address asset = pool.asset();
91              if (sharesToRepay > sharesOwed) {
92                  revert IConnector_InvalidInput();
93              }
94              _approveOperations(asset, address(pool), repayTokenAmount);
95              IFraxPair(pool).repayAsset(sharesToRepay, address(this));
96              _updateTokenInRegistry(asset);
97              emit Repay(address(pool), sharesToRepay);
98          }
142         function _getUnderlyingTokens(uint256 p, bytes memory data) public view override returns (address[] memory) {
143             address[] memory tokens = new address[](2);
144             (address pool) = abi.decode(data, (address));
145             tokens[0] = IFraxPair(pool).collateralContract();
146             tokens[1] = IFraxPair(pool).asset();
147             return tokens;
148         }
150         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
151             PositionBP memory positionInfo = registry.getPositionBP(vaultId, p.positionId);
152             IFraxPair pool = IFraxPair(abi.decode(positionInfo.data, (address)));
153             uint256 collateralAmount = pool.userCollateralBalance(address(this));
154             uint256 borrowerShares = pool.userBorrowShares(address(this));
155             uint256 _borrowerAmount = pool.toBorrowAmount(borrowerShares, true);
156     
157             uint256 borrowValue = _getValue(pool.asset(), base, _borrowerAmount);
158             uint256 collateralValue = _getValue(pool.collateralContract(), base, collateralAmount);
159             if (collateralValue > borrowValue) {
160                 return collateralValue - borrowValue;
161             }
162             return tvl;
163         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


24          function openAccount(address facade, uint256 ref) public onlyManager {
25              address c = ICreditFacadeV3(facade).openCreditAccount(address(this), new MultiCall[](0), ref);
26              registry.updateHoldingPosition(
27                  vaultId,
28                  registry.calculatePositionId(address(this), GEARBOX_POSITION_ID, abi.encode(facade)),
29                  abi.encode(c),
30                  "",
31                  false
32              );
33              emit OpenAccount(facade, ref);
34          }
41          function closeAccount(address facade, address creditAccount) public onlyManager nonReentrant {
42              ICreditFacadeV3(facade).closeCreditAccount(creditAccount, new MultiCall[](0));
43      
44              registry.updateHoldingPosition(
45                  vaultId,
46                  registry.calculatePositionId(address(this), GEARBOX_POSITION_ID, abi.encode(facade)),
47                  abi.encode(creditAccount),
48                  "",
49                  true
50              );
51              emit CloseAccount(facade, creditAccount);
52          }
62          function executeCommands(
63              address facade,
64              address creditAccount,
65              MultiCall[] calldata calls,
66              address approvalToken,
67              uint256 amount
68          ) public onlyManager nonReentrant {
69              for (uint256 i = 0; i < calls.length; i++) {
70                  if (calls[i].target != facade) revert IConnector_InvalidTarget(calls[i].target);
71                  bytes4 method = bytes4(calls[i].callData[:4]);
72      
73                  if (method == ICreditFacadeV3Multicall.enableToken.selector) {
74                      (address token) = abi.decode(calls[i].callData[4:], (address));
75                      _updateTokenInRegistry(token);
76                  }
77              }
78              if (approvalToken != address(0)) {
79                  _approveOperations(approvalToken, ICreditFacadeV3(facade).creditManager(), amount);
80              }
81              ICreditFacadeV3(facade).multicall(creditAccount, calls);
82              if (approvalToken != address(0)) {
83                  _revokeApproval(approvalToken, ICreditFacadeV3(facade).creditManager());
84              }
85              emit ExecuteCommands(facade, creditAccount, calls, approvalToken, amount);
86          }
93          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
94              address creditAccount = abi.decode(p.data, (address));
95              PositionBP memory positionInfo = registry.getPositionBP(vaultId, p.positionId);
96              ICreditFacadeV3 facade = ICreditFacadeV3(abi.decode(positionInfo.data, (address)));
97              CollateralDebtData memory d = ICreditManagerV3(facade.creditManager()).calcDebtAndCollateral(
98                  creditAccount, CollateralCalcTask.DEBT_COLLATERAL_SAFE_PRICES
99              );
100             if (d.totalDebtUSD > d.totalValueUSD) {
101                 return 0;
102             }
103             return _getValue(address(840), base, (d.totalValueUSD - d.totalDebtUSD));
104         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


91          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
92              (uint256 amount) = abi.decode(p.additionalData, (uint256));
93              return _getValue(steth, base, amount);
94          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


153         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
154             PositionBP memory position = registry.getPositionBP(vaultId, p.positionId);
155             IMaverickPool pool = abi.decode(position.data, (IMaverickPool));
156     
157             (uint256 a, uint256 b) = positionInspector.addressBinReservesAllKindsAllTokenIds(address(this), pool);
158             return _getValue(pool.tokenA(), base, a) + _getValue(pool.tokenB(), base, b);
159         }
161         function _getUnderlyingTokens(uint256 id, bytes memory data) public view override returns (address[] memory) {
162             (address pool) = abi.decode(data, (address));
163             address[] memory tokens = new address[](2);
164             tokens[0] = IMaverickPool(pool).tokenA();
165             tokens[1] = IMaverickPool(pool).tokenB();
166             return tokens;
167         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


118         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
119             PositionBP memory positionInfo = registry.getPositionBP(vaultId, p.positionId);
120             if (positionInfo.positionTypeId == MORPHO_POSITION_ID) {
121                 Id id = abi.decode(positionInfo.data, (Id));
122                 MarketParams memory params = morphoBlue.idToMarketParams(id);
123                 Market memory market = morphoBlue.market(id);
124                 Position memory pos = morphoBlue.position(id, address(this));
125                 uint256 borrowAmount =
126                     uint256(pos.borrowShares).toAssetsUp(market.totalBorrowAssets, market.totalBorrowShares);
127                 uint256 supplyAmount =
128                     uint256(pos.supplyShares).toAssetsUp(market.totalSupplyAssets, market.totalSupplyShares);
129                 tvl = _getValue(
130                     params.loanToken,
131                     base,
132                     supplyAmount + borrowAmount + convertCToL(pos.collateral, params.oracle, params.collateralToken)
133                 );
134             }
135         }
141         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {
142             Id id = abi.decode(data, (Id));
143             MarketParams memory params = morphoBlue.idToMarketParams(id);
144             address[] memory tokens = new address[](2);
145             tokens[0] = params.loanToken;
146             tokens[1] = params.collateralToken;
147             return tokens;
148         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


40          function updatePosition(uint256 tokenId) public onlyManager nonReentrant {
41              masterchef.updateLiquidity(tokenId);
42              _updateTokenInRegistry(masterchef.CAKE());
43              emit UpdatePosition(tokenId);
44          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


126         function depositIntoPenpie(address _market, uint256 _amount) public onlyManager nonReentrant {
127             _approveOperations(_market, pendleMarketDepositHelper.pendleStaking(), _amount);
128             pendleMarketDepositHelper.depositMarket(_market, _amount);
129             emit DepositIntoPenpie(_market, _amount);
130         }
137         function withdrawFromPenpie(address _market, uint256 _amount) public onlyManager nonReentrant {
138             pendleMarketDepositHelper.withdrawMarketWithClaim(_market, _amount, true);
139             emit WithdrawFromPenpie(_market, _amount);
140         }
166         function swapYTForSY(address market, uint256 exactYTIn, uint256 min, LimitOrderData memory orderData)
167             public
168             onlyManager
169         {
170             (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
171             _approveOperations(address(_YT), address(pendleRouter), exactYTIn);
172             pendleRouter.swapExactYtForSy(address(this), market, exactYTIn, min, orderData);
173             emit SwapYTForSY(market, exactYTIn, min, orderData);
174         }
257         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
258             PositionBP memory positionInfo = registry.getPositionBP(vaultId, p.positionId);
259             if (positionInfo.positionTypeId == PENDLE_POSITION_ID) {
260                 uint256 underlyingBalance = 0;
261                 address market = abi.decode(positionInfo.data, (address));
262                 (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
263                 (, address _underlyingToken,) = _SY.assetInfo();
264     
265                 uint256 SYAmount = _SY.balanceOf(address(this));
266     
267                 //
268                 uint256 lpBalance =
269                     IERC20(market).balanceOf(address(this)) + pendleMarketDepositHelper.balance(market, address(this));
270                 if (lpBalance > 0) {
271                     SYAmount += lpBalance * IPMarket(market).getLpToAssetRate(10) / 1e18;
272                 }
273     
274                 uint256 PTAmount = _PT.balanceOf(address(this));
275                 if (PTAmount > 0) SYAmount += PTAmount * IPMarket(market).getPtToAssetRate(10) / 1e18;
276     
277                 uint256 YTBalance = _YT.balanceOf(address(this));
278                 if (YTBalance > 0) SYAmount += getYTValue(market, YTBalance);
279     
280                 if (SYAmount > 0) underlyingBalance += SYAmount * _SY.exchangeRate() / 1e18;
281     
282                 tvl = valueOracle.getValue(_underlyingToken, base, underlyingBalance);
283             }
284             return tvl;
285         }
311         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {
312             address market = abi.decode(data, (address));
313             (IPStandardizedYield SY,,) = IPMarket(market).readTokens();
314             address[] memory tokens = new address[](1);
315             (, tokens[0],) = SY.assetInfo();
316             return tokens;
317         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


33          function approveZap(IStakeNTroveZap zap, address tm, bool approve) public onlyManager nonReentrant {
34              if (approve) {
35                  bytes32 positionId = registry.calculatePositionId(address(this), PRISMA_POSITION_ID, abi.encode(zap, tm));
36      
37                  if (!registry.isPositionTrustedForConnector(vaultId, positionId, address(this))) {
38                      revert IConnector_InvalidPosition(positionId);
39                  }
40              }
41              IBorrowerOperations(zap.borrowerOps()).setDelegateApproval(address(zap), approve);
42          }
145         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
146             PositionBP memory positionInfo = registry.getPositionBP(vaultId, p.positionId);
147             if (positionInfo.positionTypeId == PRISMA_POSITION_ID) {
148                 (address zap, address troveManager) = abi.decode(positionInfo.data, (address, address));
149                 IBorrowerOperations borrowerOperations = IStakeNTroveZap(zap).borrowerOps();
150                 address collateral = borrowerOperations.troveManagersData(troveManager).collateralToken;
151                 address debTtoken = ITroveManager(troveManager).debtToken();
152                 (uint256 collateralBalance, uint256 debtBalance) =
153                     ITroveManager(troveManager).getTroveCollAndDebt(address(this));
154                 return _getValue(collateral, base, collateralBalance) - _getValue(debTtoken, base, debtBalance);
155             }
156         }
164         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {
165             (address zap, address troveManager) = abi.decode(data, (address, address));
166             IBorrowerOperations borrowerOperations = IStakeNTroveZap(zap).borrowerOps();
167             address collateral = borrowerOperations.troveManagersData(troveManager).collateralToken;
168             address debTtoken = ITroveManager(troveManager).debtToken();
169             address[] memory tokens = new address[](2);
170             tokens[0] = collateral;
171             tokens[1] = debTtoken;
172             return tokens;
173         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


68          function delegateIntoPreferredPool(
69              uint128 _accountId,
70              address collateralType,
71              uint256 newCollateralAmountD18,
72              uint256 leverage
73          ) public onlyManager {
74              // Delegate
75      
76              uint128 poolId = SNXCoreProxy.getPreferredPool();
77      
78              SNXCoreProxy.delegateCollateral(_accountId, poolId, collateralType, newCollateralAmountD18, leverage);
79          }
81          function delegateIntoApprovedPool(
82              uint256 poolIndex,
83              uint128 _accountId,
84              address collateralType,
85              uint256 newCollateralAmountD18,
86              uint256 leverage
87          ) public onlyManager {
88              uint256[] memory poolIds = SNXCoreProxy.getApprovedPools();
89              SNXCoreProxy.delegateCollateral(
90                  _accountId, uint128(poolIds[poolIndex]), collateralType, newCollateralAmountD18, leverage
91              );
92          }
102         function mintOrBurnSUSD(
103             uint256 _amount,
104             uint128 _accountId,
105             uint128 poolId,
106             address collateralType,
107             bool mintOrBurn
108         ) public onlyManager {
109             // Mint or burn
110             address usdToken = SNXCoreProxy.getUsdToken();
111             if (mintOrBurn) {
112                 SNXCoreProxy.mintUsd(_accountId, poolId, collateralType, _amount);
113             } else {
114                 _approveOperations(usdToken, address(SNXCoreProxy), _amount);
115                 SNXCoreProxy.burnUsd(_accountId, poolId, collateralType, _amount);
116             }
117             _updateTokenInRegistry(collateralType);
118             _updateTokenInRegistry(usdToken);
119         }
121         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
122             (uint128 accountId, address collateralType) = abi.decode(p.data, (uint128, address));
123             (uint256 totalDeposited, uint256 totalAssigned, uint256 totalLocked) =
124                 SNXCoreProxy.getAccountCollateral(accountId, collateralType);
125             tvl = _getValue(collateralType, base, totalDeposited + totalAssigned);
126         }
128         function _getUnderlyingTokens(uint256, bytes memory) public pure override returns (address[] memory) {
129             return new address[](0);
130         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


109         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
110             PositionBP memory bp = registry.getPositionBP(vaultId, p.positionId);
111             (address siloToken) = abi.decode(bp.data, (address));
112             ISilo silo = ISilo(siloRepository.getSilo(siloToken));
113             (address[] memory assets, IBaseSilo.AssetStorage[] memory assetsS) = silo.getAssetsWithState();
114             uint256 totalDepositAmount = 0;
115             uint256 totalBAmount = 0;
116             for (uint256 i = 0; i < assets.length; i++) {
117                 uint256 depositAmount = IERC20(assetsS[i].collateralToken).balanceOf(address(this));
118                 depositAmount += IERC20(assetsS[i].collateralOnlyToken).balanceOf(address(this));
119                 uint256 borrowAmount = IERC20(assetsS[i].debtToken).balanceOf(address(this));
120                 if (depositAmount == 0 && borrowAmount == 0) {
121                     continue;
122                 }
123                 uint256 price = _getValue(assets[i], base, 1e18);
124                 totalDepositAmount += depositAmount * price / 1e18;
125                 totalBAmount += borrowAmount * price / 1e18;
126             }
127             tvl = totalDepositAmount - totalBAmount;
128         }
143         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {
144             (address siloToken) = abi.decode(data, (address));
145             ISilo silo = ISilo(siloRepository.getSilo(siloToken));
146             (address[] memory assets,) = silo.getAssetsWithState();
147             return assets;
148         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


110         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
111             PositionBP memory pBP = registry.getPositionBP(vaultId, p.positionId);
112             uint256 poolId = abi.decode(pBP.data, (uint256));
113             address lpAddress = LPStaking.poolInfo(poolId).lpToken;
114             uint256 lpAmount = LPStaking.userInfo(poolId, address(this)).amount + IERC20(lpAddress).balanceOf(address(this));
115             if (lpAmount == 0) {
116                 return 0;
117             }
118             address underlyingToken = IStargatePool(lpAddress).token();
119             uint256 underlyingAmount = IStargatePool(lpAddress).amountLPtoLD(lpAmount);
120             return _getValue(underlyingToken, base, underlyingAmount);
121         }
123         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {
124             uint256 poolId = abi.decode(data, (uint256));
125             address lpAddress = LPStaking.poolInfo(poolId).lpToken;
126             address[] memory tokens = new address[](1);
127             tokens[0] = IStargatePool(lpAddress).token();
128             return tokens;
129         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


101         function collectAllFees(uint256[] memory tokenIds) public onlyManager nonReentrant {
102             for (uint256 i = 0; i < tokenIds.length; i++) {
103                 (, address token0, address token1) = getCurrentLiquidity(tokenIds[i]);
104                 _collectFees(tokenIds[i]);
105                 _updateTokenInRegistry(token0);
106                 _updateTokenInRegistry(token1);
107                 emit CollectFees(tokenIds[i]);
108             }
109         }
127         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
128             PositionBP memory positionInfo = registry.getPositionBP(vaultId, p.positionId);
129             uint256 tokenId = abi.decode(p.data, (uint256));
130             (address token0, address token1) = abi.decode(positionInfo.data, (address, address));
131             uint256 amount0;
132             uint256 amount1;
133             (int24 tL, int24 tU, uint24 fee) = abi.decode(p.additionalData, (int24, int24, uint24));
134             {
135                 IUniswapV3Pool pool = IUniswapV3Pool(factory.getPool(token0, token1, fee));
136                 bytes32 key = keccak256(abi.encodePacked(positionManager, tL, tU));
137     
138                 (uint128 liquidity,,, uint128 tokensOwed0, uint128 tokensOwed1) = pool.positions(key);
139     
140                 (uint160 sqrtPriceX96,,,,,,) = pool.slot0();
141                 (amount0, amount1) = LiquidityAmounts.getAmountsForLiquidity(
142                     sqrtPriceX96, TickMath.getSqrtRatioAtTick(tL), TickMath.getSqrtRatioAtTick(tU), liquidity
143                 );
144                 amount0 += tokensOwed0;
145                 amount1 += tokensOwed1;
146             }
147     
148             tvl += valueOracle.getValue(token0, base, amount0);
149             tvl += valueOracle.getValue(token1, base, amount1);
150         }
152         function _getUnderlyingTokens(uint256, bytes memory data) public pure override returns (address[] memory) {
153             address[] memory tokens = new address[](2);
154             (tokens[0], tokens[1]) = abi.decode(data, (address, address));
155             return tokens;
156         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


42          function updateOwners(address[] memory _owners, bool[] memory addOrRemove) public onlyOwner {
43              uint256 numOwnersTemp = numOwners;
44              for (uint256 i = 0; i < _owners.length; i++) {
45                  if (addOrRemove[i] && !isOwner[_owners[i]]) {
46                      isOwner[_owners[i]] = true;
47                      numOwnersTemp++;
48                  } else if (!addOrRemove[i] && isOwner[_owners[i]]) {
49                      isOwner[_owners[i]] = false;
50                      numOwnersTemp--;
51                  }
52              }
53              require(numOwnersTemp <= 10 && threshold <= numOwnersTemp && threshold > 1);
54              numOwners = numOwnersTemp;
55              emit UpdateOwners(_owners, addOrRemove);
56          }
63          function setThreshold(uint8 _threshold) public onlyOwner {
64              require(_threshold <= numOwners && _threshold > 1);
65              threshold = _threshold;
66              emit UpdateThreshold(_threshold);
67          }
84          function execute(
85              address destination,
86              bytes calldata data,
87              uint256 gasLimit,
88              address executor,
89              bytes32[] memory sigR,
90              bytes32[] memory sigS,
91              uint8[] memory sigV,
92              uint256 deadline
93          ) public {
94              require(isOwner[msg.sender], "Not an owner");
95              require(sigR.length == threshold, "Not enough signatures");
96              require(sigR.length == sigS.length && sigR.length == sigV.length, "Lengths do not match");
97              require(executor == msg.sender, "Invalid executor");
98              require(block.timestamp <= deadline, "Transaction expired");
99              {
100                 bytes32 txInputHash =
101                     keccak256(abi.encode(TXTYPE_HASH, nonce, destination, data, gasLimit, executor, deadline));
102                 bytes32 totalHash = keccak256(abi.encodePacked("\x19\x01", _domainSeparatorV4(), txInputHash));
103                 address lastAdd = address(0);
104                 for (uint256 i = 0; i < threshold;) {
105                     address recovered = ECDSA.recover(totalHash, sigV[i], sigR[i], sigS[i]);
106                     require(recovered > lastAdd && isOwner[recovered]);
107                     lastAdd = recovered;
108                     unchecked {
109                         ++i;
110                     }
111                 }
112     
113                 nonce++;
114             }
115             emit Execute(destination, data, gasLimit, executor, deadline);
116             (bool success,) = destination.call{ gas: gasLimit }(data);
117             require(success, "Transaction execution reverted.");
118         }
124         function domainSeparatorV4() public view returns (bytes32) {
125             return _domainSeparatorV4();
126         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


153         function updateTokenInRegistry(address token) public onlyManager {
154             _updateTokenInRegistry(token);
155         }
232         function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {
233             if (positionTypeId == 0) {
234                 address[] memory tokens = new address[](1);
235                 tokens[0] = abi.decode(data, (address));
236                 return tokens;
237             }
238             return _getUnderlyingTokens(positionTypeId, data);
239         }
249         function getPositionTVL(HoldingPI memory p, address baseToken) public view returns (uint256) {
250             return _getPositionTVL(p, baseToken);
251         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


71          function getPositionTVL(HoldingPI memory p, address baseToken) public view returns (uint256) {
72              return 0;
73          }
75          function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {
76              return new address[](0);
77          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


40          function setChainInfo(uint256 chainId, uint32 lzChainId, address lzHelperAddress) public onlyOwner {
41              require(lzHelperAddress != address(0));
42              chainInfo[lzChainId] = ChainInfo(chainId, lzHelperAddress);
43          }
52          function addVaultInfo(uint256 vaultId, uint256 baseChainId, address omniChainManager) public onlyOwner {
53              require(omniChainManager != address(0));
54              vaultIdToVaultInfo[vaultId] = VaultInfo(baseChainId, omniChainManager);
55          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


36          function updateMessageSetting(bytes memory _messageSetting) public onlyOwner {
37              messageSetting = _messageSetting;
38          }
51          function setChainInfo(uint256 chainId, uint32 lzChainId, address lzHelperAddress) public onlyOwner {
52              require(lzHelperAddress != address(0));
53              chainInfo[chainId] = ChainInfo(lzChainId, lzHelperAddress);
54          }
63          function addVaultInfo(uint256 vaultId, uint256 baseChainId, address omniChainManager) public onlyOwner {
64              vaultIdToVaultInfo[vaultId] = VaultInfo(baseChainId, omniChainManager);
65          }
75          function updateTVL(uint256 vaultId, uint256 tvl, uint256 updateTime) public {
76              if (msg.sender != vaultIdToVaultInfo[vaultId].omniChainManager) revert InvalidSender();
77      
78              uint32 lzChainId = chainInfo[vaultIdToVaultInfo[vaultId].baseChainId].lzChainId;
79              bytes memory data = abi.encode(vaultId, tvl, updateTime);
80              _lzSend(lzChainId, data, messageSetting, MessagingFee(address(this).balance, 0), payable(address(this))); // TODO: send event here
81          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


57          function updateBridgeTransactionApproval(bytes32 transactionHash) public onlyManager {
58              if (approvedBridgeTXN[transactionHash] != 0) delete approvedBridgeTXN[transactionHash];
59              else approvedBridgeTXN[transactionHash] = block.timestamp;
60              emit UpdateBridgeTransactionApproval(transactionHash, block.timestamp);
61          }
68          function startBridgeTransaction(BridgeRequest memory bridgeRequest) public onlyManager nonReentrant {
69              bytes32 txn = keccak256(abi.encode(bridgeRequest));
70              emit StartBridgeTransaction(bridgeRequest, txn);
71              if (approvedBridgeTXN[txn] == 0 || approvedBridgeTXN[txn] + BRIDGE_TXN_WAITING_TIME > block.timestamp) {
72                  revert IConnector_BridgeTransactionNotApproved(txn);
73              }
74              if (bridgeRequest.from != address(this)) revert IConnector_InvalidInput();
75              if (
76                  destChainAddress[bridgeRequest.destChainId] == address(0)
77                      || destChainAddress[bridgeRequest.destChainId] != bridgeRequest.receiverAddress
78              ) {
79                  revert IConnector_InvalidDestinationChain();
80              }
81              approvedBridgeTXN[txn] = 0;
82              swapHandler.executeBridge(bridgeRequest);
83              _updateTokenInRegistry(bridgeRequest.inputToken);
84          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


51          function _getPositionTVL(HoldingPI memory position, address) public view override returns (uint256) {
52              uint256 positionTypeId = registry.getPositionBP(vaultId, position.positionId).positionTypeId;
53              if (positionTypeId == OMNICHAIN_POSITION_ID) {
54                  return (abi.decode(position.additionalData, (uint256)));
55              }
56              return 0;
57          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol


33          function _getPositionTVL(HoldingPI memory position, address base) public view override returns (uint256) {
34              PositionBP memory bp = registry.getPositionBP(vaultId, position.positionId);
35              if (bp.positionTypeId == 0) {
36                  address token = abi.decode(bp.data, (address));
37                  uint256 amount = IERC20(token).balanceOf(address(this));
38                  return _getValue(token, base, amount);
39              }
40              return 0;
41          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


147         function addRoutes(RouteData[] memory _routes) public onlyMaintainer {
148             for (uint256 i = 0; i < _routes.length;) {
149                 routes.push(_routes[i]);
150                 emit NewRouteAdded(i, _routes[i].route, _routes[i].isEnabled, _routes[i].isBridge);
151                 unchecked {
152                     i++;
153                 }
154             }
155         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/TVLHelper.sol


14          function getTVL(uint256 vaultId, PositionRegistry registry, address baseToken) public view returns (uint256) {
15              uint256 totalTVL;
16              uint256 totalDebt;
17              HoldingPI[] memory positions = registry.getHoldingPositions(vaultId);
18              for (uint256 i = 0; i < positions.length; i++) {
19                  if (positions[i].calculatorConnector == address(0)) {
20                      continue;
21                  }
22                  uint256 tvl = IConnector(positions[i].calculatorConnector).getPositionTVL(positions[i], baseToken);
23                  bool isPositionDebt = registry.isPositionDebt(vaultId, positions[i].positionId);
24                  if (isPositionDebt) {
25                      totalDebt += tvl;
26                  } else {
27                      totalTVL += tvl;
28                  }
29              }
30              if (totalTVL < totalDebt) {
31                  return 0;
32              }
33              return (totalTVL - totalDebt);
34          }
41          function getLatestUpdateTime(uint256 vaultId, PositionRegistry registry) public view returns (uint256) {
42              uint256 latestUpdateTime;
43              HoldingPI[] memory positions = registry.getHoldingPositions(vaultId);
44              for (uint256 i = 0; i < positions.length; i++) {
45                  if (latestUpdateTime == 0 || positions[i].positionTimestamp < latestUpdateTime) {
46                      latestUpdateTime = positions[i].positionTimestamp;
47                  }
48              }
49              if (latestUpdateTime == 0) {
50                  latestUpdateTime = block.timestamp;
51              }
52              return latestUpdateTime;
53          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/TVLHelper.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


37          function updateDefaultPriceSource(address[] calldata baseCurrencies, INoyaValueOracle[] calldata oracles)
38              public
39              onlyMaintainer
40          {
41              for (uint256 i = 0; i < baseCurrencies.length; i++) {
42                  defaultPriceSource[baseCurrencies[i]] = oracles[i];
43              }
44              emit UpdatedDefaultPriceSource(baseCurrencies, oracles);
45          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


89          function getValue(address asset, address baseToken, uint256 amount) public view returns (uint256) {
90              if (asset == baseToken) {
91                  return amount;
92              }
93      
94              (address primarySource, bool isPrimaryInverse) = getSourceOfAsset(asset, baseToken);
95              if (primarySource == address(0)) {
96                  revert NoyaChainlinkOracle_PRICE_ORACLE_UNAVAILABLE(asset, baseToken, primarySource);
97              }
98              address decimalsSource = isPrimaryInverse ? baseToken : asset;
99              decimalsSource = decimalsSource == ETH || decimalsSource == USD ? primarySource : decimalsSource;
100             return getValueFromChainlinkFeed(
101                 AggregatorV3Interface(primarySource), amount, getTokenDecimals(decimalsSource), isPrimaryInverse
102             );
103         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


60          function getValue(address tokenIn, address baseToken, uint256 amount) public view returns (uint256 _amountOut) {
61              uint128 amountIn128 = uint128(amount);
62              address pool = assetToBaseToPool[tokenIn][baseToken];
63              if (pool == address(0)) {
64                  pool = assetToBaseToPool[baseToken][tokenIn];
65              }
66              if (pool == address(0)) revert INoyaOracle_ValueOracleUnavailable(tokenIn, baseToken);
67      
68              // Code copied from OracleLibrary.sol, consult()
69              uint32[] memory secondsAgos = new uint32[](2);
70              secondsAgos[0] = period;
71              secondsAgos[1] = 0;
72      
73              // Get the tick cumulatives from the pool for the periods
74              (int56[] memory tickCumulatives,) = IUniswapV3Pool(pool).observe(secondsAgos);
75      
76              // Calculate the delta of the tick cumulatives
77              int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];
78      
79              // Calculate the time-weighted average tick
80              // int56 / uint32 = int24
81              int24 timeWeightedAverageTick = int24(tickCumulativesDelta / int56(int32(period)));
82              if (tickCumulativesDelta < 0 && (tickCumulativesDelta % int56(int32(period)) != 0)) {
83                  timeWeightedAverageTick--;
84              }
85              _amountOut = OracleLibrary.getQuoteAtTick(timeWeightedAverageTick, amountIn128, tokenIn, baseToken);
86          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## NC016 - Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`, for readability:

Well-organized data structures make code reviews easier, which may lead to fewer bugs. Consider combining related mappings into mappings to structs, so it's clear what data is related


<details>
<summary>Click to show 5 findings</summary>

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


20          mapping(uint256 => ChainInfo) public chainInfo; // chainId => ChainInfo
21          mapping(uint256 => VaultInfo) public vaultIdToVaultInfo; // vaultId => VaultInfo


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


15          mapping(address => mapping(address => uint256)) public slippageTolerance;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


13          mapping(address => INoyaValueOracle) public defaultPriceSource;
14          mapping(address => mapping(address => address[])) public priceRoutes;
15          /// @notice Price sources for assets
16          mapping(address => mapping(address => INoyaValueOracle)) public priceSource;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


20          mapping(address => mapping(address => address)) private assetsSources;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


14          mapping(address => mapping(address => address)) public assetToBaseToPool;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## NC017 - Duplicated `require()`/`revert()` checks should be refactored to a modifier or function:

The compiler will inline the function, which will avoid JUMP instructions usually associated with functions.


```solidity
File: contracts/accountingManager/Registry.sol


67              require(_governer != address(0));
68              require(_maintainer != address(0));
124             require(_keeperContract != address(0));
125             require(_watcher != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

## NC018 - Variables need not be initialized to zero:

The default value for variables is zero, so initializing them to zero is superfluous.


<details>
<summary>Click to show 18 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


551             for (uint256 i = 0; i < retrieveData.length; i++) {
603                 for (uint256 i = 0; i < items.length; i++) {
608                 for (uint256 i = 0; i < items.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


138             for (uint256 i = 0; i < _trustedTokens.length; i++) {
194             for (uint256 i = 0; i < _connectorAddresses.length; i++) {
214             for (uint256 i = 0; i < _tokens.length; i++) {
253                 for (uint256 i = 0; i < usingTokens.length; i++) {
274             for (uint256 i = 0; i < length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


54              for (uint256 i = 0; i < rewardsPools.length; i++) {
77              for (uint256 i = 0; i < tokens.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


74                  for (uint256 i = 0; i < tokens.length; i++) {
79                  for (uint256 i = 0; i < destinationConnector.length; i++) {
84                  for (uint256 i = 0; i < tokens.length; i++) {
89              for (uint256 i = 0; i < tokens.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


222             for (uint256 i = 0; i < gauges.length; i++) {
234             for (uint256 i = 0; i < pools.length; i++) {
248             for (uint256 i = 0; i < rewardsPools.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


113             for (uint256 i = 0; i < markets.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


69              for (uint256 i = 0; i < calls.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


140             for (uint256 i = 0; i < earnedInfo.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


244             for (uint256 i = 0; i < rewardTokens.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


116             for (uint256 i = 0; i < assets.length; i++) {
132             for (uint256 i = 0; i < assetsS.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


102             for (uint256 i = 0; i < tokenIds.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


29              for (uint256 i = 0; i < _owners.length; i++) {
44              for (uint256 i = 0; i < _owners.length; i++) {
104                 for (uint256 i = 0; i < threshold;) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


178             for (uint256 i = 0; i < tokens.length; i++) {
189             for (uint256 i = 0; i < tokens.length; i++) {
211             for (uint256 i = 0; i < tokensIn.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


41              for (uint256 i = 0; i < tokens.length; i++) {
46              for (uint256 i = 0; i < tokens.length; i++) {
17          uint256 public vaultId = 0;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


37              for (uint256 i = 0; i < usersAddresses.length; i++) {
148             for (uint256 i = 0; i < _routes.length;) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/TVLHelper.sol


18              for (uint256 i = 0; i < positions.length; i++) {
44              for (uint256 i = 0; i < positions.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/TVLHelper.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


41              for (uint256 i = 0; i < baseCurrencies.length; i++) {
55              for (uint256 i = 0; i < oracle.length; i++) {
88              for (uint256 i = 0; i < sources.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


74              for (uint256 i = 0; i < assets.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

</details>

## NC019 - Variable names that consist of all capital letters should be reserved for constant/immutable variables:

If the variable needs to be different based on which class it comes from, a view/pure function should be used instead.


<details>
<summary>Click to show 8 findings</summary>

```solidity
File: contracts/connectors/BalancerConnector.sol


29          address public BAL;
30          address public AURA;
32          uint256 public BALANCER_LP_POSITION = 1;
163             PositionBP memory PTI = registry.getPositionBP(vaultId, p.positionId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


8           uint256 public COMPOUND_LP = 2;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


27          address public CVX;
28          address public CRV;
29          address public PRISMA;
266             PositionBP memory PTI = registry.getPositionBP(vaultId, p.positionId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


22          uint256 public COLLATERAL_AND_DEBT_POSITION_TYPE = 1;
127             (uint256 LTV_PRECISION,,,, uint256 EXCHANGE_PRECISION,,,) = _fraxlendPair.getConstants();
127             (uint256 LTV_PRECISION,,,, uint256 EXCHANGE_PRECISION,,,) = _fraxlendPair.getConstants();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


13          uint256 public LIDO_WITHDRAWAL_REQUEST_ID = 10;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


35          uint256 public MAVERICK_LP = 10;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


79              (IPStandardizedYield _SY, IPPrincipalToken _PT,) = IPMarket(market).readTokens();
79              (IPStandardizedYield _SY, IPPrincipalToken _PT,) = IPMarket(market).readTokens();
98              (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
98              (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
98              (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
113             (IPStandardizedYield _SY, IPPrincipalToken _PT,) = IPMarket(market).readTokens();
113             (IPStandardizedYield _SY, IPPrincipalToken _PT,) = IPMarket(market).readTokens();
153             (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
153             (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
153             (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
170             (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
170             (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
170             (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
188             (IPStandardizedYield _SY, IPPrincipalToken _PT,) = IPMarket(market).readTokens();
188             (IPStandardizedYield _SY, IPPrincipalToken _PT,) = IPMarket(market).readTokens();
217             (IPStandardizedYield SY,,) = market.readTokens();
262                 (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
262                 (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
262                 (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
304             (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
304             (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
304             (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
313             (IPStandardizedYield SY,,) = IPMarket(market).readTokens();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


28          uint256 public MINIMUM_HEALTH_FACTOR = 15e17;
31          uint256 public DUST_LEVEL = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

</details>

## NC020 - Consider using delete rather than assigning false/zero to clear values:

The `delete` keyword more closely matches the semantics of what is being done, and draws more attention to the changing of state, which may lead to a more thorough audit of its associated logic.


<details>
<summary>Click to show 5 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


386             currentWithdrawGroup.totalCBAmount = 0;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


360                 vault.isPositionUsed[holdingPositionId] = 0;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


49                      isOwner[_owners[i]] = false;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


81              approvedBridgeTXN[txn] = 0;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


71              secondsAgos[1] = 0;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## NC021 - Variable names for `constant`s are improperly named:

According to the [Style guide](https://docs.soliditylang.org/en/latest/style-guide.html#constants), for `constant` variable names, each word should use all capital letters, with underscores separating each word (CONSTANT_CASE).


```solidity
File: contracts/helpers/ConnectorMock2.sol


20          uint256 public constant positionType = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

## NC022 - Variable names for `immutable`s should use CONSTANT_CASE:

For `immutable` variable names, each word should use all capital letters, with underscores separating each word (CONSTANT_CASE).


```solidity
File: contracts/connectors/AaveConnector.sol


18          address immutable pool;
22          address immutable poolBaseToken;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


13          IMorpho public immutable morphoBlue;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


16          INonfungiblePositionManager public immutable positionManager;
17          IUniswapV3Factory public immutable factory;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

## NC023 - Lines are too long:

Usually lines in source code are limited to 80 characters. Today's screens are much larger so it's reasonable to stretch this in some cases. The solidity style guide recommends a maximumum line length of 120 characters, so the lines below should be split when they reach that length.


<details>
<summary>Click to show 96 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


/// @dev withdrawRequestsByAddress is used to prevent users from withdrawing or transferring more than their shares, while their withdraw request are waiting for execution

/// @dev we use this variable to prevent the withdraw group from being fullfilled before the needed amount is gathered

/// @dev This variable is used to calculate the performance fee and prevent the strategy manager to increase the profit of the vault by depositing the profit to the vault

/// @notice profitStoredTime is the time that the profit is cached. We allow the strategy manager to get the performance fee only if the profit is cached for more than 12 hours

/// @notice lastFeeDistributionTime is the time that the last fee distribution is done. This variable is used to calculate the management fee (x% of the total assets per year)

/// @notice preformanceFeeSharesWaitingForDistribution is the total amount of shares that are waiting for distribution of the performance fee

/// @dev we use this variable to prevent the strategy manager to get the performance fee before the lock period is passed

/// @notice managementFee is the fee that is taken for the total assets of the vault (x% of the total assets per year)

/// @dev if isStarted is true and isFullfilled is false, it means that the withdraw group is active and we are gethering funds for these withdrawals

/// @dev if isStarted is true and isFullfilled is true, it means that the withdraw group is fullfilled and but there are still some withdraws that are waiting for execution

/// @notice depositLimitPerTransaction is the total amount of the base token that can be deposited to the vault per transaction

/// @notice valueOracle is the address of the value oracle that is used to calculate the price of the assets (used to get TVL of holding tokens)

/// @param _performanceFeeReceiver is the address that the performance fee is sent to (this should be the NoyaFeeReceiver contract address)

/// @param _managementFeeReceiver is the address that the management fee is sent to(this should be another instance of NoyaFeeReceiver contract address)

/// @notice by overriding this function we can prevent users from withdrawing or transferring more than their shares, while their withdraw request are waiting for execution

* @notice calculateDepositShares is a function that calculates the shares of the deposits that are waiting for calculation

* @dev this function is used to calculate the users desposit shares that has been deposited before the oldest update time of the vault

* @dev This function iterates through withdrawal requests queued for calculation and assigns the corresponding amount of base tokens to each request based on the current share price. It is intended to be called by the vault manager to process queued withdrawals efficiently.

* @param maxIterations The maximum number of iterations the function will process to prevent gas limit issues. This allows for batch processing of withdrawal calculations.

* 1. Iterate through the withdrawal queue and calculate the amount of base tokens to be assigned to each withdrawal request.

/// @dev after starting the withdraw group, we can not start another withdraw group until the current withdraw group is fullfilled

/// @dev after starting the withdraw group, we can not calculate the withdraw shares until the withdraw group is fullfilled

// if the withdraw group is fullfilled and there are no withdraws that are waiting for execution, we delete the withdraw group

/// @param depositOrWithdraw is a boolean that indicates if the function is used to reset the middle index of the deposit or withdraw queue

/// @dev in case of a price manipulation, we can reset the middle index of the deposit or withdraw queue to prevent the users from getting more shares than they should

/// @dev by resetting the middle index of the deposit or withdraw queue, we force the users to wait for the calculation of their shares

/// @dev in this function, we calculate the profit of the vault and record it for the performance fee, if the profit is more than the total profit that is calculated

/// @dev we mint the shares to address(this) so after the lock period is passed, the strategy manager can get the performance fee  shares by calling the collectPerformanceFees function

/// @dev the access to this function is public so everyone can prevent the strategy manager from getting the performance fee  more than it should

/// @notice collectPerformanceFees after the lock period is passed, the strategy manager can get the performance fee shares by calling this function

/// @notice retrieveTokensForWithdraw the manager can call this function to get tokens from the connectors to fulfill the withdraw requests

* @notice Calculates the vault's current profit based on the Total Value Locked (TVL), total deposited, and withdrawn amounts

/// @notice by overriding the totalAssets function, we can calculate the total assets of the vault and use the 4626 standard to calculate the shares price

/// @notice if the withdraw group is not fullfilled, we can get the needed assets for the withdraw using this function

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L614:614

```solidity
File: contracts/accountingManager/Registry.sol


* @dev adds one dummy holding position to the vault so it can be used as a placeholder at index 0 of the holdingPositions array

// Enable the accounting manager connector so the vault can use the "getValue" function of the accounting manager for calculating the value of tokens

* @dev This function is used to update the information of an holding position (holding position is a position that the connector is holding)

* @param d data is the information that represents the position (e.g. the address of the pool in curve connector, the address of the pool in uniswap connector, etc.)

* @param holdingPositionId The id of the holding position (calculated using the positionId, the connector and the data)

* @dev This function is used to update the information of an holding position (holding position is a position that the connector is holding)

/// @dev in scenarios where the positionTimestamp is not the current time (e.g. when we have positions on other chains)

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L369:369

```solidity
File: contracts/connectors/AerodromeConnector.sol


bytes32 positionId = registry.calculatePositionId(address(this), AERODROME_POSITION_TYPE, abi.encode(data.pool));

bytes32 positionId = registry.calculatePositionId(address(this), AERODROME_POSITION_TYPE, abi.encode(data.pool));

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L80:80

```solidity
File: contracts/connectors/FraxConnector.sol


* @notice The ```_getHealthFactor``` function returns the current health factor of a respective position given an exchange rate

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L115:115

```solidity
File: contracts/connectors/PendleConnector.sol


* @notice Mints Principal Tokens (PT) and Yield Tokens (YT) in the specified market using Standardized Yield (SY) tokens

* @dev The TVL is calculated by calculating the value of YT, LP and PT in terms of SY and then converting to the base token

* @notice Checks whether all positions (SY, PT, YT, and LP (in the pool and in penpie)) in a given market are empty for this contract

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L298:298

```solidity
File: contracts/connectors/PrismaConnector.sol


borrowerOps.adjustTrove(tm, address(this), mFee, 0, wAmount, bAmount, isBorrowing, address(this), address(this));

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L114:114

```solidity
File: contracts/connectors/StargateConnector.sol


uint256 lpAmount = LPStaking.userInfo(poolId, address(this)).amount + IERC20(lpAddress).balanceOf(address(this));

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L114:114

```solidity
File: contracts/governance/Keepers.sol


* @notice Constructs the Keepers multisignature wallet with a set of owners and a threshold for transaction execution

* @param addOrRemove An array of booleans corresponding to the addresses in _owners; `true` to add, `false` to remove

* @param data The data payload of the transaction (same as msg.data (https://github.com/safe-global/safe-smart-account/blob/2278f7ccd502878feb5cec21dd6255b82df374b5/contracts/base/Executor.sol#L24))

*     - Sequentially verifying each signature to confirm it's valid, from an owner, and not reused within the same transaction (guarding against replay attacks).

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L81:81

```solidity
File: contracts/governance/NoyaGovernanceBase.sol


* @param _registry The PositionRegistry contract that stores governance addresses and other configurations for vaults

* @notice Ensures the caller is the designated manager for the vault, either the keeper contract or the emergency manager

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L27:27

```solidity
File: contracts/helpers/BaseConnector.sol


* @dev for the connectors that borrowing is allowed, the health factor should be higher than this value (so we keep a safe margin)

* @dev in case the caller is the accounting manager, the function will check with the watcher contract the number of tokens to withdraw

// the value function is inside the accounting manager contract (so we can use the accounting manager address as the calculator connector)

* @notice Updates the token registry to reflect the current balance of a specified token. It can add a new token to the registry or remove a token with zero balance.

* @dev This function is called to ensure the registry is accurate after liquidity is added, removed, or swaps are performed. It should reflect the current state of tokens held by this connector.

* @dev This function is called to add liquidity to this connector. It should be implemented in the connector contract to handle the specific liquidity adding process for the connector by overriding the _addLiquidity function (optional).

_addLiquidity(tokens, amounts, data); // call the specific implementation if the connector needs to do something after the liquidity is added

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L187:187

```solidity
File: contracts/helpers/ConnectorMock2.sol


// the value function is inside the accounting manager contract (so we can use the accounting manager address as the calculator connector)

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L81:81

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


* @param _owner The address that will own the LZHelperReceiver contract, typically a governance or deployer address with the ability to execute administrative functions

* @dev This function allows the contract owner to map a LayerZero chain ID to its corresponding chain information, including the native chain ID and the address of a helper contract specific to LayerZero on that chain.

* @param lzHelperAddress The address of the helper contract deployed on the chainId that interacts with LayerZero for cross-chain messaging

* @dev This function allows the contract owner to map a vault ID to its corresponding chain information, including the base chain ID and the address of the OmniChainManager contract that manages the vault on the base chain.

* @dev Overrides the `_lzReceive` function from `OAppReceiver` to process incoming messages. It's designed to decode the received message containing TVL update information for a specific vault and then call the associated OmnichainManager to update the TVL accordingly.

* @param _origin Struct containing information about the origin chain of the message, including the LayerZero chain ID and other metadata

* @param _message The encoded message data containing the vault ID, updated TVL value, and the timestamp of the update

* This function decodes the message and then utilizes the `OmnichainManagerBaseChain` contract associated with the specified vault to update its TVL. It ensures that messages are processed only from configured chains and vaults to maintain data integrity and security.

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L62:62

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


* @dev Allows the owner to configure how messages are sent through LayerZero, adjusting parameters like gas limits or message fees.

* @param _messageSetting The new message settings to be used for LayerZero sends (see https://docs.layerzero.network/contracts/options)

* @dev Stores LayerZero-specific identifiers and helper contract addresses for cross-chain communication to a specified chain.

* @dev Maps a vault ID to its corresponding base chain ID and omnichain manager contract, setting up the infrastructure for cross-chain TVL updates.

* @dev Constructs and sends a message containing the vault ID, new TVL, and the time of the update through LayerZero. This function can only be called by the vault's omnichain manager.

_lzSend(lzChainId, data, messageSetting, MessagingFee(address(this).balance, 0), payable(address(this))); // TODO: send event here

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L80:80

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


* @notice OmnichainLogic is a base contract for OmnichainManagerBaseChain and OmnichainManagerNormalChain, which are used to manage cross-chain communication and transactions.

*     - Mapping Addresses for Cross-Chain Bridges: At its core, the contract uses something called destChainAddress mapping. This is essentially a way to keep track of where assets should be sent across different blockchain networks. It's a crucial part of making sure that when assets are bridged, they end up exactly where they're supposed to, maintaining accuracy across a complex web of chains.

*     - A Two-Step Approval for Transactions: Before any asset can make the jump to another chain, the contract requires each transaction to be approved not once, but twice. First, someone needs to give the green light indicating that the transaction is okay (that's where updateBridgeTransactionApproval comes into play). Then, and only then, can the actual transaction process begin (startBridgeTransaction). This double-check adds an extra layer of security, ensuring every transaction is intended and verified.

* @notice Initializes the OmnichainLogic contract with the address of the LayerZero helper contract and base connector parameters

* @param _lzHelper Address of the LayerZero helper contract responsible for managing cross-chain communication (in OmnichainManagerNormalChain this is LZHelperSender and in OmnichainManagerBaseChain this is LZHelperReceiver)

* @dev This function allows the maintainer to set or update the destination address for each supported chain, facilitating targeted cross-chain transactions.

* @dev This toggles the approval state of a bridge transaction identified by its hash. If previously unapproved or expired, it approves it; if already approved, it revokes approval.

* @dev Validates the bridge request against approvals and destination chain information before executing the bridge transaction via the `GenericSwapAndBridgeHandler`.

* @param bridgeRequest A struct containing details of the bridge transaction, including source and destination chain IDs, addresses, and token information

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L65:65

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


* @dev This function is called by the LayerZero helper to adjust the TVL in response to changes detected on other chains. It's critical for maintaining an accurate and up-to-date reflection of the assets managed across the entire ecosystem.

* @dev Overrides the `_getPositionTVL` function from `OmnichainLogic` to provide specific logic for interpreting TVL data related to omnichain positions on the base chain.

* @return The TVL associated with the specified omnichain position, derived from additional data stored in the position.

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L48:48

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol


* @return The current TVL calculated using the TVLHelper utility, which aggregates the value of assets managed by the vault on this chain.

* Triggers an update of the vault's TVL information, sending the latest data to the base chain via the LZHelperSender contract.

* This function is restricted to be called by managers only, ensuring that TVL updates are controlled and authorized.

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol#L25:25

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


ITokenTransferCallBack(from).sendTokensToTrustedAddress(address(token), amount, caller, abi.encode(routeId));

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L171:171

```solidity
File: contracts/helpers/TVLHelper.sol


/// @dev in case we have a position that we can't fetch the latest update at the moment, we get the oldest update time of all of them to avoid any issues with the TVL

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/TVLHelper.sol#L39:39

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


* @dev If the tokens are not ETH or USD, it should support the decimals() function in IERC20Metadata interface since the logic depends on it

* @dev The Chainlink price is the price of a token based on another token(or currency) so if we need to claculate the price of the later based on the first, we should put isInverse to true

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L113:113

</details>

## NC024 - File is missing NatSpec comments:

The file does not contain any of the NatSpec comments (@inheritdoc, @param, @return, @notice), which are important for documentation and user confirmation.


<details>
<summary>Click to show 7 findings</summary>

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.20;

import { AccountingManager } from "./AccountingManager.sol";
import "hottings/node_modules/@openzeppelin/contracts-5.0/access/Ownable.sol";

contract NoyaFeeReceiver is Ownable {
    address public receiver;
    address public accountingManager;
    address public baseToken;

    event ManagementFeeReceived(address indexed token, uint256 amount);

    constructor(address _accountingManager, address _baseToken, address _receiver) Ownable(msg.sender) {
        require(_accountingManager != address(0));
        require(_baseToken != address(0));
        require(_receiver != address(0));
        accountingManager = _accountingManager;
        baseToken = _baseToken;
        receiver = _receiver;
    }

    function withdrawShares(uint256 amount) external onlyOwner {
        AccountingManager(accountingManager).withdraw(amount, receiver);
    }

    function burnShares(uint256 amount) external onlyOwner {
        AccountingManager(accountingManager).burnShares(amount);
    }
}


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L1:1

```solidity
File: contracts/connectors/BalancerConnector.sol


// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.20;

import "../helpers/BaseConnector.sol";
import "../external/interfaces/Balancer/IBalancerVault.sol";

struct PoolInfo {
    address pool;
    address[] tokens;
    uint256 tokenIndex;
    bytes32 poolId;
    uint256[] weights;
    address auraPoolAddress;
    uint256 boosterPoolId;
}

struct DecreasePositionParams {
    bytes32 poolId;
    uint256 _lpAmount;
    uint256 withdrawIndex;
    uint256 outerIndex;
    uint256 minAmount;
    uint256 _auraAmount;
}

contract BalancerConnector is BaseConnector {
    address internal balancerVault;

    address public BAL;
    address public AURA;

    uint256 public BALANCER_LP_POSITION = 1;

    event OpenPosition(
        bytes32 poolId, uint256[] amounts, uint256[] amountsWithoutBPT, uint256 minBPT, uint256 auraAmount
    );
    event DecreasePosition(DecreasePositionParams p);

    /**
     * Constructor *********************************
     */
    constructor(address _balancerVault, address bal, address aura, BaseConnectorCP memory baseConnectorParams)
        BaseConnector(baseConnectorParams)
    {
        require(_balancerVault != address(0));
        require(bal != address(0));
        require(aura != address(0));
        AURA = aura;
        BAL = bal;
        balancerVault = _balancerVault;
    }

    function harvestAuraRewards(address[] calldata rewardsPools) public onlyManager nonReentrant {
        for (uint256 i = 0; i < rewardsPools.length; i++) {
            IRewardPool baseRewardPool = IRewardPool(rewardsPools[i]);
            baseRewardPool.getReward();
        }
        _updateTokenInRegistry(address(AURA));
    }

    /**
     * Internal Functions *********************************
     */
    function openPosition(
        bytes32 poolId,
        uint256[] memory amounts,
        uint256[] memory amountsWithoutBPT,
        uint256 minBPT,
        uint256 auraAmount
    ) public onlyManager nonReentrant {
        address[] memory tokens;
        {
            (tokens,,) = IBalancerVault(balancerVault).getPoolTokens(poolId);
        }
        address pool = IBalancerVault(balancerVault).getPool(poolId);

        for (uint256 i = 0; i < tokens.length; i++) {
            if (amounts[i] > 0) _approveOperations(tokens[i], balancerVault, amounts[i]);
        }

        IBalancerVault(balancerVault).joinPool(
            poolId,
            address(this), // sender
            address(this), // recipient
            IBalancerVault.JoinPoolRequest(
                tokens,
                amounts,
                abi.encode(
                    IBalancerVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,
                    amountsWithoutBPT, //_noBptAmounts,
                    minBPT // minimumBPT
                ),
                false
            )
        );
        bytes32 positionId = registry.calculatePositionId(address(this), BALANCER_LP_POSITION, abi.encode(poolId));
        registry.updateHoldingPosition(vaultId, positionId, "", "", false);

        if (auraAmount > 0) {
            (PoolInfo memory _poolInfo,) = _getPoolInfo(poolId);

            uint256 amount = IERC20(pool).balanceOf(address(this));
            _approveOperations(pool, _poolInfo.auraPoolAddress, amount);
            IRewardPool(_poolInfo.auraPoolAddress).deposit(auraAmount, address(this));
        }
        emit OpenPosition(poolId, amounts, amountsWithoutBPT, minBPT, auraAmount);
    }

    function depositIntoAuraBooster(bytes32 poolId, uint256 _amount) public onlyManager nonReentrant {
        (PoolInfo memory _poolInfo,) = _getPoolInfo(poolId);
        _approveOperations(_poolInfo.pool, _poolInfo.auraPoolAddress, _amount);
        IRewardPool(_poolInfo.auraPoolAddress).deposit(_amount, address(this));
    }

    function decreasePosition(DecreasePositionParams memory p) public onlyManager nonReentrant {
        if (p._auraAmount > 0) {
            (PoolInfo memory _poolInfo, bytes32 positionId) = _getPoolInfo(p.poolId);

            IRewardPool(_poolInfo.auraPoolAddress).withdrawAndUnwrap(p._auraAmount, true);
        }

        if (p._lpAmount > 0) {
            address[] memory tokens;
            {
                (tokens,,) = IBalancerVault(balancerVault).getPoolTokens(p.poolId);
            }
            uint256[] memory _amounts = new uint256[](tokens.length);
            _amounts[p.outerIndex] = p.minAmount;

            IBalancerVault(balancerVault).exitPool(
                p.poolId,
                address(this), // sender
                payable(address(this)), // recipient
                IBalancerVault.ExitPoolRequest(
                    tokens,
                    _amounts,
                    abi.encode(
                        IBalancerVault.ExitKind.EXACT_BPT_IN_FOR_ONE_TOKEN_OUT,
                        p._lpAmount,
                        p.withdrawIndex // enterTokenIndex
                    ),
                    false
                )
            );

            if (totalLpBalanceOf(p.poolId) == 0) {
                registry.updateHoldingPosition(
                    vaultId,
                    registry.calculatePositionId(address(this), BALANCER_LP_POSITION, abi.encode(p.poolId)),
                    "",
                    "",
                    true
                );
            }
            _updateTokenInRegistry(tokens[p.outerIndex]);
        }
        _updateTokenInRegistry(AURA);
        _updateTokenInRegistry(BAL);
        emit DecreasePosition(p);
    }

    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {
        PositionBP memory PTI = registry.getPositionBP(vaultId, p.positionId);
        PoolInfo memory pool = abi.decode(PTI.additionalData, (PoolInfo));
        uint256 lpBalance = totalLpBalanceOf(pool);
        (, uint256[] memory _tokenBalances,) = IBalancerVault(balancerVault).getPoolTokens(pool.poolId);
        uint256 _totalSupply = IERC20(pool.pool).totalSupply();

        uint256 _weight = pool.weights[pool.tokenIndex];

        uint256 token1bal = valueOracle.getValue(pool.tokens[pool.tokenIndex], base, _tokenBalances[pool.tokenIndex]);
        return (((1e18 * token1bal * lpBalance) / _weight) / _totalSupply);
    }

    function totalLpBalanceOf(PoolInfo memory pool) public view returns (uint256) {
        uint256 auraShares;
        if (pool.auraPoolAddress != address(0)) {
            auraShares = IERC20(pool.auraPoolAddress).balanceOf(address(this));
            auraShares = IRewardPool(pool.auraPoolAddress).convertToAssets(auraShares);
        }
        return IERC20(pool.pool).balanceOf(address(this)) + auraShares;
    }

    function totalLpBalanceOf(bytes32 poolId) public view returns (uint256) {
        (PoolInfo memory pool,) = _getPoolInfo(poolId);
        return totalLpBalanceOf(pool);
    }

    function _getPoolInfo(bytes32 pooId) internal view returns (PoolInfo memory, bytes32) {
        bytes32 positionId = registry.calculatePositionId(address(this), BALANCER_LP_POSITION, abi.encode(pooId));
        PositionBP memory p = registry.getPositionBP(vaultId, positionId);
        return (abi.decode(p.additionalData, (PoolInfo)), positionId);
    }
}


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L1:1

```solidity
File: contracts/connectors/Dolomite.sol


// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.20;

import "../helpers/BaseConnector.sol";
import "../external/interfaces/Dolomite/IDepositWithdrawalProxy.sol";
import "../external/interfaces/Dolomite/IBorrowPositionProxyV1.sol";
import "../external/interfaces/Dolomite/IDolomiteMargin.sol";

contract DolomiteConnector is BaseConnector {
    using SafeERC20 for IERC20;

    IDepositWithdrawalProxy public depositWithdrawalProxy;
    IDolomiteMargin public dolomiteMargin;
    IBorrowPositionProxyV1 public borrowPositionProxy;

    uint256 public constant DOL_POSITION_ID = 1;

    constructor(
        address _depositWithdrawalProxy,
        address _dolomiteMargin,
        address _borrowPositionProxy,
        BaseConnectorCP memory baseConnectorParams
    ) BaseConnector(baseConnectorParams) {
        require(_depositWithdrawalProxy != address(0));
        depositWithdrawalProxy = IDepositWithdrawalProxy(_depositWithdrawalProxy);
        dolomiteMargin = IDolomiteMargin(_dolomiteMargin);
        borrowPositionProxy = IBorrowPositionProxyV1(_borrowPositionProxy);
    }

    function deposit(uint256 marketId, uint256 _amount) public onlyManager nonReentrant {
        // get market token
        address token = dolomiteMargin.getMarketTokenAddress(marketId);
        // approve
        _approveOperations(token, address(dolomiteMargin), _amount);
        depositWithdrawalProxy.depositWeiIntoDefaultAccount(marketId, _amount);
        // Update token
        _updateTokenInRegistry(token);
        registry.updateHoldingPosition(
            vaultId, registry.calculatePositionId(address(this), DOL_POSITION_ID, ""), abi.encode(0), "", false
        );
    }

    function withdraw(uint256 marketId, uint256 _amount) public onlyManager nonReentrant {
        address token = dolomiteMargin.getMarketTokenAddress(marketId);
        depositWithdrawalProxy.withdrawWeiFromDefaultAccount(
            marketId, _amount, AccountBalanceHelper.BalanceCheckFlag.None
        );
        // Update token
        _updateTokenInRegistry(token);
        (uint256[] memory markets,,,) = dolomiteMargin.getAccountBalances(Info(address(this), 0));
        if (markets.length == 0) {
            registry.updateHoldingPosition(
                vaultId, registry.calculatePositionId(address(this), DOL_POSITION_ID, ""), abi.encode(0), "", true
            );
        }
    }

    function openBorrowPosition(uint256 marketId, uint256 _amountWei, uint256 accountId)
        public
        onlyManager
        nonReentrant
    {
        address token = dolomiteMargin.getMarketTokenAddress(marketId);

        if (!registry.isTokenTrusted(vaultId, token, address(this))) {
            revert IConnector_UntrustedToken(token);
        }
        // borrow
        borrowPositionProxy.openBorrowPosition(
            0, accountId, marketId, _amountWei, AccountBalanceHelper.BalanceCheckFlag.None
        );
        registry.updateHoldingPosition(
            vaultId, registry.calculatePositionId(address(this), DOL_POSITION_ID, ""), abi.encode(accountId), "", true
        );
    }

    function transferBetweenAccounts(uint256 accountId, uint256 marketId, uint256 _amountWei, bool borrowOrRepay)
        public
        onlyManager
        nonReentrant
    {
        address token = dolomiteMargin.getMarketTokenAddress(marketId);

        if (!registry.isTokenTrusted(vaultId, token, address(this))) {
            revert IConnector_UntrustedToken(token);
        }
        if (borrowOrRepay) {
            borrowPositionProxy.transferBetweenAccounts(
                accountId, 0, marketId, _amountWei, AccountBalanceHelper.BalanceCheckFlag.None
            );
        } else {
            borrowPositionProxy.transferBetweenAccounts(
                0, accountId, marketId, _amountWei, AccountBalanceHelper.BalanceCheckFlag.None
            );
        }
    }

    function closeBorrowPosition(uint256[] memory marketIds, uint256 accountId) public onlyManager nonReentrant {
        // repay
        borrowPositionProxy.closeBorrowPosition(accountId, 0, marketIds);
        registry.updateHoldingPosition(
            vaultId, registry.calculatePositionId(address(this), DOL_POSITION_ID, ""), abi.encode(accountId), "", true
        );
    }

    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
        uint256 accountId = abi.decode(p.data, (uint256));

        (uint256[] memory markets, address[] memory tokens,, Types.Wei[] memory amounts) =
            dolomiteMargin.getAccountBalances(Info(address(this), accountId));
        uint256 totalDebt = 0;
        uint256 totalCollateral = 0;
        for (uint256 i = 0; i < markets.length; i++) {
            uint256 value = valueOracle.getValue(tokens[i], base, amounts[i].value);
            if (amounts[i].sign) {
                totalCollateral += value;
            } else {
                totalDebt += value;
            }
        }
        return totalCollateral - totalDebt;
    }
}


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L1:1

```solidity
File: contracts/governance/TimeLock.sol


// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.20;

import "hottings/node_modules/@openzeppelin/contracts-5.0/governance/TimelockController.sol";

contract NoyaTimeLock is TimelockController {
    constructor(uint256 minDelay, address[] memory proposers, address[] memory executors, address owner)
        TimelockController(minDelay, proposers, executors, owner)
    { }
}


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/TimeLock.sol#L1:1

```solidity
File: contracts/governance/Watchers.sol


// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.20;

import "./Keepers.sol";

contract Watchers is Keepers {
    constructor(address[] memory _owners, uint8 _threshold) Keepers(_owners, _threshold) { }
    function verifyRemoveLiquidity(uint256 withdrawAmount, uint256 sentAmount, bytes memory data) external view { }
}


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Watchers.sol#L1:1

```solidity
File: contracts/helpers/ConnectorMock2.sol


// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.20;

import "hottings/node_modules/@openzeppelin/contracts-5.0/token/ERC20/utils/SafeERC20.sol";
import {
    SwapAndBridgeHandler,
    SwapRequest,
    BridgeRequest
} from "contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol";
import { ITokenTransferCallBack } from "hottings/contracts/interface/ITokenTransferCallBack.sol";
import { HoldingPI } from "hottings/contracts/interface/IConnector.sol";
import { PositionRegistry } from "hottings/contracts/accountingManager/Registry.sol";

contract ConnectorMock2 {
    using SafeERC20 for IERC20;

    uint256 public vaultId = 0;
    PositionRegistry public registry;

    uint256 public constant positionType = 1;

    constructor(address _registry, uint256 _vaultId) {
        registry = PositionRegistry(_registry);
        vaultId = _vaultId;
    }

    function sendTokensToTrustedAddress(address token, uint256 amount, address caller, bytes memory data)
        external
        returns (uint256)
    {
        if (data.length == 0) {
            IERC20(token).safeTransfer(msg.sender, amount);
            return amount;
        }
        (uint256 amountToSend, uint256 amountToReturn) = abi.decode(data, (uint256, uint256));
        IERC20(token).safeTransfer(msg.sender, amountToSend);
        return amountToReturn;
    }

    function addLiquidity(address[] memory tokens, uint256[] memory amounts, bytes memory data) external {
        for (uint256 i = 0; i < tokens.length; i++) {
            // gather all of the tokens

            ITokenTransferCallBack(msg.sender).sendTokensToTrustedAddress(tokens[i], amounts[i], msg.sender, "");
        }
        for (uint256 i = 0; i < tokens.length; i++) {
            _updateTokenInRegistry(tokens[i]); // update the token in the registry
        }
    }

    function updatePositionToRegistryUsingType(bytes32 _positionId, bytes memory data, bool remove) external {
        registry.updateHoldingPosition(vaultId, _positionId, data, "", remove);
    }

    // function addPositionToRegistryUsingType(bytes32 _positionId, bytes memory data) external {
    //     registry.updateHoldingPosition(vaultId, _positionId, data, "", false);
    // }

    function addPositionToRegistryUsingType(uint256 _positionType, bytes memory data) external {
        registry.updateHoldingPosition(
            vaultId, registry.calculatePositionId(address(this), _positionType, ""), data, "", false
        );
    }

    function addPositionToRegistry(bytes memory data) external {
        registry.updateHoldingPosition(
            vaultId, registry.calculatePositionId(address(this), positionType, ""), data, "", false
        );
    }

    function getPositionTVL(HoldingPI memory p, address baseToken) public view returns (uint256) {
        return 0;
    }

    function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {
        return new address[](0);
    }

    function _updateTokenInRegistry(address token, bool remove) internal {
        (address accountingManager,) = registry.getVaultAddresses(vaultId);
        // the value function is inside the accounting manager contract (so we can use the accounting manager address as the calculator connector)
        bytes32 positionId = registry.calculatePositionId(accountingManager, 0, abi.encode(token));
        // if the token is not in the registry, we add it or remove it if the remove flag is true
        uint256 positionIndex =
            registry.getHoldingPositionIndex(vaultId, positionId, address(this), abi.encode(address(this)));
        if ((positionIndex == 0 && !remove) || (positionIndex > 0 && remove)) {
            registry.updateHoldingPosition(vaultId, positionId, abi.encode(address(this)), "", remove);
        }
    }

    function _updateTokenInRegistry(address token) internal {
        _updateTokenInRegistry(token, IERC20(token).balanceOf(address(this)) == 0);
    }
}


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L1:1

```solidity
File: contracts/helpers/valueOracle/oracles/WETH_Oracle.sol


// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.20;

contract WETH_Oracle {
    function latestRoundData()
        external
        view
        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)
    {
        return (0, 1e18, 0, block.timestamp, 0);
    }
}


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/WETH_Oracle.sol#L1:1

</details>

## NC025 - Function declarations should have NatSpec descriptions:

Function declarations should be preceded by a NatSpec comment.


<details>
<summary>Click to show 40 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


94          constructor(AccountingManagerConstructorParams memory p)
328         function calculateWithdrawShares(uint256 maxIterations) public onlyManager nonReentrant whenNotPaused {
543         function burnShares(uint256 amount) public {
596         function getQueueItems(bool depositOrWithdraw, uint256[] memory items)
616         function neededAssetsForWithdraw() public view returns (uint256) {
627         function TVL() public view returns (uint256) {
632         function getPositionTVL(HoldingPI memory position, address base) public view returns (uint256) {
649         function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {
659         function emergencyStop() public whenNotPaused onlyEmergency {
663         function unpause() public whenPaused onlyEmergency {
667         function setDepositLimits(uint256 _depositLimitPerTransaction, uint256 _depositTotalAmount) public onlyMaintainer {
673         function changeDepositWaitingTime(uint256 _depositWaitingTime) public onlyMaintainer {
678         function changeWithdrawWaitingTime(uint256 _withdrawWaitingTime) public onlyMaintainer {
683         function rescue(address token, uint256 amount) public onlyEmergency nonReentrant {
693         function mint(uint256 shares, address receiver) public override returns (uint256) {
697         function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256) {
701         function redeem(uint256 shares, address receiver, address shareOwner) public override returns (uint256) {
705         function deposit(uint256 assets, address receiver) public override returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


14          constructor(address _accountingManager, address _baseToken, address _receiver) Ownable(msg.sender) {
23          function withdrawShares(uint256 amount) external onlyOwner {
27          function burnShares(uint256 amount) external onlyOwner {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


79          function setMaxNumHoldingPositions(uint256 _maxNumHoldingPositions) external onlyRole(MAINTAINER_ROLE) {
84          function setFlashLoanAddress(address _flashLoan) external onlyRole(MAINTAINER_ROLE) {
394         function getHoldingPositionIndex(uint256 vaultId, bytes32 _positionId, address _connector, bytes memory data)
408         function getHoldingPosition(uint256 vaultId, uint256 i) public view returns (HoldingPI memory) {
416         function getHoldingPositions(uint256 vaultId) public view returns (HoldingPI[] memory) {
426         function isPositionTrusted(uint256 vaultId, bytes32 _positionId) public view returns (bool) {
436         function isPositionTrustedForConnector(uint256 vaultId, bytes32 _positionId, address connector)
449         function getGovernanceAddresses(uint256 vaultId)
470         function isTokenTrusted(uint256 vaultId, address token, address connector) public view returns (bool) {
486         function calculatePositionId(address calculatorConnector, uint256 positionTypeId, bytes memory data)
499         function isAnActiveConnector(uint256 vaultId, address connectorAddress) public view returns (bool) {
508         function isPositionDebt(uint256 vaultId, bytes32 _positionId) public view returns (bool) {
516         function getVaultAddresses(uint256 vaultId) public view returns (address, address) {
525         function isAddressTrusted(uint256 vaultId, address addr) public view returns (bool) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


33          constructor(address _pool, address _poolBaseToken, BaseConnectorCP memory baseConnectorParams)
88          function repayWithCollateral(uint256 _amount, uint256 i, address _borrowAsset) external onlyManager {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


40          constructor(address _router, address _voter, BaseConnectorCP memory baseConnectorParams)
100         function stake(address pool, uint256 liquidity) public onlyManager nonReentrant {
106         function unstake(address pool, uint256 liquidity) public onlyManager nonReentrant {
111         function claim(address pool) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


42          constructor(address _balancerVault, address bal, address aura, BaseConnectorCP memory baseConnectorParams)
53          function harvestAuraRewards(address[] calldata rewardsPools) public onlyManager nonReentrant {
64          function openPosition(
109         function depositIntoAuraBooster(bytes32 poolId, uint256 _amount) public onlyManager nonReentrant {
115         function decreasePosition(DecreasePositionParams memory p) public onlyManager nonReentrant {
175         function totalLpBalanceOf(PoolInfo memory pool) public view returns (uint256) {
184         function totalLpBalanceOf(bytes32 poolId) public view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


24          constructor(address _balancerVault, PositionRegistry _registry) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


36          constructor(address _router, address _factory, BaseConnectorCP memory baseCP) BaseConnector(baseCP) {
43          function addLiquidityInCamelotPool(CamelotAddLiquidityParams calldata p) external onlyManager nonReentrant {
65          function removeLiquidityFromCamelotPool(CamelotRemoveLiquidityParams calldata p)


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


17          constructor(BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) { }
84          function getBorrowBalanceInBase(IComet comet) public view returns (uint256 borrowBalanceInVirtualBase) {
95          function getCollBlanace(IComet comet, bool riskAdjusted) public view returns (uint256 CollValue) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


45          constructor(
81          function depositIntoPrisma(address pool, uint256 amount, bool curveOrConvex) public onlyManager nonReentrant {
103         function depositIntoConvexBooster(address pool, uint256 pid, uint256 amount, bool stake) public onlyManager {
117         function openCurvePosition(address pool, uint256 depositIndex, uint256 amount, uint256 minAmount)
160         function decreaseCurvePosition(address pool, uint256 withdrawIndex, uint256 amount, uint256 minAmount)
182         function withdrawFromConvexBooster(uint256 pid, uint256 amount) public onlyManager {
202         function withdrawFromGauge(address pool, uint256 amount) public onlyManager {
212         function withdrawFromPrisma(address depostiToken, uint256 amount) public onlyManager {
221         function harvestRewards(address[] calldata gauges) public onlyManager nonReentrant {
233         function harvestPrismaRewards(address[] calldata pools) public onlyManager nonReentrant {
247         function harvestConvexRewards(address[] calldata rewardsPools) public onlyManager nonReentrant {
279         function LPToUnder(PoolInfo memory info, uint256 balance) public view returns (uint256, address) {
311         function totalLpBalanceOf(PoolInfo memory info) public view returns (uint256) {
325         function balanceOfConvexRewardPool(PoolInfo memory info) public view returns (uint256) {
335         function balanceOfLPToken(PoolInfo memory info) public view returns (uint256) {
344         function balanceOfRewardPool(PoolInfo memory info) public view returns (uint256) {
354         function balanceOfPrisma(address prismaPool) public view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


18          constructor(
30          function deposit(uint256 marketId, uint256 _amount) public onlyManager nonReentrant {
43          function withdraw(uint256 marketId, uint256 _amount) public onlyManager nonReentrant {
58          function openBorrowPosition(uint256 marketId, uint256 _amountWei, uint256 accountId)
77          function transferBetweenAccounts(uint256 accountId, uint256 marketId, uint256 _amountWei, bool borrowOrRepay)
98          function closeBorrowPosition(uint256[] memory marketIds, uint256 accountId) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


29          constructor(BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) { }
68          function withdraw(IFraxPair pool, uint256 withdrawAmount) public onlyManager nonReentrant {
104         function verifyHealthFactor(IFraxPair pool) public view {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


17          constructor(BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) { }
24          function openAccount(address facade, uint256 ref) public onlyManager {
41          function closeAccount(address facade, address creditAccount) public onlyManager nonReentrant {
62          function executeCommands(


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


20          constructor(address _lido, address _lidoW, address _steth, address w, BaseConnectorCP memory baseConnectorParams)
37          function deposit(uint256 amountIn) external onlyManager nonReentrant {
51          function requestWithdrawals(uint256 amount) public onlyManager nonReentrant {
69          function claimWithdrawal(uint256 requestId) public onlyManager nonReentrant {
89          receive() external payable { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


43          constructor(address _mav, address _veMav, address mr, address pi, BaseConnectorCP memory baseCP)
56          receive() external payable { }
64          function stake(uint256 amount, uint256 duration, bool doDelegation) external onlyManager nonReentrant {
78          function unstake(uint256 lockupId) external onlyManager nonReentrant {
115         function removeLiquidityFromMaverickPool(MavericRemoveLiquidityParams calldata p)
137         function claimBoostedPositionRewards(IMaverickReward rewardContract) external onlyManager nonReentrant {
149         function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


23          constructor(address MB, BaseConnectorCP memory baseCP) BaseConnector(baseCP) {
58          function withdraw(uint256 amount, Id id, bool sOrC) external onlyManager nonReentrant {
80          function borrow(uint256 amount, Id id) external onlyManager nonReentrant {
95          function repay(uint256 amount, Id id) public onlyManager nonReentrant {
108         function getHealthFactor(Id _id, Market memory _market) public view returns (uint256) {
137         function convertCToL(uint256 amount, address marketOracle, address collateral) public view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


19          constructor(address MC, address _positionManager, address _factory, BaseConnectorCP memory baseConnectorParams)
31          function sendPositionToMasterChef(uint256 tokenId) external onlyManager nonReentrant {
40          function updatePosition(uint256 tokenId) public onlyManager nonReentrant {
50          function withdraw(uint256 tokenId) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


97          function mintPTAndYT(address market, uint256 syAmount) external onlyManager nonReentrant {
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
149         function swapYTForPT(address market, uint256 exactYTIn, uint256 min, ApproxParams memory guess)
183         function swapExactPTForSY(IPMarket market, uint256 exactPTIn, bytes calldata swapData, uint256 minSY)
203         function burnLP(IPMarket market, uint256 amount) external onlyManager nonReentrant {
216         function decreasePosition(IPMarket market, uint256 _amount, bool closePosition) external onlyManager nonReentrant {
241         function claimRewards(IPMarket market) external onlyManager nonReentrant {
293         function getYTValue(address market, uint256 balance) public view returns (uint256) {
303         function isMarketEmpty(IPMarket market) public view returns (bool) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


33          function approveZap(IStakeNTroveZap zap, address tm, bool approve) public onlyManager nonReentrant {
52          function openTrove(IStakeNTroveZap zap, address tm, uint256 maxFee, uint256 dAmount, uint256 bAmount)


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


20          constructor(address _SNXCoreProxy, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {
25          function createAccount() public onlyManager {
30          function deposit(address _token, uint256 _amount, uint128 _accountId) public onlyManager {
46          function withdraw(address _token, uint256 _amount, uint128 _accountId) public onlyManager {
64          function onERC721Received(address, address, uint256, bytes memory) external pure override returns (bytes4) {
68          function delegateIntoPreferredPool(
81          function delegateIntoApprovedPool(
94          function claimRewards(uint128 accountId, uint128 poolId, address collateralType, address distributor)
102         function mintOrBurnSUSD(


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


17          constructor(address SR, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {
33          function deposit(address siloToken, address dToken, uint256 amount, bool oC) external onlyManager nonReentrant {
71          function getData(address siloToken)
85          function borrow(address siloToken, address bToken, uint256 amount) external onlyManager nonReentrant {
98          function repay(address siloToken, address rToken, uint256 amount) external onlyManager nonReentrant {
130         function isSiloEmpty(ISilo silo) public view returns (bool) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


33          constructor(address lpStacking, address _stargateRouter, BaseConnectorCP memory baseConnectorParams)
76          function withdrawFromStargatePool(StargateRequest calldata withdrawRequest) external onlyManager nonReentrant {
103         function claimStargateRewards(uint256 poolId) external onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


27          constructor(address _positionManager, address _factory, BaseConnectorCP memory baseConnectorParams)
63          function decreasePosition(DecreaseLiquidityParams memory p) external onlyManager nonReentrant {
87          function increasePosition(IncreaseLiquidityParams memory p) external onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


42          function updateOwners(address[] memory _owners, bool[] memory addOrRemove) public onlyOwner {
63          function setThreshold(uint8 _threshold) public onlyOwner {
84          function execute(
124         function domainSeparatorV4() public view returns (bytes32) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/governance/NoyaGovernanceBase.sol


21          constructor(PositionRegistry _registry, uint256 _vaultId) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L0:0

```solidity
File: contracts/governance/TimeLock.sol


7           constructor(uint256 minDelay, address[] memory proposers, address[] memory executors, address owner)


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/TimeLock.sol#L0:0

```solidity
File: contracts/governance/Watchers.sol


7           constructor(address[] memory _owners, uint8 _threshold) Keepers(_owners, _threshold) { }
8           function verifyRemoveLiquidity(uint256 withdrawAmount, uint256 sentAmount, bytes memory data) external view { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Watchers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


33          constructor(BaseConnectorCP memory params) NoyaGovernanceBase(params.registry, params.vaultId) {
67          function updateValueOracle(address _valueOracle) external onlyMaintainer {
84          function sendTokensToTrustedAddress(address token, uint256 amount, address caller, bytes memory data)
122         function transferPositionToAnotherConnector(
153         function updateTokenInRegistry(address token) public onlyManager {
169         function addLiquidity(address[] memory tokens, uint256[] memory amounts, bytes memory data)
232         function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {
249         function getPositionTVL(HoldingPI memory p, address baseToken) public view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


22          constructor(address _registry, uint256 _vaultId) {
27          function sendTokensToTrustedAddress(address token, uint256 amount, address caller, bytes memory data)
40          function addLiquidity(address[] memory tokens, uint256[] memory amounts, bytes memory data) external {
51          function updatePositionToRegistryUsingType(bytes32 _positionId, bytes memory data, bool remove) external {
59          function addPositionToRegistryUsingType(uint256 _positionType, bytes memory data) external {
65          function addPositionToRegistry(bytes memory data) external {
71          function getPositionTVL(HoldingPI memory p, address baseToken) public view returns (uint256) {
75          function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


31          constructor(address _endpoint, address _owner) OAppReceiver() OAppCore(_endpoint, _owner) { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


27          receive() external payable { }
29          constructor(address _endpoint, address _owner) OAppSender() OAppCore(_endpoint, _owner) { }
36          function updateMessageSetting(bytes memory _messageSetting) public onlyOwner {
51          function setChainInfo(uint256 chainId, uint32 lzChainId, address lzHelperAddress) public onlyOwner {
63          function addVaultInfo(uint256 vaultId, uint256 baseChainId, address omniChainManager) public onlyOwner {
75          function updateTVL(uint256 vaultId, uint256 tvl, uint256 updateTime) public {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


46          function updateChainInfo(uint256 chainId, address destinationAddress) external onlyMaintainer {
57          function updateBridgeTransactionApproval(bytes32 transactionHash) public onlyManager {
68          function startBridgeTransaction(BridgeRequest memory bridgeRequest) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


19          constructor(uint256 dl, address payable _lzHelper, BaseConnectorCP memory baseConnectorParams)


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol


11          constructor(address payable _lzHelper, BaseConnectorCP memory baseConnectorParams)
19          function getTVL() public view returns (uint256) {
28          function updateTVLInfo() external onlyManager {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


34          constructor(address[] memory usersAddresses, address _valueOracle, PositionRegistry _registry, uint256 _vaultId)


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


27          constructor(address swapHandler, address _lifi) Ownable2Step() Ownable(msg.sender) {
150         function verifyBridgeData(BridgeRequest calldata _request) public view override returns (bool) {
193         function rescueFunds(address token, address userAddress, uint256 amount) external onlyOwner {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/TVLHelper.sol


41          function getLatestUpdateTime(uint256 vaultId, PositionRegistry registry) public view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/TVLHelper.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


29          constructor(PositionRegistry _registry) {
61          function updatePriceRoute(address asset, address base, address[] calldata s) external onlyMaintainer {
71          function getValue(address asset, address baseToken, uint256 amount) public view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


46          constructor(address _reg) {
143         function getSourceOfAsset(address asset, address baseToken) public view returns (address source, bool isInverse) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/WETH_Oracle.sol


5           function latestRoundData()


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/WETH_Oracle.sol#L0:0

</details>

## NC026 - Contract declarations should have `@notice` tags:

`@notice` is used to explain to end users what the contract does, and the compiler interprets `///` or `/**` comments as this tag if one wasn't explicitly provided.


<details>
<summary>Click to show 39 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


16      contract AccountingManager is IAccountingManager, ERC4626, ReentrancyGuard, Pausable, NoyaGovernanceBase {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


7       contract NoyaFeeReceiver is Ownable {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


12      contract PositionRegistry is AccessControl, IPositionRegistry, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


11      contract AaveConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


27      contract AerodromeConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


26      contract BalancerConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


12      contract BalancerFlashLoan is IFlashLoanRecipient, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


30      contract CamelotConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


7       contract CompoundConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


24      contract CurveConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


9       contract DolomiteConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


18      contract FraxConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


8       contract Gearboxv3 is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


7       contract LidoConnector is BaseConnector, ERC721Holder {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


29      contract MaverickConnector is BaseConnector, IERC721Receiver {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


8       contract MorphoBlueConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


8       contract PancakeswapConnector is UNIv3Connector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


12      contract PendleConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


11      contract PrismaConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


7       contract SNXV3Connector is BaseConnector, IERC721Receiver {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


8       contract SiloConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


19      contract StargateConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


12      contract UNIv3Connector is BaseConnector, ERC721Holder {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


9       contract Keepers is EIP712, Ownable2Step {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/governance/NoyaGovernanceBase.sol


6       contract NoyaGovernanceBase {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L0:0

```solidity
File: contracts/governance/TimeLock.sol


6       contract NoyaTimeLock is TimelockController {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/TimeLock.sol#L0:0

```solidity
File: contracts/governance/Watchers.sol


6       contract Watchers is Keepers {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Watchers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


22      contract BaseConnector is NoyaGovernanceBase, IConnector, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


14      contract ConnectorMock2 {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


18      contract LZHelperReceiver is OAppReceiver {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


19      contract LZHelperSender is OAppSender {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


14      abstract contract OmnichainLogic is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


8       contract OmnichainManagerBaseChain is OmnichainLogic {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol


10      contract OmnichainManagerNormalChain is OmnichainLogic {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


10      contract SwapAndBridgeHandler is NoyaGovernanceBase, ISwapAndBridgeHandler, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


10      contract LifiImplementation is ISwapAndBridgeImplementation, Ownable2Step, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/TVLHelper.sol


7       library TVLHelper {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/TVLHelper.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


10      contract ChainlinkOracleConnector is INoyaValueOracle {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/WETH_Oracle.sol


4       contract WETH_Oracle {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/WETH_Oracle.sol#L0:0

</details>

## NC027 - Invalid NatSpec comment style:

NatSpec must begin with `///`, or use `/* ... */` syntax. 


```solidity
File: contracts/accountingManager/Registry.sol


265         // @dev This function is used to remove trusted positions from a vault


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


134         // @dev the following functions are used to manage holding tokens in the registry


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

## NC028 - Error declarations should have NatSpec descriptions:

  


<details>
<summary>Click to show 7 findings</summary>

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


19          error Unauthorized(address sender);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


33          error InsufficientSyOut(uint256 netSyOut, uint256 minSY);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/governance/NoyaGovernanceBase.sol


14          error NoyaGovernance_Unauthorized(address sender);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


22          error InvalidPayload();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


25          error InvalidSender();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


18          error NoyaOracle_PriceOracleUnavailable(address asset, address baseToken);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


37          error NoyaChainlinkOracle_DATA_OUT_OF_DATE();
38          error NoyaChainlinkOracle_PRICE_ORACLE_UNAVAILABLE(address asset, address baseToken, address source);
39          error NoyaChainlinkOracle_INVALID_INPUT();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

</details>

## NC029 - Contract does not follow the Solidity style guide's suggested layout ordering:

The [style guide](https://docs.soliditylang.org/en/v0.8.16/style-guide.html#order-of-layout) says that, within a contract, the ordering should be 1) Type declarations, 2) State variables, 3) Events, 4) Modifiers, and 5) Functions, but the contract(s) below do not follow this ordering.


```solidity
File: contracts/governance/NoyaGovernanceBase.sol


31          modifier onlyManager() {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


34          modifier onlyHandler() {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

## NC030 - Non-external/public variable names should begin with an underscore:

According to the Solidity Style Guide, non-external/public variable names should begin with an underscore


<details>
<summary>Click to show 8 findings</summary>

```solidity
File: contracts/connectors/AaveConnector.sol


18          address immutable pool;
22          address immutable poolBaseToken;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


33          IRouter aerodromeRouter;
34          IVoter voter;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


27          address internal balancerVault;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


15          IBalancerVault internal vault;
17          address caller;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


30          address mav;
31          address veMav;
32          address maverickRouter;
33          IPositionInspector positionInspector;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


22          IStargateLPStaking LPStaking;
23          IStargateRouter stargateRouter;
24          address rewardToken;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


23          bytes messageSetting;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


20          mapping(address => mapping(address => address)) private assetsSources;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

</details>

## NC031 - Consider disabling `renounceOwnership()`:

If the plan for your project does not include eventually giving up all ownership control, consider overwriting OpenZeppelin's Ownable's `renounceOwnership()` function in order to disable it.


```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


7       contract NoyaFeeReceiver is Ownable {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


9       contract Keepers is EIP712, Ownable2Step {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


10      contract LifiImplementation is ISwapAndBridgeImplementation, Ownable2Step, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

## NC032 - Not using the named return variables anywhere in the function is confusing:

Consider changing the return variable to be an unnamed one, since the variable is never assigned, nor is it returned by name


<details>
<summary>Click to show 16 findings</summary>

```solidity
File: contracts/connectors/AaveConnector.sol


114         function _getPositionTVL(HoldingPI memory, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


88          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


265         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


106         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


150         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


93          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


91          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


153         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


145         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


74              returns (uint256 userLTV, uint256 LiquidationThreshold, bool isSolvent)


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


110         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


271         function _getPositionTVL(HoldingPI memory, address) public view virtual returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


189         function _isNative(IERC20 token) internal pure returns (bool isNative) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


84              returns (uint256 value)


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


143         function getSourceOfAsset(address asset, address baseToken) public view returns (address source, bool isInverse) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/WETH_Oracle.sol


8               returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/WETH_Oracle.sol#L0:0

</details>

## NC033 - Unused arguments in override functions:

Arguments in overridden functions that are unused should have their names removed or commented out to avoid compiler warnings.


<details>
<summary>Click to show 4 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


693         function mint(uint256 shares, address receiver) public override returns (uint256) {
693         function mint(uint256 shares, address receiver) public override returns (uint256) {
697         function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256) {
697         function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256) {
697         function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256) {
701         function redeem(uint256 shares, address receiver, address shareOwner) public override returns (uint256) {
701         function redeem(uint256 shares, address receiver, address shareOwner) public override returns (uint256) {
701         function redeem(uint256 shares, address receiver, address shareOwner) public override returns (uint256) {
705         function deposit(uint256 assets, address receiver) public override returns (uint256) {
705         function deposit(uint256 assets, address receiver) public override returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


99          function _getUnderlyingTokens(uint256 id, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


134         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


161         function _getUnderlyingTokens(uint256 id, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

</details>

## NC034 - Expressions for constant values such as a call to `keccak256()`, should use `immutable` rather than `constant`:

While it **doesn't save any gas** because the compiler knows that developers often make this mistake, it's still best to use the right tool for the task at hand. There is a difference between `constant` variables and `immutable` variables, and they should each be used in their appropriate contexts. `constants` should be used for literal values written into the code, and `immutable` variables should be used for expressions, or values calculated in, or passed into the constructor.


```solidity
File: contracts/accountingManager/Registry.sol


15          bytes32 public constant MAINTAINER_ROLE = keccak256("MAINTAINER_ROLE");
17          bytes32 public constant GOVERNER_ROLE = keccak256("GOVERNER_ROLE");
19          bytes32 public constant EMERGENCY_ROLE = keccak256("EMERGENCY_ROLE");


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


11          bytes32 public constant TXTYPE_HASH = keccak256(
12              "Execute(uint256 nonce,address destination,bytes data,uint256 gasLimit,address executor, uint256 deadline)"
13          );


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

## NC035 - Empty Function Body - Consider commenting why:

  


```solidity
File: contracts/governance/Watchers.sol


8           function verifyRemoveLiquidity(uint256 withdrawAmount, uint256 sentAmount, bytes memory data) external view { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Watchers.sol#L0:0

## NC036 - Contracts should have full test coverage:

While 100% code coverage does not guarantee that there are no bugs, it often will catch easy-to-find bugs, and will ensure that there are fewer regressions when the code invariably has to be modified. Furthermore, in order to get full coverage, code authors will often have to re-organize their code so that it is more modular, so that each component can be tested separately, which reduces interdependencies between modules and layers, and makes for code that is easier to reason about and audit.


```solidity
File: Various Files


None

```

## NC037 - Large or complicated code bases should implement invariant tests:

Large code bases, or code with lots of inline-assembly, complicated math, or complicated interactions between multiple contracts, should implement invariant fuzzing tests. Invariant fuzzers such as Echidna require the test writer to come up with invariants which should not be violated under any circumstances, and the fuzzer tests various inputs and function calls to ensure that the invariants always hold. Even code with 100% code coverage can still have bugs due to the order of the operations a user performs, and invariant fuzzers, with properly and extensively-written invariants, can close this testing gap significantly.


```solidity
File: Various Files


None

```

## NC038 - Consider using `block.number` instead of `block.timestamp`:

`block.timestamp` is vulnerable to miner manipulation and creates a potential front-running vulnerability. Consider using `block.number` instead.


<details>
<summary>Click to show 7 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


101             lastFeeDistributionTime = block.timestamp;
215             depositQueue.queue[depositQueue.last] = DepositRequest(receiver, block.timestamp, 0, amount, 0);
216             emit RecordDeposit(depositQueue.last, receiver, block.timestamp, amount, referrer);
241                 data.calculationTime = block.timestamp;
243                     middleTemp, data.receiver, block.timestamp, shares, data.amount, shares * 1e18 / data.amount
269                     && depositQueue.queue[firstTemp].calculationTime + depositWaitingTime <= block.timestamp && i < maxI
275                     firstTemp, data.receiver, block.timestamp, data.shares, data.amount, data.shares * 1e18 / data.amount
313             withdrawQueue.queue[withdrawQueue.last] = WithdrawRequest(msg.sender, receiver, block.timestamp, 0, share, 0);
314             emit RecordWithdraw(withdrawQueue.last, msg.sender, receiver, share, block.timestamp);
346                 data.calculationTime = block.timestamp;
349                 emit CalculateWithdraw(middleTemp, data.owner, data.receiver, data.shares, assets, block.timestamp);
408                     && withdrawQueue.queue[firstTemp].calculationTime + withdrawWaitingTime <= block.timestamp
430                     firstTemp, data.owner, data.receiver, shares, data.amount, baseTokenAmount, block.timestamp
477             profitStoredTime = block.timestamp;
486                 storedProfitForFee, totalProfitCalculated, preformanceFeeSharesWaitingForDistribution, block.timestamp
496                 emit ResetFee(currentProfit, storedProfitForFee, block.timestamp);
506             if (block.timestamp - lastFeeDistributionTime < 1 days) {
509             uint256 timePassed = block.timestamp - lastFeeDistributionTime;
521             lastFeeDistributionTime = block.timestamp;
528                 preformanceFeeSharesWaitingForDistribution == 0 || block.timestamp - profitStoredTime < 12 hours
529                     || block.timestamp - profitStoredTime > 48 hours


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


98              require(block.timestamp <= deadline, "Transaction expired");


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


59              else approvedBridgeTXN[transactionHash] = block.timestamp;
60              emit UpdateBridgeTransactionApproval(transactionHash, block.timestamp);
71              if (approvedBridgeTXN[txn] == 0 || approvedBridgeTXN[txn] + BRIDGE_TXN_WAITING_TIME > block.timestamp) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol


30              LZHelperSender(lzHelper).updateTVL(vaultId, tvl, block.timestamp);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol#L0:0

```solidity
File: contracts/helpers/TVLHelper.sol


50                  latestUpdateTime = block.timestamp;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/TVLHelper.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


125             if (block.timestamp - updatedAt > chainlinkPriceAgeThreshold) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/WETH_Oracle.sol


10              return (0, 1e18, 0, block.timestamp, 0);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/WETH_Oracle.sol#L0:0

</details>

## NC039 - Consider bounding input array length:

The functions below take in an unbounded array, and make function calls for entries in the array. While the function will revert if it eventually runs out of gas, it may be a nicer user experience to `require()` that the length of the array is below some reasonable maximum, so that the user doesn't have to use up a full transaction's gas only to see that the transaction reverts.


<details>
<summary>Click to show 12 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


551             for (uint256 i = 0; i < retrieveData.length; i++) {
552                 if (!registry.isAnActiveConnector(vaultId, retrieveData[i].connectorAddress)) {
553                     continue;
554                 }
555                 uint256 balanceBefore = baseToken.balanceOf(address(this));
556                 uint256 amount = IConnector(retrieveData[i].connectorAddress).sendTokensToTrustedAddress(
557                     address(baseToken), retrieveData[i].withdrawAmount, address(this), retrieveData[i].data
558                 );
559                 uint256 balanceAfter = baseToken.balanceOf(address(this));
560                 if (balanceBefore + amount > balanceAfter) revert NoyaAccounting_banalceAfterIsNotEnough();
561                 amountAskedForWithdraw_temp += retrieveData[i].withdrawAmount;
562                 emit RetrieveTokensForWithdraw(
563                     retrieveData[i].withdrawAmount,
564                     retrieveData[i].connectorAddress,
565                     amount,
566                     amountAskedForWithdraw + amountAskedForWithdraw_temp
567                 );
568             }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


194             for (uint256 i = 0; i < _connectorAddresses.length; i++) {
195                 vault.connectors[_connectorAddresses[i]].enabled = _enableds[i];
196                 emit ConnectorAdded(vaultId, _connectorAddresses[i]);
197             }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


54              for (uint256 i = 0; i < rewardsPools.length; i++) {
55                  IRewardPool baseRewardPool = IRewardPool(rewardsPools[i]);
56                  baseRewardPool.getReward();
57              }
77              for (uint256 i = 0; i < tokens.length; i++) {
78                  if (amounts[i] > 0) _approveOperations(tokens[i], balancerVault, amounts[i]);
79              }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


74                  for (uint256 i = 0; i < tokens.length; i++) {
75                      // send the tokens to the receiver
76                      tokens[i].safeTransfer(receiver, amounts[i]);
77                      amounts[i] = amounts[i] + feeAmounts[i];
78                  }
79                  for (uint256 i = 0; i < destinationConnector.length; i++) {
80                      // execute the transactions
81                      (bool success,) = destinationConnector[i].call{ value: 0, gas: gas[i] }(callingData[i]);
82                      require(success, "BalancerFlashLoan: Flash loan failed");
83                  }
84                  for (uint256 i = 0; i < tokens.length; i++) {
85                      // send the tokens back to this contract
86                      BaseConnector(receiver).sendTokensToTrustedAddress(address(tokens[i]), amounts[i], address(this), "");
87                  }
89              for (uint256 i = 0; i < tokens.length; i++) {
90                  // send the tokens back to the vault
91                  tokens[i].safeTransfer(msg.sender, amounts[i]);
92                  require(tokens[i].balanceOf(address(this)) == 0, "BalancerFlashLoan: Flash loan extra tokens");
93              }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


222             for (uint256 i = 0; i < gauges.length; i++) {
223                 IRewardsGauge(gauges[i]).claim_rewards(address(this));
224             }
234             for (uint256 i = 0; i < pools.length; i++) {
235                 IDepositToken(pools[i]).claimReward(address(this));
236             }
248             for (uint256 i = 0; i < rewardsPools.length; i++) {
249                 IConvexBasicRewards baseRewardPool = IConvexBasicRewards(rewardsPools[i]);
250                 baseRewardPool.getReward(address(this), true);
251             }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


69              for (uint256 i = 0; i < calls.length; i++) {
70                  if (calls[i].target != facade) revert IConnector_InvalidTarget(calls[i].target);
71                  bytes4 method = bytes4(calls[i].callData[:4]);
72      
73                  if (method == ICreditFacadeV3Multicall.enableToken.selector) {
74                      (address token) = abi.decode(calls[i].callData[4:], (address));
75                      _updateTokenInRegistry(token);
76                  }
77              }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


102             for (uint256 i = 0; i < tokenIds.length; i++) {
103                 (, address token0, address token1) = getCurrentLiquidity(tokenIds[i]);
104                 _collectFees(tokenIds[i]);
105                 _updateTokenInRegistry(token0);
106                 _updateTokenInRegistry(token1);
107                 emit CollectFees(tokenIds[i]);
108             }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


178             for (uint256 i = 0; i < tokens.length; i++) {
179                 // gather all of the tokens
180                 uint256 _balance = IERC20(tokens[i]).balanceOf(address(this));
181                 ITokenTransferCallBack(msg.sender).sendTokensToTrustedAddress(tokens[i], amounts[i], msg.sender, "");
182                 uint256 _balanceAfter = IERC20(tokens[i]).balanceOf(address(this));
183                 if (_balanceAfter < amounts[i] + _balance) {
184                     revert IConnector_InsufficientDepositAmount(_balanceAfter - _balance, amounts[i]);
185                 }
186             }
189             for (uint256 i = 0; i < tokens.length; i++) {
190                 _updateTokenInRegistry(tokens[i]); // update the token in the registry
191             }
211             for (uint256 i = 0; i < tokensIn.length; i++) {
212                 _executeSwap(
213                     SwapRequest(address(this), routeIds[i], amountsIn[i], tokensIn[i], tokensOut[i], swapData[i], true, 0)
214                 );
215                 _updateTokenInRegistry(tokensIn[i]);
216                 _updateTokenInRegistry(tokensOut[i]);
217                 emit SwapHoldings(tokensIn[i], tokensOut[i], amountsIn[i], swapData[i]);
218             }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


41              for (uint256 i = 0; i < tokens.length; i++) {
42                  // gather all of the tokens
43      
44                  ITokenTransferCallBack(msg.sender).sendTokensToTrustedAddress(tokens[i], amounts[i], msg.sender, "");
45              }
46              for (uint256 i = 0; i < tokens.length; i++) {
47                  _updateTokenInRegistry(tokens[i]); // update the token in the registry
48              }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


148             for (uint256 i = 0; i < _routes.length;) {
149                 routes.push(_routes[i]);
150                 emit NewRouteAdded(i, _routes[i].route, _routes[i].isEnabled, _routes[i].isBridge);
151                 unchecked {
152                     i++;
153                 }
154             }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


55              for (uint256 i = 0; i < oracle.length; i++) {
56                  priceSource[asset[i]][baseToken[i]] = INoyaValueOracle(oracle[i]);
57              }
88              for (uint256 i = 0; i < sources.length; i++) {
89                  initialValue = _getValue(asset, sources[i], initialValue);
90                  quotingToken = sources[i];
91              }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


74              for (uint256 i = 0; i < assets.length; i++) {
75                  assetsSources[assets[i]][baseTokens[i]] = sources[i];
76                  emit AssetSourceUpdated(assets[i], baseTokens[i], sources[i]);
77              }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

</details>

## NC040 - Large numeric literals should use underscores for readability:

At a glance, it's quite difficult to understand how big this number is. Use underscores to make values more clear.


```solidity
File: contracts/accountingManager/AccountingManager.sol


89          uint256 public depositLimitPerTransaction = 1e6 * 2000;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


19          uint32 public period = 1800;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

## NC041 - Variables should be named in mixedCase style:

As the [Solidity Style Guide](https://docs.soliditylang.org/en/latest/style-guide.html#naming-styles) suggests: arguments, local variables and mutable state variables should be named in mixedCase style.


<details>
<summary>Click to show 21 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


257         function executeDeposit(uint256 maxI, address connector, bytes memory addLPdata)
549             uint256 amountAskedForWithdraw_temp = 0;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


298             bytes calldata AD,


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


126             PositionBP memory pBP = registry.getPositionBP(vaultId, p.positionId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


30          address public AURA;
34          event OpenPosition(
35              bytes32 poolId, uint256[] amounts, uint256[] amountsWithoutBPT, uint256 minBPT, uint256 auraAmount
36          );
68              uint256 minBPT,
29          address public BAL;
163             PositionBP memory PTI = registry.getPositionBP(vaultId, p.positionId);
32          uint256 public BALANCER_LP_POSITION = 1;
67              uint256[] memory amountsWithoutBPT,


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


17          uint256 minAmountB;
14          uint256 amountA;
23          address tokenB;
16          uint256 minAmountA;
100             (address tokenA, address tokenB) = abi.decode(data, (address, address));
25          uint256 minAmountA;
36          constructor(address _router, address _factory, BaseConnectorCP memory baseCP) BaseConnector(baseCP) {
13          address tokenB;
26          uint256 minAmountB;
12          address tokenA;
89              (address tokenA, address tokenB) =
22          address tokenA;
15          uint256 amountB;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


8           uint256 public COMPOUND_LP = 2;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


14          address convexLPToken;
27          address public CVX;
29          address public PRISMA;
28          address public CRV;
266             PositionBP memory PTI = registry.getPositionBP(vaultId, p.positionId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


132             uint256 fraxlendPairMaxLTV = _fraxlendPair.maxLTV();
136             uint256 currentHF = (fraxlendPairMaxLTV * 1e18) / currentPositionLTV;
128             uint256 currentPositionLTV =
127             (uint256 LTV_PRECISION,,,, uint256 EXCHANGE_PRECISION,,,) = _fraxlendPair.getConstants();
22          uint256 public COLLATERAL_AND_DEBT_POSITION_TYPE = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


20          constructor(address _lido, address _lidoW, address _steth, address w, BaseConnectorCP memory baseConnectorParams)
13          uint256 public LIDO_WITHDRAWAL_REQUEST_ID = 10;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


14          uint256 minTokenBAmount;
16          uint256 tokenBRequiredAllowance;
43          constructor(address _mav, address _veMav, address mr, address pi, BaseConnectorCP memory baseCP)
25          uint256 minTokenBAmount;
13          uint256 minTokenAAmount;
35          uint256 public MAVERICK_LP = 10;
15          uint256 tokenARequiredAllowance;
24          uint256 minTokenAAmount;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


17          event Supply(uint256 amount, Id id, bool sOrC);
23          constructor(address MB, BaseConnectorCP memory baseCP) BaseConnector(baseCP) {
58          function withdraw(uint256 amount, Id id, bool sOrC) external onlyManager nonReentrant {
35          function supply(uint256 amount, Id id, bool sOrC) external onlyManager nonReentrant {
18          event Withdraw(uint256 amount, Id id, bool sOrC);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


19          constructor(address MC, address _positionManager, address _factory, BaseConnectorCP memory baseConnectorParams)


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


98              (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
277                 uint256 YTBalance = _YT.balanceOf(address(this));
304             (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
37          event DepositIntoMarket(address market, uint256 SYamount, uint256 PTamount);
153             (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
217             (IPStandardizedYield SY,,) = market.readTokens();
57          constructor(address _pendleMarketDepositHelper, address _pendleRouter, address SR, BaseConnectorCP memory baseCP)
149         function swapYTForPT(address market, uint256 exactYTIn, uint256 min, ApproxParams memory guess)
265                 uint256 SYAmount = _SY.balanceOf(address(this));
113             (IPStandardizedYield _SY, IPPrincipalToken _PT,) = IPMarket(market).readTokens();
40          event SwapYTForPT(address market, uint256 exactYTIn, uint256 min, ApproxParams guess);
274                 uint256 PTAmount = _PT.balanceOf(address(this));
183         function swapExactPTForSY(IPMarket market, uint256 exactPTIn, bytes calldata swapData, uint256 minSY)
41          event SwapYTForSY(address market, uint256 exactYTIn, uint256 min, LimitOrderData orderData);
188             (IPStandardizedYield _SY, IPPrincipalToken _PT,) = IPMarket(market).readTokens();
170             (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
166         function swapYTForSY(address market, uint256 exactYTIn, uint256 min, LimitOrderData memory orderData)
262                 (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
79              (IPStandardizedYield _SY, IPPrincipalToken _PT,) = IPMarket(market).readTokens();
313             (IPStandardizedYield SY,,) = IPMarket(market).readTokens();
42          event SwapExactPTForSY(address market, uint256 exactPTIn, bytes swapData, uint256 minSY);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


14          IV3CoreProxy public SNXCoreProxy;
20          constructor(address _SNXCoreProxy, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


17          constructor(address SR, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {
52          function withdraw(address siloToken, address wToken, uint256 amount, bool oC, bool closePosition)
115             uint256 totalBAmount = 0;
13          event Withdraw(address siloToken, address wToken, uint256 amount, bool oC, bool closePosition);
12          event Deposit(address siloToken, address dToken, uint256 amount, bool oC);
131             (, IBaseSilo.AssetStorage[] memory assetsS) = silo.getAssetsWithState();
113             (address[] memory assets, IBaseSilo.AssetStorage[] memory assetsS) = silo.getAssetsWithState();
33          function deposit(address siloToken, address dToken, uint256 amount, bool oC) external onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


111             PositionBP memory pBP = registry.getPositionBP(vaultId, p.positionId);
16          uint256 LPStakingAmount;
88              uint256 LPAmount = LPStaking.userInfo(withdrawRequest.poolId, address(this)).amount;
22          IStargateLPStaking LPStaking;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


133             (int24 tL, int24 tU, uint24 fee) = abi.decode(p.additionalData, (int24, int24, uint24));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


89              bytes32[] memory sigR,
91              uint8[] memory sigV,
90              bytes32[] memory sigS,


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


28          uint256 public MINIMUM_HEALTH_FACTOR = 15e17;
31          uint256 public DUST_LEVEL = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


22          mapping(bytes32 => uint256) public approvedBridgeTXN;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/TVLHelper.sol


15              uint256 totalTVL;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/TVLHelper.sol#L0:0

</details>

## NC042 - Consider using named mappings:

Consider moving to solidity version 0.8.18 or later, and using [named mappings](https://ethereum.stackexchange.com/a/145555) to make it easier to understand the purpose of each mapping.


<details>
<summary>Click to show 11 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


27          mapping(address => uint256) public withdrawRequestsByAddress;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


26          mapping(uint256 => Vault) public vaults;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


10          mapping(address => bool) public isOwner;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


19          mapping(uint32 => ChainInfo) public chainInfo; // chainId => ChainInfo
20          mapping(uint256 => VaultInfo) public vaultIdToVaultInfo; // vaultId => VaultInfo


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


20          mapping(uint256 => ChainInfo) public chainInfo; // chainId => ChainInfo
21          mapping(uint256 => VaultInfo) public vaultIdToVaultInfo; // vaultId => VaultInfo


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


21          mapping(uint256 => address) public destChainAddress;
22          mapping(bytes32 => uint256) public approvedBridgeTXN;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


13          mapping(address => bool) public isEligibleToUse;
15          mapping(address => mapping(address => uint256)) public slippageTolerance;
15          mapping(address => mapping(address => uint256)) public slippageTolerance;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


13          mapping(address => bool) public isHandler;
14          mapping(string => bool) public isBridgeWhiteListed;
15          mapping(uint256 => bool) public isChainSupported;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


13          mapping(address => INoyaValueOracle) public defaultPriceSource;
16          mapping(address => mapping(address => INoyaValueOracle)) public priceSource;
16          mapping(address => mapping(address => INoyaValueOracle)) public priceSource;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


20          mapping(address => mapping(address => address)) private assetsSources;
20          mapping(address => mapping(address => address)) private assetsSources;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


14          mapping(address => mapping(address => address)) public assetToBaseToPool;
14          mapping(address => mapping(address => address)) public assetToBaseToPool;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## NC043 - Use allowlist/denylist rather than whitelist/blacklist:

Use alternative variants, e.g. allowlist/denylist instead of whitelist/blacklist.


```solidity
File: contracts/connectors/PancakeswapConnector.sol


5       import "../external/interfaces/Pancakeswap/IMasterChefV3.sol";
12          IMasterchefV3 public masterchef;
14          event SendPositionToMasterChef(uint256 tokenId);
23              masterchef = IMasterchefV3(MC);
31          function sendPositionToMasterChef(uint256 tokenId) external onlyManager nonReentrant {
32              IERC721(address(positionManager)).safeTransferFrom(address(this), address(masterchef), tokenId);
33              emit SendPositionToMasterChef(tokenId);
41              masterchef.updateLiquidity(tokenId);
42              _updateTokenInRegistry(masterchef.CAKE());
51              masterchef.withdraw(tokenId, address(this));
52              _updateTokenInRegistry(masterchef.CAKE());


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


14          mapping(string => bool) public isBridgeWhiteListed;
22          event AddedBridgeBlacklist(string bridgeName, bool state);
65          function addBridgeBlacklist(string memory bridgeName, bool state) external onlyOwner {
66              isBridgeWhiteListed[bridgeName] = state;
67              emit AddedBridgeBlacklist(bridgeName, state);
153             if (isBridgeWhiteListed[bridgeData.bridge] == false) revert BridgeBlacklisted();
153             if (isBridgeWhiteListed[bridgeData.bridge] == false) revert BridgeBlacklisted();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

## NC044 - Function names should use lowerCamelCase:

According to the Solidity [style guide](https://docs.soliditylang.org/en/latest/style-guide.html#function-names) function names should be in `mixedCase` (lowerCamelCase).


<details>
<summary>Click to show 26 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


493         function checkIfTVLHasDroped() public nonReentrant {
627         function TVL() public view returns (uint256) {
632         function getPositionTVL(HoldingPI memory position, address base) public view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


224         function getPositionBP(uint256 vaultId, bytes32 _positionId) public view returns (PositionBP memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


114         function _getPositionTVL(HoldingPI memory, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


125         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


162         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


88          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


125         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


265         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


106         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


150         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


93          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


91          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


153         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


118         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
137         function convertCToL(uint256 amount, address marketOracle, address collateral) public view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


97          function mintPTAndYT(address market, uint256 syAmount) external onlyManager nonReentrant {
149         function swapYTForPT(address market, uint256 exactYTIn, uint256 min, ApproxParams memory guess)
166         function swapYTForSY(address market, uint256 exactYTIn, uint256 min, LimitOrderData memory orderData)
183         function swapExactPTForSY(IPMarket market, uint256 exactPTIn, bytes calldata swapData, uint256 minSY)
257         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
293         function getYTValue(address market, uint256 balance) public view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


145         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


102         function mintOrBurnSUSD(
121         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


109         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


110         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


127         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


249         function getPositionTVL(HoldingPI memory p, address baseToken) public view returns (uint256) {
271         function _getPositionTVL(HoldingPI memory, address) public view virtual returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


71          function getPositionTVL(HoldingPI memory p, address baseToken) public view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


75          function updateTVL(uint256 vaultId, uint256 tvl, uint256 updateTime) public {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


32          function updateTVL(uint256 chainId, uint256 tvl, uint256 updateTime) external nonReentrant {
51          function _getPositionTVL(HoldingPI memory position, address) public view override returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol


19          function getTVL() public view returns (uint256) {
28          function updateTVLInfo() external onlyManager {
33          function _getPositionTVL(HoldingPI memory position, address base) public view override returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol#L0:0

```solidity
File: contracts/helpers/TVLHelper.sol


14          function getTVL(uint256 vaultId, PositionRegistry registry, address baseToken) public view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/TVLHelper.sol#L0:0

</details>

## NC045 - Consider adding a deny-list:

Doing so will significantly increase centralization, but will help to prevent hackers from using stolen tokens.


<details>
<summary>Click to show 36 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


16      contract AccountingManager is IAccountingManager, ERC4626, ReentrancyGuard, Pausable, NoyaGovernanceBase {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


7       contract NoyaFeeReceiver is Ownable {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


12      contract PositionRegistry is AccessControl, IPositionRegistry, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


11      contract AaveConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


27      contract AerodromeConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


26      contract BalancerConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


12      contract BalancerFlashLoan is IFlashLoanRecipient, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


30      contract CamelotConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


7       contract CompoundConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


24      contract CurveConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


9       contract DolomiteConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


18      contract FraxConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


8       contract Gearboxv3 is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


7       contract LidoConnector is BaseConnector, ERC721Holder {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


29      contract MaverickConnector is BaseConnector, IERC721Receiver {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


8       contract MorphoBlueConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


8       contract PancakeswapConnector is UNIv3Connector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


12      contract PendleConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


11      contract PrismaConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


7       contract SNXV3Connector is BaseConnector, IERC721Receiver {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


8       contract SiloConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


19      contract StargateConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


12      contract UNIv3Connector is BaseConnector, ERC721Holder {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


9       contract Keepers is EIP712, Ownable2Step {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/governance/Watchers.sol


6       contract Watchers is Keepers {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Watchers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


22      contract BaseConnector is NoyaGovernanceBase, IConnector, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


14      contract ConnectorMock2 {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


18      contract LZHelperReceiver is OAppReceiver {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


19      contract LZHelperSender is OAppSender {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


8       contract OmnichainManagerBaseChain is OmnichainLogic {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol


10      contract OmnichainManagerNormalChain is OmnichainLogic {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


10      contract SwapAndBridgeHandler is NoyaGovernanceBase, ISwapAndBridgeHandler, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


10      contract NoyaValueOracle is INoyaValueOracle {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


10      contract ChainlinkOracleConnector is INoyaValueOracle {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


12      contract UniswapValueOracle is INoyaValueOracle {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/WETH_Oracle.sol


4       contract WETH_Oracle {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/WETH_Oracle.sol#L0:0

</details>

## NC046 - Custom errors should be used rather than `revert()`/`require()`:

Custom errors are available from solidity version 0.8.4. Custom errors are more easily processed in `try`-`catch` blocks, and are easier to re-use and maintain.


<details>
<summary>Click to show 27 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


106             require(p._baseTokenAddress != address(0));
107             require(p._valueOracle != address(0));
108             require(p._withdrawFeeReceiver != address(0));
109             require(p._performanceFeeReceiver != address(0));
110             require(p._managementFeeReceiver != address(0));
125             require(address(_valueOracle) != address(0));
140             require(_withdrawFeeReceiver != address(0));
141             require(_performanceFeeReceiver != address(0));
142             require(_managementFeeReceiver != address(0));
361             require(currentWithdrawGroup.isStarted == false && currentWithdrawGroup.isFullfilled == false);
371             require(currentWithdrawGroup.isStarted == true && currentWithdrawGroup.isFullfilled == false);
686                 require(success, "Transfer failed.");
694             revert NoyaAccounting_NOT_ALLOWED();
698             revert NoyaAccounting_NOT_ALLOWED();
702             revert NoyaAccounting_NOT_ALLOWED();
706             revert NoyaAccounting_NOT_ALLOWED();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


15              require(_accountingManager != address(0));
16              require(_baseToken != address(0));
17              require(_receiver != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


67              require(_governer != address(0));
68              require(_maintainer != address(0));
69              require(_emergency != address(0));
80              require(_maxNumHoldingPositions <= MAX_NUM_HOLDING_POSITIONS);
120             require(_governer != address(0));
121             require(_accountingManager != address(0));
122             require(_baseToken != address(0));
123             require(_maintainer != address(0));
124             require(_keeperContract != address(0));
125             require(_watcher != address(0));
167             require(_governer != address(0));
168             require(_maintainer != address(0));
169             require(_keeperContract != address(0));
170             require(_watcher != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


36              require(_pool != address(0));
37              require(_poolBaseToken != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


43              require(_router != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


45              require(_balancerVault != address(0));
46              require(bal != address(0));
47              require(aura != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


25              require(_balancerVault != address(0));
26              require(address(_registry) != address(0));
61              require(msg.sender == address(vault));
82                      require(success, "BalancerFlashLoan: Flash loan failed");
92                  require(tokens[i].balanceOf(address(this)) == 0, "BalancerFlashLoan: Flash loan extra tokens");


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


37              require(_router != address(0));
38              require(_factory != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


52              require(_convexBooster != address(0));
53              require(cvx != address(0));
54              require(crv != address(0));
55              require(prisma != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


24              require(_depositWithdrawalProxy != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


23              require(_lido != address(0));
24              require(_lidoW != address(0));
25              require(_steth != address(0));
26              require(w != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


46              require(_mav != address(0));
47              require(_veMav != address(0));
48              require(mr != address(0));
49              require(pi != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


24              require(MB != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


22              require(MC != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


60              require(_pendleMarketDepositHelper != address(0));
61              require(_pendleRouter != address(0));
62              require(SR != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


21              require(_SNXCoreProxy != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


18              require(SR != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


36              require(lpStacking != address(0));
37              require(_stargateRouter != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


28              require(_owners.length <= 10 && _threshold <= _owners.length && _threshold > 1);
53              require(numOwnersTemp <= 10 && threshold <= numOwnersTemp && threshold > 1);
64              require(_threshold <= numOwners && _threshold > 1);
94              require(isOwner[msg.sender], "Not an owner");
95              require(sigR.length == threshold, "Not enough signatures");
96              require(sigR.length == sigS.length && sigR.length == sigV.length, "Lengths do not match");
97              require(executor == msg.sender, "Invalid executor");
98              require(block.timestamp <= deadline, "Transaction expired");
106                     require(recovered > lastAdd && isOwner[recovered]);
117             require(success, "Transaction execution reverted.");


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/governance/NoyaGovernanceBase.sol


22              require(address(_registry) != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


41              require(lzHelperAddress != address(0));
53              require(omniChainManager != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


52              require(lzHelperAddress != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


25              require(isEligibleToUse[msg.sender], "NoyaSwapHandler: Not eligible to use");
41              require(_valueOracle != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


35              require(isHandler[msg.sender] == true, "LifiImplementation: INVALID_SENDER");
84              require(verifySwapData(_request), "LifiImplementation: INVALID_SWAP_DATA");
196                 require(success, "Transfer failed.");


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


30              require(address(_registry) != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


47              require(_reg != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


50              require(pool != address(0), "pool doesn't exist");


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## NC047 - Top level declarations should be separated by two blank lines:

  


<details>
<summary>Click to show 10 findings</summary>

```solidity
File: contracts/connectors/AerodromeConnector.sol


18      
26      


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


25      
16      


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


20      
29      


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


23      


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


17      
12      


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


19      
28      


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


18      


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


21      


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


17      
12      


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


18      
13      


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

</details>

## NC048 - Custom error has no error details:

Consider adding parameters to the error to indicate which user or values caused the failure.


```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


22          error InvalidPayload();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


25          error InvalidSender();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


37          error NoyaChainlinkOracle_DATA_OUT_OF_DATE();
39          error NoyaChainlinkOracle_INVALID_INPUT();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

## NC049 - Contract uses both `require()`/`revert()` as well as custom errors:

Consider using just one method in a single file


<details>
<summary>Click to show 7 findings</summary>

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


12      contract BalancerFlashLoan is IFlashLoanRecipient, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


12      contract PendleConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/governance/NoyaGovernanceBase.sol


6       contract NoyaGovernanceBase {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


18      contract LZHelperReceiver is OAppReceiver {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


19      contract LZHelperSender is OAppSender {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


10      contract NoyaValueOracle is INoyaValueOracle {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


10      contract ChainlinkOracleConnector is INoyaValueOracle {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

</details>

## NC050 - Consider moving `msg.sender` checks to a common authorization `modifier`:

  


```solidity
File: contracts/connectors/BalancerFlashLoan.sol


61              require(msg.sender == address(vault));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


94              require(isOwner[msg.sender], "Not an owner");
97              require(executor == msg.sender, "Invalid executor");


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

## NC051 - `internal` functions not called by the contract should be removed:

All unused code should be removed.


```solidity
File: contracts/helpers/BaseConnector.sol


    function _getValue(address token, address baseToken, uint256 amount) internal view returns (uint256) {
        if (token == baseToken) {
            return amount;
        }
        if (amount == 0) {
            return 0;
        }
        return valueOracle.getValue(token, baseToken, amount);
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L253:261

## NC052 - Unused `struct` definition:

Note that there may be cases where a struct superficially appears to be used, but this is only because there are multiple definitions of the struct in different files. In such cases, the struct definition should be moved into a separate file. The instances below are the unused definitions.


```solidity
File: contracts/connectors/FraxConnector.sol


struct FraxPoolInfo {
    address collateralContract;
    address assetContract;
    bool isActive;
}

struct FraxBorrowRequest {
    address poolAddress;
    uint256 amount;
}

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L13:16

## NC053 - Unused `error` definition:

Note that there may be cases where an error superficially appears to be used, but this is only because there are multiple definitions of the error in different files. In such cases, the error definition should be moved into a separate file. The instances below are the unused definitions.


```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


    error InvalidPayload();

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L22:22

## NC054 - Events are missing sender information:

When an action is triggered based on a user's action, not being able to filter based on who triggered the action makes event processing a lot more cumbersome. Including the msg.sender the events of these types of action will make events much more useful to end users. Include `msg.sender` in the event output.


<details>
<summary>Click to show 21 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


154             emit TransferTokensToTrustedAddress(token, amount, _caller, _data);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


85              emit updateFlashloanAddress(_flashLoan, flashLoan);
142             emit VaultAdded(vaultId, _accountingManager, _baseToken, _trustedTokens);
143             emit VaultAddressesChanged(
144                 vaultId, _governer, _maintainer, _maintainerWithoutTimelock, _keeperContract, _watcher, _emergency
145             );
178             emit VaultAddressesChanged(
179                 vaultId, _governer, _maintainer, _maintainerWithoutTimelock, _keeperContract, _watcher, _emergency
180             );
196                 emit ConnectorAdded(vaultId, _connectorAddresses[i]);
217             emit ConnectorTrustedTokensUpdated(vaultId, _connectorAddress, _tokens, trusted);
262             emit TrustedPositionAdded(vaultId, positionId, calculatorConnector, _positionTypeId, onlyOwner, _isDebt, _data);
279             emit TrustedPositionRemoved(vaultId, _positionId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


53              emit Supply(supplyToken, amount);
75              emit Borrow(_borrowAsset, _amount);
85              emit Repay(asset, amount, i);
90              emit RepayWithCollateral(_borrowAsset, _amount, i);
111             emit WithdrawCollateral(_collateral, _collateralAmount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


42              emit MakeFlashLoan(tokens, amounts);
60              emit ReceiveFlashLoan(tokens, amounts, feeAmounts, userData);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


37              emit Supply(market, asset, amount);
59              emit WithdrawOrBorrow(_market, asset, amount);
67              emit ClaimRewards(rewardContract, market);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


60              emit BorrowAndSupply(address(pool), borrowAmount, collateralAmount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


44              emit Deposit(amountIn);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


71              emit Stake(amount, duration, doDelegation);
83              emit Unstake(lockupId);
107             emit AddLiquidityInMaverickPool(p);
130             emit RemoveLiquidityFromMaverickPool(p);
146             emit ClaimBoostedPositionRewards(rewardContract);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


49              emit Supply(amount, id, sOrC);
72              emit Withdraw(amount, id, sOrC);
87              emit Borrow(amount, id);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


33              emit SendPositionToMasterChef(tokenId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


89              emit Supply(market, syMinted);
101             emit MintPTAndYT(market, syAmount);
118             emit DepositIntoMarket(address(market), SYamount, PTamount);
156             emit SwapYTForPT(market, exactYTIn, min, guess);
195             emit SwapExactPTForSY(address(market), exactPTIn, swapData, minSY);
207             emit BurnLP(address(market), amount);
232             emit DecreasePosition(address(market), _amount, closePosition);
247             emit ClaimRewards(address(market));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


41              emit Deposit(siloToken, dToken, amount, oC);
68              emit Withdraw(siloToken, wToken, amount, oC, closePosition);
89              emit Borrow(siloToken, bToken, amount);
106             emit Repay(siloToken, rToken, amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


69              emit DepositIntoStargatePool(depositRequest);
96              emit WithdrawFromStargatePool(withdrawRequest);
106             emit ClaimStargateRewards(poolId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


56              emit OpenPosition(p, tokenId);
80              emit DecreasePosition(p);
95              emit IncreasePosition(p);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


50              emit MinimumHealthFactorUpdated(_minimumHealthFactor);
60              emit SwapHandlerUpdated(_swapHandler);
69              emit ValueOracleUpdated(_valueOracle);
88              emit TransferTokensToTrustedAddress(token, amount, caller, data);
128             emit TransferPositionToConnector(tokens, amounts, connector, data);
192             emit AddLiquidity(tokens, amounts, data);
217                 emit SwapHoldings(tokensIn[i], tokensOut[i], amountsIn[i], swapData[i]);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


49              emit UpdateChainInfo(chainId, destinationAddress);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


50              emit SetValueOracle(_valueOracle);
59              emit SetSlippageTolerance(address(0), address(0), _slippageTolerance);
73              emit SetSlippageTolerance(_inputToken, _outputToken, _slippageTolerance);
82              emit AddEligibleUser(_user);
117             emit ExecutionCompleted(
118                 _swapRequest.routeId, _swapRequest.amount, _amountOut, _swapRequest.inputToken, _swapRequest.outputToken
119             );
139             emit BridgeExecutionCompleted(_bridgeRequest);
160             emit RouteUpdate(_routeId, false);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


47              emit AddedHandler(_handler, state);
57              emit AddedChain(_chainId, state);
67              emit AddedBridgeBlacklist(bridgeName, state);
99              emit Swapped(balanceOut0, balanceOut1, _request.outputToken);
141             emit Bridged(_request.from, _request.inputToken, _request.amount, _request.data);
200             emit Rescued(token, userAddress, amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


58              emit UpdatedAssetPriceSource(asset, baseToken, oracle);
63              emit UpdatedPriceRoute(asset, base, s);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


61              emit ChainlinkPriceAgeThresholdUpdated(_chainlinkPriceAgeThreshold);
76                  emit AssetSourceUpdated(assets[i], baseTokens[i], sources[i]);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


41              emit NewPeriod(_period);
52              emit PoolsForAsset(tokenIn, baseToken, pool);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## NC055 - Enum values should be used in place of constant array indexes:

Create a commented enum value to use in place of constant array indexes, this makes the code far easier to understand.


<details>
<summary>Click to show 13 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


290                 amounts[0] = processedBaseTokenAmount;
292                 tokens[0] = address(baseToken);
652                 tokens[0] = abi.decode(data, (address));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


120             tokens[0] = IPool(pool).token0();
121             tokens[1] = IPool(pool).token1();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


102             tokens[0] = tokenA;
103             tokens[1] = tokenB;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


145             tokens[0] = IFraxPair(pool).collateralContract();
146             tokens[1] = IFraxPair(pool).asset();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


55              amounts[0] = amount;
59              registry.updateHoldingPosition(vaultId, positionId, abi.encode(requestIds[0]), abi.encode(amount), false);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


164             tokens[0] = IMaverickPool(pool).tokenA();
165             tokens[1] = IMaverickPool(pool).tokenB();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


145             tokens[0] = params.loanToken;
146             tokens[1] = params.collateralToken;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


315             (, tokens[0],) = SY.assetInfo();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


170             tokens[0] = collateral;
171             tokens[1] = debTtoken;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


127             tokens[0] = IStargatePool(lpAddress).token();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


154             (tokens[0], tokens[1]) = abi.decode(data, (address, address));
154             (tokens[0], tokens[1]) = abi.decode(data, (address, address));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


235                 tokens[0] = abi.decode(data, (address));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


70              secondsAgos[0] = period;
71              secondsAgos[1] = 0;
77              int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];
77              int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## NC056 - Zero as a function argument should have a descriptive meaning:

Consider using descriptive constants or an enum instead of passing zero directly on function calls, as that might be error-prone, to fully describe the caller's intention.


<details>
<summary>Click to show 22 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


215             depositQueue.queue[depositQueue.last] = DepositRequest(receiver, block.timestamp, 0, amount, 0);
289                 uint256[] memory amounts = new uint256[](1);
291                 address[] memory tokens = new address[](1);
313             withdrawQueue.queue[withdrawQueue.last] = WithdrawRequest(msg.sender, receiver, block.timestamp, 0, share, 0);
651                 address[] memory tokens = new address[](1);
655             return new address[](0);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


141             vault.holdingPositions.push(HoldingPI(address(0), address(0), bytes32(0), "", "", type(uint256).max));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


48              IPool(pool).supply(supplyToken, amount, address(this), 0);
70              IPool(pool).borrow(_borrowAsset, _amount, _interestRateMode, 0, address(this));
121             return new address[](0);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


118             address[] memory tokens = new address[](2);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


101             address[] memory tokens = new address[](2);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


135             return new address[](0);
142             return (assetsIn & (uint16(1) << assetOffset) != 0);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


39                  vaultId, registry.calculatePositionId(address(this), DOL_POSITION_ID, ""), abi.encode(0), "", false
50              (uint256[] memory markets,,,) = dolomiteMargin.getAccountBalances(Info(address(this), 0));
53                      vaultId, registry.calculatePositionId(address(this), DOL_POSITION_ID, ""), abi.encode(0), "", true
69              borrowPositionProxy.openBorrowPosition(
70                  0, accountId, marketId, _amountWei, AccountBalanceHelper.BalanceCheckFlag.None
71              );
88                  borrowPositionProxy.transferBetweenAccounts(
89                      accountId, 0, marketId, _amountWei, AccountBalanceHelper.BalanceCheckFlag.None
90                  );
92                  borrowPositionProxy.transferBetweenAccounts(
93                      0, accountId, marketId, _amountWei, AccountBalanceHelper.BalanceCheckFlag.None
94                  );
100             borrowPositionProxy.closeBorrowPosition(accountId, 0, marketIds);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


143             address[] memory tokens = new address[](2);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


25              address c = ICreditFacadeV3(facade).openCreditAccount(address(this), new MultiCall[](0), ref);
42              ICreditFacadeV3(facade).closeCreditAccount(creditAccount, new MultiCall[](0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


54              uint256[] memory amounts = new uint256[](1);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


98                  (tokenId,,,) = IMaverickRouter(maverickRouter).addLiquidityToPool{ value: sendEthAmount }(
99                      p.pool, 0, p.params, p.minTokenAAmount, p.minTokenBAmount, p.deadline
100                 );
163             address[] memory tokens = new address[](2);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


39                  morphoBlue.supply(params, amount, 0, address(this), "");
61                  morphoBlue.withdraw(params, amount, 0, address(this), address(this));
82              morphoBlue.borrow(market, amount, 0, address(this), address(this));
98              morphoBlue.repay(params, amount, 0, address(this), "");
144             address[] memory tokens = new address[](2);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


85              uint256 syMinted = _SY.deposit(address(this), _underlyingToken, amount, 1);
222             IPStandardizedYield(address(SY)).redeem(address(this), _amount, _underlyingToken, 1, true);
271                     SYAmount += lpBalance * IPMarket(market).getLpToAssetRate(10) / 1e18;
275                 if (PTAmount > 0) SYAmount += PTAmount * IPMarket(market).getPtToAssetRate(10) / 1e18;
314             address[] memory tokens = new address[](1);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


114             borrowerOps.adjustTrove(tm, address(this), mFee, 0, wAmount, bAmount, isBorrowing, address(this), address(this));
169             address[] memory tokens = new address[](2);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


129             return new address[](0);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


66                  revert IConnector_LowHealthFactor(0);
104                 revert IConnector_LowHealthFactor(0);
123                 uint256 price = _getValue(assets[i], base, 1e18);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


104             LPStaking.deposit(poolId, 0);
126             address[] memory tokens = new address[](1);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


153             address[] memory tokens = new address[](2);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


138             bytes32 positionId = registry.calculatePositionId(accountingManager, 0, abi.encode(token));
213                     SwapRequest(address(this), routeIds[i], amountsIn[i], tokensIn[i], tokensOut[i], swapData[i], true, 0)
234                 address[] memory tokens = new address[](1);
264             return new address[](0);
286             IERC20(_token).forceApprove(_spender, 0);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


76              return new address[](0);
82              bytes32 positionId = registry.calculatePositionId(accountingManager, 0, abi.encode(token));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


80              _lzSend(lzChainId, data, messageSetting, MessagingFee(address(this).balance, 0), payable(address(this))); // TODO: send event here


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


69              uint32[] memory secondsAgos = new uint32[](2);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## NC057 - Function names should differ to make the code more readable:

In Solidity, while function overriding allows for functions with the same name to coexist, it is advisable to avoid this practice to enhance code readability and maintainability. Having multiple functions with the same name, even with different parameters or in inherited contracts, can cause confusion and increase the likelihood of errors during development, testing, and debugging. Using distinct and descriptive function names not only clarifies the purpose and behavior of each function, but also helps prevent unintended function calls or incorrect overriding. By adopting a clear and consistent naming convention, developers can create more comprehensible and maintainable smart contracts.


<details>
<summary>Click to show 120 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


    function updateValueOracle(INoyaValueOracle _valueOracle) public onlyMaintainer {
        require(address(_valueOracle) != address(0));
        valueOracle = _valueOracle;
        emit ValueOracleUpdated(address(_valueOracle));
    }

    function sendTokensToTrustedAddress(address token, uint256 amount, address _caller, bytes calldata _data)
        external
        returns (uint256)
    {
        emit TransferTokensToTrustedAddress(token, amount, _caller, _data);
        if (registry.isAnActiveConnector(vaultId, msg.sender)) {
            IERC20(token).safeTransfer(address(msg.sender), amount);
            return amount;
        }
        return 0;
    }

    function deposit(address receiver, uint256 amount, address referrer) public nonReentrant whenNotPaused {
        if (amount == 0) {
            revert NoyaAccounting_INVALID_AMOUNT();
        }

        baseToken.safeTransferFrom(msg.sender, address(this), amount);

        if (amount > depositLimitPerTransaction) {
            revert NoyaAccounting_DepositLimitPerTransactionExceeded();
        }

        if (TVL() > depositLimitTotalAmount) {
            revert NoyaAccounting_TotalDepositLimitExceeded();
        }

        depositQueue.queue[depositQueue.last] = DepositRequest(receiver, block.timestamp, 0, amount, 0);
        emit RecordDeposit(depositQueue.last, receiver, block.timestamp, amount, referrer);
        depositQueue.last += 1;
        depositQueue.totalAWFDeposit += amount;
    }

    function deposit(uint256 assets, address receiver) public override returns (uint256) {
        revert NoyaAccounting_NOT_ALLOWED();
    }

    function withdraw(uint256 share, address receiver) public nonReentrant whenNotPaused {
        if (balanceOf(msg.sender) < share + withdrawRequestsByAddress[msg.sender]) {
            revert NoyaAccounting_INSUFFICIENT_FUNDS(
                balanceOf(msg.sender), share, withdrawRequestsByAddress[msg.sender]
            );
        }
        withdrawRequestsByAddress[msg.sender] += share;

        // adding the withdraw request to the withdraw queue
        withdrawQueue.queue[withdrawQueue.last] = WithdrawRequest(msg.sender, receiver, block.timestamp, 0, share, 0);
        emit RecordWithdraw(withdrawQueue.last, msg.sender, receiver, share, block.timestamp);
        withdrawQueue.last += 1;
    }

    function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256) {
        revert NoyaAccounting_NOT_ALLOWED();
    }

    function burnShares(uint256 amount) public {
        _burn(msg.sender, amount);
    }

    function getPositionTVL(HoldingPI memory position, address base) public view returns (uint256) {
        PositionBP memory p = registry.getPositionBP(vaultId, position.positionId);
        if (p.positionTypeId == 0) {
            address token = abi.decode(p.data, (address));
            uint256 amount = IERC20(token).balanceOf(abi.decode(position.data, (address)));
            return _getValue(token, base, amount);
        }
        return 0;
    }

    function _getValue(address token, address base, uint256 amount) internal view returns (uint256) {
        if (token == base) {
            return amount;
        }
        return valueOracle.getValue(token, base, amount);
    }

    function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {
        if (positionTypeId == 0) {
            address[] memory tokens = new address[](1);
            tokens[0] = abi.decode(data, (address));
            return tokens;
        }
        return new address[](0);
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L649:656

```solidity
File: contracts/helpers/BaseConnector.sol


    function updateValueOracle(address _valueOracle) external onlyMaintainer {
        valueOracle = INoyaValueOracle(_valueOracle);
        emit ValueOracleUpdated(_valueOracle);
    }

    function sendTokensToTrustedAddress(address token, uint256 amount, address caller, bytes memory data)
        external
        returns (uint256)
    {
        emit TransferTokensToTrustedAddress(token, amount, caller, data);
        (address accountingManager,) = registry.getVaultAddresses(vaultId);
        if (msg.sender == accountingManager) {
            (,,,, address watcherContract,) = registry.getGovernanceAddresses(vaultId);

            (uint256 newAmount, bytes memory newData) = abi.decode(data, (uint256, bytes));
            Watchers(watcherContract).verifyRemoveLiquidity(amount, newAmount, newData);

            IERC20(token).safeTransfer(address(accountingManager), newAmount);
            amount = newAmount;
        } else if (registry.isAnActiveConnector(vaultId, msg.sender) || msg.sender == registry.flashLoan()) {
            IERC20(token).safeTransfer(address(msg.sender), amount);
        } else {
            uint256 routeId = abi.decode(data, (uint256));
            swapHandler.verifyRoute(routeId, msg.sender);
            if (caller != address(this)) revert IConnector_InvalidAddress(caller);
            IERC20(token).safeTransfer(msg.sender, amount);
        }
        _updateTokenInRegistry(token);
        return amount;
    }

    function getPositionTVL(HoldingPI memory p, address baseToken) public view returns (uint256) {
        return _getPositionTVL(p, baseToken);
    }

    function _getValue(address token, address baseToken, uint256 amount) internal view returns (uint256) {
        if (token == baseToken) {
            return amount;
        }
        if (amount == 0) {
            return 0;
        }
        return valueOracle.getValue(token, baseToken, amount);
    }

    function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {
        if (positionTypeId == 0) {
            address[] memory tokens = new address[](1);
            tokens[0] = abi.decode(data, (address));
            return tokens;
        }
        return _getUnderlyingTokens(positionTypeId, data);
    }

    function _getPositionTVL(HoldingPI memory, address) public view virtual returns (uint256 tvl) {
        return 0;
    }

    function _getUnderlyingTokens(uint256, bytes memory) public view virtual returns (address[] memory) {
        return new address[](0);
    }

    function _updateTokenInRegistry(address token, bool remove) internal {
        (address accountingManager,) = registry.getVaultAddresses(vaultId);
        // the value function is inside the accounting manager contract (so we can use the accounting manager address as the calculator connector)
        bytes32 positionId = registry.calculatePositionId(accountingManager, 0, abi.encode(token));
        // if the token is not in the registry, we add it or remove it if the remove flag is true
        uint256 positionIndex =
            registry.getHoldingPositionIndex(vaultId, positionId, address(this), abi.encode(address(this)));
        if ((positionIndex == 0 && !remove) || (positionIndex > 0 && remove)) {
            emit UpdateTokenInRegistry(token, remove);
            registry.updateHoldingPosition(vaultId, positionId, abi.encode(address(this)), "", remove);
        }
    }

    function _updateTokenInRegistry(address token) internal {
        _updateTokenInRegistry(token, IERC20(token).balanceOf(address(this)) == 0);
    }

    function addLiquidity(address[] memory tokens, uint256[] memory amounts, bytes memory data)
        external
        override
        nonReentrant
    {
        if (!registry.isAddressTrusted(vaultId, msg.sender)) {
            revert IConnector_InvalidAddress(msg.sender);
        }

        for (uint256 i = 0; i < tokens.length; i++) {
            // gather all of the tokens
            uint256 _balance = IERC20(tokens[i]).balanceOf(address(this));
            ITokenTransferCallBack(msg.sender).sendTokensToTrustedAddress(tokens[i], amounts[i], msg.sender, "");
            uint256 _balanceAfter = IERC20(tokens[i]).balanceOf(address(this));
            if (_balanceAfter < amounts[i] + _balance) {
                revert IConnector_InsufficientDepositAmount(_balanceAfter - _balance, amounts[i]);
            }
        }
        _addLiquidity(tokens, amounts, data); // call the specific implementation if the connector needs to do something after the liquidity is added

        for (uint256 i = 0; i < tokens.length; i++) {
            _updateTokenInRegistry(tokens[i]); // update the token in the registry
        }
        emit AddLiquidity(tokens, amounts, data);
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L169:193

```solidity
File: contracts/helpers/ConnectorMock2.sol


    function sendTokensToTrustedAddress(address token, uint256 amount, address caller, bytes memory data)
        external
        returns (uint256)
    {
        if (data.length == 0) {
            IERC20(token).safeTransfer(msg.sender, amount);
            return amount;
        }
        (uint256 amountToSend, uint256 amountToReturn) = abi.decode(data, (uint256, uint256));
        IERC20(token).safeTransfer(msg.sender, amountToSend);
        return amountToReturn;
    }

    function getPositionTVL(HoldingPI memory p, address baseToken) public view returns (uint256) {
        return 0;
    }

    function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {
        return new address[](0);
    }

    function _updateTokenInRegistry(address token, bool remove) internal {
        (address accountingManager,) = registry.getVaultAddresses(vaultId);
        // the value function is inside the accounting manager contract (so we can use the accounting manager address as the calculator connector)
        bytes32 positionId = registry.calculatePositionId(accountingManager, 0, abi.encode(token));
        // if the token is not in the registry, we add it or remove it if the remove flag is true
        uint256 positionIndex =
            registry.getHoldingPositionIndex(vaultId, positionId, address(this), abi.encode(address(this)));
        if ((positionIndex == 0 && !remove) || (positionIndex > 0 && remove)) {
            registry.updateHoldingPosition(vaultId, positionId, abi.encode(address(this)), "", remove);
        }
    }

    function _updateTokenInRegistry(address token) internal {
        _updateTokenInRegistry(token, IERC20(token).balanceOf(address(this)) == 0);
    }

    function addLiquidity(address[] memory tokens, uint256[] memory amounts, bytes memory data) external {
        for (uint256 i = 0; i < tokens.length; i++) {
            // gather all of the tokens

            ITokenTransferCallBack(msg.sender).sendTokensToTrustedAddress(tokens[i], amounts[i], msg.sender, "");
        }
        for (uint256 i = 0; i < tokens.length; i++) {
            _updateTokenInRegistry(tokens[i]); // update the token in the registry
        }
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L40:49

```solidity
File: contracts/connectors/Dolomite.sol


    function deposit(uint256 marketId, uint256 _amount) public onlyManager nonReentrant {
        // get market token
        address token = dolomiteMargin.getMarketTokenAddress(marketId);
        // approve
        _approveOperations(token, address(dolomiteMargin), _amount);
        depositWithdrawalProxy.depositWeiIntoDefaultAccount(marketId, _amount);
        // Update token
        _updateTokenInRegistry(token);
        registry.updateHoldingPosition(
            vaultId, registry.calculatePositionId(address(this), DOL_POSITION_ID, ""), abi.encode(0), "", false
        );
    }

    function withdraw(uint256 marketId, uint256 _amount) public onlyManager nonReentrant {
        address token = dolomiteMargin.getMarketTokenAddress(marketId);
        depositWithdrawalProxy.withdrawWeiFromDefaultAccount(
            marketId, _amount, AccountBalanceHelper.BalanceCheckFlag.None
        );
        // Update token
        _updateTokenInRegistry(token);
        (uint256[] memory markets,,,) = dolomiteMargin.getAccountBalances(Info(address(this), 0));
        if (markets.length == 0) {
            registry.updateHoldingPosition(
                vaultId, registry.calculatePositionId(address(this), DOL_POSITION_ID, ""), abi.encode(0), "", true
            );
        }
    }

    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
        uint256 accountId = abi.decode(p.data, (uint256));

        (uint256[] memory markets, address[] memory tokens,, Types.Wei[] memory amounts) =
            dolomiteMargin.getAccountBalances(Info(address(this), accountId));
        uint256 totalDebt = 0;
        uint256 totalCollateral = 0;
        for (uint256 i = 0; i < markets.length; i++) {
            uint256 value = valueOracle.getValue(tokens[i], base, amounts[i].value);
            if (amounts[i].sign) {
                totalCollateral += value;
            } else {
                totalDebt += value;
            }
        }
        return totalCollateral - totalDebt;
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L106:122

```solidity
File: contracts/connectors/LidoConnector.sol


    function deposit(uint256 amountIn) external onlyManager nonReentrant {
        IWETH(weth).withdraw(amountIn);
        // deposit recieved eth into Lido
        // refferal address can be different
        ILido(lido).submit{ value: amountIn }(address(0));
        _updateTokenInRegistry(steth);
        _updateTokenInRegistry(weth);
        emit Deposit(amountIn);
    }

    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
        (uint256 amount) = abi.decode(p.additionalData, (uint256));
        return _getValue(steth, base, amount);
    }

    receive() external payable { }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L89:89

```solidity
File: contracts/connectors/SNXConnector.sol


    function deposit(address _token, uint256 _amount, uint128 _accountId) public onlyManager {
        // Deposit
        _approveOperations(_token, address(SNXCoreProxy), _amount);

        SNXCoreProxy.deposit(_accountId, _token, _amount);
        registry.updateHoldingPosition(
            vaultId,
            registry.calculatePositionId(address(this), SNX_POSITION_ID, ""),
            abi.encode(_accountId, _token),
            "",
            false
        );
        // Update token
        _updateTokenInRegistry(_token);
    }

    function withdraw(address _token, uint256 _amount, uint128 _accountId) public onlyManager {
        // Deposit
        _approveOperations(_token, address(SNXCoreProxy), _amount);
        SNXCoreProxy.withdraw(_accountId, _token, _amount);
        (uint256 c,,) = SNXCoreProxy.getAccountCollateral(_accountId, _token);
        if (c == 0) {
            registry.updateHoldingPosition(
                vaultId,
                registry.calculatePositionId(address(this), SNX_POSITION_ID, ""),
                abi.encode(_accountId, _token),
                "",
                true
            );
        }
        // Update token
        _updateTokenInRegistry(_token);
    }

    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
        (uint128 accountId, address collateralType) = abi.decode(p.data, (uint128, address));
        (uint256 totalDeposited, uint256 totalAssigned, uint256 totalLocked) =
            SNXCoreProxy.getAccountCollateral(accountId, collateralType);
        tvl = _getValue(collateralType, base, totalDeposited + totalAssigned);
    }

    function _getUnderlyingTokens(uint256, bytes memory) public pure override returns (address[] memory) {
        return new address[](0);
    }

    function claimRewards(uint128 accountId, uint128 poolId, address collateralType, address distributor)
        public
        onlyManager
    {
        SNXCoreProxy.claimRewards(accountId, poolId, collateralType, distributor);
        _updateTokenInRegistry(collateralType);
    }

    function onERC721Received(address, address, uint256, bytes memory) external pure override returns (bytes4) {
        return this.onERC721Received.selector;
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L64:66

```solidity
File: contracts/connectors/SiloConnector.sol


    function deposit(address siloToken, address dToken, uint256 amount, bool oC) external onlyManager nonReentrant {
        ISilo silo = ISilo(siloRepository.getSilo(siloToken));
        _approveOperations(dToken, address(silo), amount);
        silo.deposit(dToken, amount, oC);
        _updateTokenInRegistry(dToken);
        registry.updateHoldingPosition(
            vaultId, registry.calculatePositionId(address(this), SILO_LP_ID, abi.encode(siloToken)), "", "", false
        );
        emit Deposit(siloToken, dToken, amount, oC);
    }

    function withdraw(address siloToken, address wToken, uint256 amount, bool oC, bool closePosition)
        external
        onlyManager
        nonReentrant
    {
        ISilo silo = ISilo(siloRepository.getSilo(siloToken));
        silo.withdraw(wToken, amount, oC);
        _updateTokenInRegistry(wToken);
        if (closePosition && isSiloEmpty(silo)) {
            registry.updateHoldingPosition(
                vaultId, registry.calculatePositionId(address(this), SILO_LP_ID, abi.encode(siloToken)), "", "", true
            );
        }
        if (!SolvencyV2.isSolvent(silo, address(this), minimumHealthFactor)) {
            revert IConnector_LowHealthFactor(0);
        }
        emit Withdraw(siloToken, wToken, amount, oC, closePosition);
    }

    function borrow(address siloToken, address bToken, uint256 amount) external onlyManager nonReentrant {
        ISilo silo = ISilo(siloRepository.getSilo(siloToken));
        silo.borrow(bToken, amount);
        _updateTokenInRegistry(bToken);
        emit Borrow(siloToken, bToken, amount);
    }

    function repay(address siloToken, address rToken, uint256 amount) external onlyManager nonReentrant {
        ISilo silo = ISilo(siloRepository.getSilo(siloToken));
        _approveOperations(rToken, address(silo), amount);
        silo.repay(rToken, amount);
        _updateTokenInRegistry(rToken);
        if (!SolvencyV2.isSolvent(silo, address(this), minimumHealthFactor)) {
            revert IConnector_LowHealthFactor(0);
        }
        emit Repay(siloToken, rToken, amount);
    }

    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
        PositionBP memory bp = registry.getPositionBP(vaultId, p.positionId);
        (address siloToken) = abi.decode(bp.data, (address));
        ISilo silo = ISilo(siloRepository.getSilo(siloToken));
        (address[] memory assets, IBaseSilo.AssetStorage[] memory assetsS) = silo.getAssetsWithState();
        uint256 totalDepositAmount = 0;
        uint256 totalBAmount = 0;
        for (uint256 i = 0; i < assets.length; i++) {
            uint256 depositAmount = IERC20(assetsS[i].collateralToken).balanceOf(address(this));
            depositAmount += IERC20(assetsS[i].collateralOnlyToken).balanceOf(address(this));
            uint256 borrowAmount = IERC20(assetsS[i].debtToken).balanceOf(address(this));
            if (depositAmount == 0 && borrowAmount == 0) {
                continue;
            }
            uint256 price = _getValue(assets[i], base, 1e18);
            totalDepositAmount += depositAmount * price / 1e18;
            totalBAmount += borrowAmount * price / 1e18;
        }
        tvl = totalDepositAmount - totalBAmount;
    }

    function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {
        (address siloToken) = abi.decode(data, (address));
        ISilo silo = ISilo(siloRepository.getSilo(siloToken));
        (address[] memory assets,) = silo.getAssetsWithState();
        return assets;
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L143:148

```solidity
File: contracts/connectors/AerodromeConnector.sol


    function withdraw(WithdrawData memory data) public onlyManager nonReentrant {
        bytes32 positionId = registry.calculatePositionId(address(this), AERODROME_POSITION_TYPE, abi.encode(data.pool));
        _approveOperations(data.pool, address(aerodromeRouter), data.amountLiquidity);
        aerodromeRouter.removeLiquidity(
            IPool(data.pool).token0(),
            IPool(data.pool).token1(),
            IPool(data.pool).stable(),
            data.amountLiquidity,
            data.min0Min,
            data.min1Min,
            address(this),
            data.deadline
        );
        if (IERC20(data.pool).balanceOf(address(this)) == 0) {
            registry.updateHoldingPosition(vaultId, positionId, "", "", true);
        }
        _updateTokenInRegistry(IPool(data.pool).token0());
        _updateTokenInRegistry(IPool(data.pool).token1());
        emit Withdraw(data.pool, data.amountLiquidity);
    }

    function supply(DepositData memory data) public onlyManager nonReentrant {
        bytes32 positionId = registry.calculatePositionId(address(this), AERODROME_POSITION_TYPE, abi.encode(data.pool));
        _approveOperations(IPool(data.pool).token0(), address(aerodromeRouter), data.amount0);
        _approveOperations(IPool(data.pool).token1(), address(aerodromeRouter), data.amount1);
        aerodromeRouter.addLiquidity(
            IPool(data.pool).token0(),
            IPool(data.pool).token1(),
            IPool(data.pool).stable(),
            data.amount0,
            data.amount1,
            data.min0Min,
            data.min1Min,
            address(this),
            data.deadline
        );
        registry.updateHoldingPosition(vaultId, positionId, "", "", false);
        _updateTokenInRegistry(IPool(data.pool).token0());
        _updateTokenInRegistry(IPool(data.pool).token1());

        emit Supply(data.pool, data.amount0, data.amount1);
    }

    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {
        PositionBP memory pBP = registry.getPositionBP(vaultId, p.positionId);
        (address pool) = abi.decode(pBP.data, (address));
        uint256 balance = IERC20(pool).balanceOf(address(this));
        uint256 totalSupply = IERC20(pool).totalSupply();
        (uint256 reserve0, uint256 reserve1,) = IPool(pool).getReserves();
        uint256 amount0 = balance * reserve0 / totalSupply;
        uint256 amount1 = balance * reserve1 / totalSupply;
        return _getValue(IPool(pool).token0(), base, amount0) + _getValue(IPool(pool).token1(), base, amount1);
    }

    function _getUnderlyingTokens(uint256 p, bytes memory data) public view override returns (address[] memory) {
        address[] memory tokens = new address[](2);
        (address pool) = abi.decode(data, (address));
        tokens[0] = IPool(pool).token0();
        tokens[1] = IPool(pool).token1();
        return tokens;
    }

    function stake(address pool, uint256 liquidity) public onlyManager nonReentrant {
        address gauge = voter.gauges(pool);
        IERC20(pool).forceApprove(address(gauge), liquidity);
        IGauge(gauge).deposit(liquidity, address(this));
    }

    function unstake(address pool, uint256 liquidity) public onlyManager nonReentrant {
        address gauge = voter.gauges(pool);
        IGauge(gauge).withdraw(liquidity);
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L106:109

```solidity
File: contracts/connectors/FraxConnector.sol


    function withdraw(IFraxPair pool, uint256 withdrawAmount) public onlyManager nonReentrant {
        uint256 currentCollateral = pool.userCollateralBalance(address(this));
        if (withdrawAmount == currentCollateral) {
            bytes32 positionId =
                registry.calculatePositionId(address(this), COLLATERAL_AND_DEBT_POSITION_TYPE, abi.encode(pool));

            registry.updateHoldingPosition(vaultId, positionId, "", "", true);
        }
        pool.removeCollateral(withdrawAmount, address(this));
        _updateTokenInRegistry(pool.collateralContract());
        verifyHealthFactor(pool);
        emit Withdraw(address(pool), withdrawAmount);
    }

    function repay(IFraxPair pool, uint256 sharesToRepay) public onlyManager nonReentrant {
        uint256 repayTokenAmount = pool.toBorrowAmount(sharesToRepay, true);
        uint256 sharesOwed = pool.userBorrowShares(address(this));
        address asset = pool.asset();
        if (sharesToRepay > sharesOwed) {
            revert IConnector_InvalidInput();
        }
        _approveOperations(asset, address(pool), repayTokenAmount);
        IFraxPair(pool).repayAsset(sharesToRepay, address(this));
        _updateTokenInRegistry(asset);
        emit Repay(address(pool), sharesToRepay);
    }

    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
        PositionBP memory positionInfo = registry.getPositionBP(vaultId, p.positionId);
        IFraxPair pool = IFraxPair(abi.decode(positionInfo.data, (address)));
        uint256 collateralAmount = pool.userCollateralBalance(address(this));
        uint256 borrowerShares = pool.userBorrowShares(address(this));
        uint256 _borrowerAmount = pool.toBorrowAmount(borrowerShares, true);

        uint256 borrowValue = _getValue(pool.asset(), base, _borrowerAmount);
        uint256 collateralValue = _getValue(pool.collateralContract(), base, collateralAmount);
        if (collateralValue > borrowValue) {
            return collateralValue - borrowValue;
        }
        return tvl;
    }

    function _getUnderlyingTokens(uint256 p, bytes memory data) public view override returns (address[] memory) {
        address[] memory tokens = new address[](2);
        (address pool) = abi.decode(data, (address));
        tokens[0] = IFraxPair(pool).collateralContract();
        tokens[1] = IFraxPair(pool).asset();
        return tokens;
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L142:148

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


    function withdraw(uint256 amount, Id id, bool sOrC) external onlyManager nonReentrant {
        MarketParams memory params = morphoBlue.idToMarketParams(id);
        if (sOrC) {
            morphoBlue.withdraw(params, amount, 0, address(this), address(this));
        } else {
            morphoBlue.withdrawCollateral(params, amount, address(this), address(this));
        }
        Position memory p = morphoBlue.position(id, address(this));
        if (p.collateral == 0 && p.supplyShares == 0) {
            registry.updateHoldingPosition(
                vaultId, registry.calculatePositionId(address(this), MORPHO_POSITION_ID, abi.encode(id)), "", "", true
            );
        }
        _updateTokenInRegistry(params.collateralToken);
        emit Withdraw(amount, id, sOrC);
    }

    function supply(uint256 amount, Id id, bool sOrC) external onlyManager nonReentrant {
        MarketParams memory params = morphoBlue.idToMarketParams(id);
        if (sOrC) {
            _approveOperations(params.loanToken, address(morphoBlue), amount);
            morphoBlue.supply(params, amount, 0, address(this), "");
            _updateTokenInRegistry(params.loanToken);
        } else {
            _approveOperations(params.collateralToken, address(morphoBlue), amount);
            morphoBlue.supplyCollateral(params, amount, address(this), "");
            _updateTokenInRegistry(params.collateralToken);
        }
        registry.updateHoldingPosition(
            vaultId, registry.calculatePositionId(address(this), MORPHO_POSITION_ID, abi.encode(id)), "", "", false
        );
        emit Supply(amount, id, sOrC);
    }

    function borrow(uint256 amount, Id id) external onlyManager nonReentrant {
        MarketParams memory market = morphoBlue.idToMarketParams(id);
        morphoBlue.borrow(market, amount, 0, address(this), address(this));
        if (getHealthFactor(id, morphoBlue.market(id)) < minimumHealthFactor) {
            revert IConnector_LowHealthFactor(getHealthFactor(id, morphoBlue.market(id)));
        }
        _updateTokenInRegistry(market.loanToken);
        emit Borrow(amount, id);
    }

    function repay(uint256 amount, Id id) public onlyManager nonReentrant {
        MarketParams memory params = morphoBlue.idToMarketParams(id);
        _approveOperations(params.loanToken, address(morphoBlue), amount);
        morphoBlue.repay(params, amount, 0, address(this), "");
        _updateTokenInRegistry(params.loanToken);
        emit Repay(amount, id);
    }

    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
        PositionBP memory positionInfo = registry.getPositionBP(vaultId, p.positionId);
        if (positionInfo.positionTypeId == MORPHO_POSITION_ID) {
            Id id = abi.decode(positionInfo.data, (Id));
            MarketParams memory params = morphoBlue.idToMarketParams(id);
            Market memory market = morphoBlue.market(id);
            Position memory pos = morphoBlue.position(id, address(this));
            uint256 borrowAmount =
                uint256(pos.borrowShares).toAssetsUp(market.totalBorrowAssets, market.totalBorrowShares);
            uint256 supplyAmount =
                uint256(pos.supplyShares).toAssetsUp(market.totalSupplyAssets, market.totalSupplyShares);
            tvl = _getValue(
                params.loanToken,
                base,
                supplyAmount + borrowAmount + convertCToL(pos.collateral, params.oracle, params.collateralToken)
            );
        }
    }

    function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {
        Id id = abi.decode(data, (Id));
        MarketParams memory params = morphoBlue.idToMarketParams(id);
        address[] memory tokens = new address[](2);
        tokens[0] = params.loanToken;
        tokens[1] = params.collateralToken;
        return tokens;
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L141:148

```solidity
File: contracts/connectors/PancakeswapConnector.sol


    function withdraw(uint256 tokenId) public onlyManager nonReentrant {
        masterchef.withdraw(tokenId, address(this));
        _updateTokenInRegistry(masterchef.CAKE());
        emit Withdraw(tokenId);
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L50:54

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


    function burnShares(uint256 amount) external onlyOwner {
        AccountingManager(accountingManager).burnShares(amount);
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L27:29

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


    function _getValue(address asset, address baseToken, uint256 amount, address[] memory sources)
        internal
        view
        returns (uint256 value)
    {
        uint256 initialValue = amount;
        address quotingToken = asset;
        for (uint256 i = 0; i < sources.length; i++) {
            initialValue = _getValue(asset, sources[i], initialValue);
            quotingToken = sources[i];
        }
        return _getValue(quotingToken, baseToken, initialValue);
    }

    function _getValue(address quotingToken, address baseToken, uint256 amount) internal view returns (uint256) {
        INoyaValueOracle oracle = priceSource[quotingToken][baseToken];
        if (address(oracle) == address(0)) {
            oracle = priceSource[baseToken][quotingToken];
        }
        if (address(oracle) == address(0)) {
            oracle = defaultPriceSource[baseToken];
        }
        if (address(oracle) == address(0)) {
            oracle = defaultPriceSource[quotingToken];
        }
        if (address(oracle) == address(0)) {
            revert NoyaOracle_PriceOracleUnavailable(quotingToken, baseToken);
        }
        return oracle.getValue(quotingToken, baseToken, amount);
    }

    function getValue(address asset, address baseToken, uint256 amount) public view returns (uint256) {
        if (asset == baseToken || amount == 0) {
            return amount;
        }

        address[] memory sources = priceRoutes[asset][baseToken];

        return _getValue(asset, baseToken, amount, sources);
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L71:79

```solidity
File: contracts/accountingManager/Registry.sol


    function updateHoldingPosition(
        Vault storage vault,
        uint256 vaultId,
        bytes32 _positionId,
        bytes calldata d,
        bytes calldata AD,
        uint256 index,
        bytes32 holdingPositionId
    ) internal returns (uint256) {
        emit HoldingPositionUpdated(vaultId, _positionId, d, AD, false, index);

        if (index == 0) {
            if (!isPositionTrustedForConnector(vaultId, _positionId, msg.sender)) {
                revert InvalidPosition(_positionId);
            }
            if (vault.holdingPositions.length >= maxNumHoldingPositions) {
                revert TooManyPositions();
            }
            vault.isPositionUsed[holdingPositionId] = vault.holdingPositions.length;
            vault.holdingPositions.push(
                HoldingPI(
                    vaults[vaultId].trustedPositionsBP[_positionId].calculatorConnector,
                    msg.sender,
                    _positionId,
                    d,
                    AD,
                    type(uint256).max
                )
            );
            return vault.holdingPositions.length - 1;
        }
        vault.holdingPositions[index].additionalData = AD;
        return index;
    }

    function updateHoldingPosition(
        uint256 vaultId,
        bytes32 _positionId,
        bytes calldata _data,
        bytes calldata additionalData,
        bool removePosition
    ) public vaultExists(vaultId) returns (uint256) {
        Vault storage vault = vaults[vaultId];
        if (!vault.connectors[msg.sender].enabled) revert UnauthorizedAccess();
        if (!vault.trustedPositionsBP[_positionId].isEnabled) revert InvalidPosition(_positionId);
        bytes32 holdingPositionId = keccak256(abi.encode(msg.sender, _positionId, _data));
        uint256 positionIndex = vault.isPositionUsed[holdingPositionId];
        if (positionIndex == 0 && removePosition) return type(uint256).max;
        if (removePosition) {
            if (positionIndex < vault.holdingPositions.length - 1) {
                vault.holdingPositions[positionIndex] = vault.holdingPositions[vault.holdingPositions.length - 1];
                vault.isPositionUsed[keccak256(
                    abi.encode(
                        vault.holdingPositions[positionIndex].calculatorConnector,
                        vault.holdingPositions[positionIndex].positionId,
                        vault.holdingPositions[positionIndex].data
                    )
                )] = positionIndex;
            }
            vault.holdingPositions.pop();
            vault.isPositionUsed[holdingPositionId] = 0;
            emit HoldingPositionUpdated(vaultId, _positionId, _data, additionalData, removePosition, positionIndex);
            return type(uint256).max;
        }
        return
            updateHoldingPosition(vault, vaultId, _positionId, _data, additionalData, positionIndex, holdingPositionId);
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L335:366

```solidity
File: contracts/connectors/AaveConnector.sol


    function supply(address supplyToken, uint256 amount) external onlyManager nonReentrant {
        _approveOperations(supplyToken, pool, amount);
        IPool(pool).supply(supplyToken, amount, address(this), 0);
        registry.updateHoldingPosition(
            vaultId, registry.calculatePositionId(address(this), AAVE_POSITION_ID, ""), "", "", false
        );
        _updateTokenInRegistry(supplyToken);
        emit Supply(supplyToken, amount);
    }

    function borrow(uint256 _amount, uint256 _interestRateMode, address _borrowAsset)
        external
        onlyManager
        nonReentrant
    {
        if (!registry.isTokenTrusted(vaultId, _borrowAsset, address(this))) {
            revert IConnector_UntrustedToken(_borrowAsset);
        }
        IPool(pool).borrow(_borrowAsset, _amount, _interestRateMode, 0, address(this));
        // get the health factor
        (,,,,, uint256 healthFactor) = IPool(pool).getUserAccountData(address(this));
        if (healthFactor < minimumHealthFactor) revert IConnector_LowHealthFactor(healthFactor);
        _updateTokenInRegistry(_borrowAsset);
        emit Borrow(_borrowAsset, _amount);
    }

    function repay(address asset, uint256 amount, uint256 i) external onlyManager nonReentrant {
        _approveOperations(asset, pool, amount);
        IPool(pool).repay(asset, amount, i, address(this));
        _updateTokenInRegistry(asset);
        emit Repay(asset, amount, i);
    }

    function _getPositionTVL(HoldingPI memory, address base) public view override returns (uint256 tvl) {
        (uint256 totalCollateralBase, uint256 totalDebtBase,,,,) = IPool(pool).getUserAccountData(address(this));
        uint256 poolBaseAmount = totalCollateralBase - totalDebtBase;
        return valueOracle.getValue(poolBaseToken, base, poolBaseAmount);
    }

    function _getUnderlyingTokens(uint256, bytes memory) public pure override returns (address[] memory) {
        return new address[](0);
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L120:122

```solidity
File: contracts/connectors/CompoundConnector.sol


    function supply(address market, address asset, uint256 amount) external onlyManager nonReentrant {
        _approveOperations(asset, market, amount);
        if (!registry.isTokenTrusted(vaultId, asset, address(this))) revert IConnector_UntrustedToken(asset);
        IComet(market).supply(asset, amount);
        registry.updateHoldingPosition(
            vaultId, registry.calculatePositionId(address(this), COMPOUND_LP, abi.encode(market)), "", "", false
        );
        _updateTokenInRegistry(asset);
        emit Supply(market, asset, amount);
    }

    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {
        address market = abi.decode(registry.getPositionBP(vaultId, p.positionId).data, (address));

        uint256 positiveBalance = getCollBlanace(IComet(market), false);
        uint256 negativeBalance = getBorrowBalanceInBase(IComet(market));
        uint256 balance = positiveBalance - negativeBalance;
        return (valueOracle.getValue(IComet(market).baseToken(), base, balance));
    }

    function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {
        return new address[](0);
    }

    function claimRewards(address rewardContract, address market) external onlyManager nonReentrant {
        address rewardToken = IRewards(rewardContract).rewardConfig(market).token;
        IRewards(rewardContract).claim(address(market), address(this), true);
        _updateTokenInRegistry(rewardToken);
        emit ClaimRewards(rewardContract, market);
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L63:68

```solidity
File: contracts/connectors/PendleConnector.sol


    function supply(address market, uint256 amount) external onlyManager nonReentrant {
        (IPStandardizedYield _SY, IPPrincipalToken _PT,) = IPMarket(market).readTokens();

        (, address _underlyingToken,) = _SY.assetInfo();

        _approveOperations(_underlyingToken, address(_SY), amount);
        // Mint SY from underlying token
        uint256 syMinted = _SY.deposit(address(this), _underlyingToken, amount, 1);

        bytes32 positionId = registry.calculatePositionId(address(this), PENDLE_POSITION_ID, abi.encode(market));
        registry.updateHoldingPosition(vaultId, positionId, "", "", false);
        emit Supply(market, syMinted);
    }

    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
        PositionBP memory positionInfo = registry.getPositionBP(vaultId, p.positionId);
        if (positionInfo.positionTypeId == PENDLE_POSITION_ID) {
            uint256 underlyingBalance = 0;
            address market = abi.decode(positionInfo.data, (address));
            (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
            (, address _underlyingToken,) = _SY.assetInfo();

            uint256 SYAmount = _SY.balanceOf(address(this));

            //
            uint256 lpBalance =
                IERC20(market).balanceOf(address(this)) + pendleMarketDepositHelper.balance(market, address(this));
            if (lpBalance > 0) {
                SYAmount += lpBalance * IPMarket(market).getLpToAssetRate(10) / 1e18;
            }

            uint256 PTAmount = _PT.balanceOf(address(this));
            if (PTAmount > 0) SYAmount += PTAmount * IPMarket(market).getPtToAssetRate(10) / 1e18;

            uint256 YTBalance = _YT.balanceOf(address(this));
            if (YTBalance > 0) SYAmount += getYTValue(market, YTBalance);

            if (SYAmount > 0) underlyingBalance += SYAmount * _SY.exchangeRate() / 1e18;

            tvl = valueOracle.getValue(_underlyingToken, base, underlyingBalance);
        }
        return tvl;
    }

    function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {
        address market = abi.decode(data, (address));
        (IPStandardizedYield SY,,) = IPMarket(market).readTokens();
        address[] memory tokens = new address[](1);
        (, tokens[0],) = SY.assetInfo();
        return tokens;
    }

    function decreasePosition(IPMarket market, uint256 _amount, bool closePosition) external onlyManager nonReentrant {
        (IPStandardizedYield SY,,) = market.readTokens();
        (, address _underlyingToken,) = SY.assetInfo();

        // redeems an amount of base tokens by burning SY
        IERC20(address(SY)).safeTransfer(address(SY), _amount);
        IPStandardizedYield(address(SY)).redeem(address(this), _amount, _underlyingToken, 1, true);
        if (closePosition && isMarketEmpty(market)) {
            registry.updateHoldingPosition(
                vaultId,
                registry.calculatePositionId(address(this), PENDLE_POSITION_ID, abi.encode(market)),
                "",
                "",
                true
            );
        }
        emit DecreasePosition(address(market), _amount, closePosition);
    }

    function claimRewards(IPMarket market) external onlyManager nonReentrant {
        market.redeemRewards(address(this));
        address[] memory rewardTokens = market.getRewardTokens();
        for (uint256 i = 0; i < rewardTokens.length; i++) {
            _updateTokenInRegistry(rewardTokens[i]);
        }
        emit ClaimRewards(address(market));
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L241:248

```solidity
File: contracts/connectors/BalancerConnector.sol


    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {
        PositionBP memory PTI = registry.getPositionBP(vaultId, p.positionId);
        PoolInfo memory pool = abi.decode(PTI.additionalData, (PoolInfo));
        uint256 lpBalance = totalLpBalanceOf(pool);
        (, uint256[] memory _tokenBalances,) = IBalancerVault(balancerVault).getPoolTokens(pool.poolId);
        uint256 _totalSupply = IERC20(pool.pool).totalSupply();

        uint256 _weight = pool.weights[pool.tokenIndex];

        uint256 token1bal = valueOracle.getValue(pool.tokens[pool.tokenIndex], base, _tokenBalances[pool.tokenIndex]);
        return (((1e18 * token1bal * lpBalance) / _weight) / _totalSupply);
    }

    function openPosition(
        bytes32 poolId,
        uint256[] memory amounts,
        uint256[] memory amountsWithoutBPT,
        uint256 minBPT,
        uint256 auraAmount
    ) public onlyManager nonReentrant {
        address[] memory tokens;
        {
            (tokens,,) = IBalancerVault(balancerVault).getPoolTokens(poolId);
        }
        address pool = IBalancerVault(balancerVault).getPool(poolId);

        for (uint256 i = 0; i < tokens.length; i++) {
            if (amounts[i] > 0) _approveOperations(tokens[i], balancerVault, amounts[i]);
        }

        IBalancerVault(balancerVault).joinPool(
            poolId,
            address(this), // sender
            address(this), // recipient
            IBalancerVault.JoinPoolRequest(
                tokens,
                amounts,
                abi.encode(
                    IBalancerVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,
                    amountsWithoutBPT, //_noBptAmounts,
                    minBPT // minimumBPT
                ),
                false
            )
        );
        bytes32 positionId = registry.calculatePositionId(address(this), BALANCER_LP_POSITION, abi.encode(poolId));
        registry.updateHoldingPosition(vaultId, positionId, "", "", false);

        if (auraAmount > 0) {
            (PoolInfo memory _poolInfo,) = _getPoolInfo(poolId);

            uint256 amount = IERC20(pool).balanceOf(address(this));
            _approveOperations(pool, _poolInfo.auraPoolAddress, amount);
            IRewardPool(_poolInfo.auraPoolAddress).deposit(auraAmount, address(this));
        }
        emit OpenPosition(poolId, amounts, amountsWithoutBPT, minBPT, auraAmount);
    }

    function decreasePosition(DecreasePositionParams memory p) public onlyManager nonReentrant {
        if (p._auraAmount > 0) {
            (PoolInfo memory _poolInfo, bytes32 positionId) = _getPoolInfo(p.poolId);

            IRewardPool(_poolInfo.auraPoolAddress).withdrawAndUnwrap(p._auraAmount, true);
        }

        if (p._lpAmount > 0) {
            address[] memory tokens;
            {
                (tokens,,) = IBalancerVault(balancerVault).getPoolTokens(p.poolId);
            }
            uint256[] memory _amounts = new uint256[](tokens.length);
            _amounts[p.outerIndex] = p.minAmount;

            IBalancerVault(balancerVault).exitPool(
                p.poolId,
                address(this), // sender
                payable(address(this)), // recipient
                IBalancerVault.ExitPoolRequest(
                    tokens,
                    _amounts,
                    abi.encode(
                        IBalancerVault.ExitKind.EXACT_BPT_IN_FOR_ONE_TOKEN_OUT,
                        p._lpAmount,
                        p.withdrawIndex // enterTokenIndex
                    ),
                    false
                )
            );

            if (totalLpBalanceOf(p.poolId) == 0) {
                registry.updateHoldingPosition(
                    vaultId,
                    registry.calculatePositionId(address(this), BALANCER_LP_POSITION, abi.encode(p.poolId)),
                    "",
                    "",
                    true
                );
            }
            _updateTokenInRegistry(tokens[p.outerIndex]);
        }
        _updateTokenInRegistry(AURA);
        _updateTokenInRegistry(BAL);
        emit DecreasePosition(p);
    }

    function totalLpBalanceOf(PoolInfo memory pool) public view returns (uint256) {
        uint256 auraShares;
        if (pool.auraPoolAddress != address(0)) {
            auraShares = IERC20(pool.auraPoolAddress).balanceOf(address(this));
            auraShares = IRewardPool(pool.auraPoolAddress).convertToAssets(auraShares);
        }
        return IERC20(pool.pool).balanceOf(address(this)) + auraShares;
    }

    function totalLpBalanceOf(bytes32 poolId) public view returns (uint256) {
        (PoolInfo memory pool,) = _getPoolInfo(poolId);
        return totalLpBalanceOf(pool);
    }

    function _getPoolInfo(bytes32 pooId) internal view returns (PoolInfo memory, bytes32) {
        bytes32 positionId = registry.calculatePositionId(address(this), BALANCER_LP_POSITION, abi.encode(pooId));
        PositionBP memory p = registry.getPositionBP(vaultId, positionId);
        return (abi.decode(p.additionalData, (PoolInfo)), positionId);
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L189:193

```solidity
File: contracts/connectors/CamelotConnector.sol


    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
        (address tokenA, address tokenB) =
            abi.decode(registry.getPositionBP(vaultId, p.positionId).data, (address, address));
        address pool = factory.getPair(tokenA, tokenB);
        uint256 totalSupply = IERC20(pool).totalSupply();
        (uint256 reserves0, uint256 reserves1,,) = ICamelotPair(pool).getReserves();

        uint256 balanceThis = IERC20(pool).balanceOf(address(this));
        return balanceThis * (_getValue(tokenA, base, reserves0) + _getValue(tokenB, base, reserves1)) / totalSupply;
    }

    function _getUnderlyingTokens(uint256 id, bytes memory data) public view override returns (address[] memory) {
        (address tokenA, address tokenB) = abi.decode(data, (address, address));
        address[] memory tokens = new address[](2);
        tokens[0] = tokenA;
        tokens[1] = tokenB;
        return tokens;
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L99:105

```solidity
File: contracts/connectors/CurveConnector.sol


    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
        PositionBP memory PTI = registry.getPositionBP(vaultId, p.positionId);
        PoolInfo memory poolInfo = abi.decode(PTI.additionalData, (PoolInfo));
        uint256 lpBalance = totalLpBalanceOf(poolInfo);
        (uint256 amount, address token) = LPToUnder(poolInfo, lpBalance);
        return _getValue(token, base, amount);
    }

    function totalLpBalanceOf(PoolInfo memory info) public view returns (uint256) {
        uint256 lpBalance = balanceOfLPToken(info);
        uint256 rewardBalance = balanceOfRewardPool(info);
        uint256 convexRewardBalance = balanceOfConvexRewardPool(info);
        uint256 prismaBalance = balanceOfPrisma(info.prismaCurvePool);
        uint256 prismaConvexBalance = balanceOfPrisma(info.prismaConvexPool);
        return lpBalance + rewardBalance + convexRewardBalance + prismaBalance + prismaConvexBalance;
    }

    function _getPoolInfo(address pool) internal view returns (PoolInfo memory) {
        bytes32 positionId = registry.calculatePositionId(address(this), CURVE_LP_POSITION, abi.encode(pool));
        PositionBP memory p = registry.getPositionBP(vaultId, positionId);
        return abi.decode(p.additionalData, (PoolInfo));
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L258:262

```solidity
File: contracts/connectors/GearBoxV3.sol


    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
        address creditAccount = abi.decode(p.data, (address));
        PositionBP memory positionInfo = registry.getPositionBP(vaultId, p.positionId);
        ICreditFacadeV3 facade = ICreditFacadeV3(abi.decode(positionInfo.data, (address)));
        CollateralDebtData memory d = ICreditManagerV3(facade.creditManager()).calcDebtAndCollateral(
            creditAccount, CollateralCalcTask.DEBT_COLLATERAL_SAFE_PRICES
        );
        if (d.totalDebtUSD > d.totalValueUSD) {
            return 0;
        }
        return _getValue(address(840), base, (d.totalValueUSD - d.totalDebtUSD));
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L93:104

```solidity
File: contracts/connectors/MaverickConnector.sol


    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
        PositionBP memory position = registry.getPositionBP(vaultId, p.positionId);
        IMaverickPool pool = abi.decode(position.data, (IMaverickPool));

        (uint256 a, uint256 b) = positionInspector.addressBinReservesAllKindsAllTokenIds(address(this), pool);
        return _getValue(pool.tokenA(), base, a) + _getValue(pool.tokenB(), base, b);
    }

    function _getUnderlyingTokens(uint256 id, bytes memory data) public view override returns (address[] memory) {
        (address pool) = abi.decode(data, (address));
        address[] memory tokens = new address[](2);
        tokens[0] = IMaverickPool(pool).tokenA();
        tokens[1] = IMaverickPool(pool).tokenB();
        return tokens;
    }

    function stake(uint256 amount, uint256 duration, bool doDelegation) external onlyManager nonReentrant {
        // approve veMav to spend mav
        _approveOperations(mav, veMav, amount);
        // stake mav
        IveMAV(veMav).stake(amount, duration, doDelegation);
        _updateTokenInRegistry(mav);
        _updateTokenInRegistry(veMav);
        emit Stake(amount, duration, doDelegation);
    }

    function unstake(uint256 lockupId) external onlyManager nonReentrant {
        // unstake veMav
        IveMAV(veMav).unstake(lockupId);
        _updateTokenInRegistry(mav);
        _updateTokenInRegistry(veMav);
        emit Unstake(lockupId);
    }

    receive() external payable { }

    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {
        return this.onERC721Received.selector;
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L149:151

```solidity
File: contracts/connectors/PrismaConnector.sol


    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
        PositionBP memory positionInfo = registry.getPositionBP(vaultId, p.positionId);
        if (positionInfo.positionTypeId == PRISMA_POSITION_ID) {
            (address zap, address troveManager) = abi.decode(positionInfo.data, (address, address));
            IBorrowerOperations borrowerOperations = IStakeNTroveZap(zap).borrowerOps();
            address collateral = borrowerOperations.troveManagersData(troveManager).collateralToken;
            address debTtoken = ITroveManager(troveManager).debtToken();
            (uint256 collateralBalance, uint256 debtBalance) =
                ITroveManager(troveManager).getTroveCollAndDebt(address(this));
            return _getValue(collateral, base, collateralBalance) - _getValue(debTtoken, base, debtBalance);
        }
    }

    function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {
        (address zap, address troveManager) = abi.decode(data, (address, address));
        IBorrowerOperations borrowerOperations = IStakeNTroveZap(zap).borrowerOps();
        address collateral = borrowerOperations.troveManagersData(troveManager).collateralToken;
        address debTtoken = ITroveManager(troveManager).debtToken();
        address[] memory tokens = new address[](2);
        tokens[0] = collateral;
        tokens[1] = debTtoken;
        return tokens;
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L164:173

```solidity
File: contracts/connectors/StargateConnector.sol


    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
        PositionBP memory pBP = registry.getPositionBP(vaultId, p.positionId);
        uint256 poolId = abi.decode(pBP.data, (uint256));
        address lpAddress = LPStaking.poolInfo(poolId).lpToken;
        uint256 lpAmount = LPStaking.userInfo(poolId, address(this)).amount + IERC20(lpAddress).balanceOf(address(this));
        if (lpAmount == 0) {
            return 0;
        }
        address underlyingToken = IStargatePool(lpAddress).token();
        uint256 underlyingAmount = IStargatePool(lpAddress).amountLPtoLD(lpAmount);
        return _getValue(underlyingToken, base, underlyingAmount);
    }

    function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {
        uint256 poolId = abi.decode(data, (uint256));
        address lpAddress = LPStaking.poolInfo(poolId).lpToken;
        address[] memory tokens = new address[](1);
        tokens[0] = IStargatePool(lpAddress).token();
        return tokens;
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L123:129

```solidity
File: contracts/connectors/UNIv3Connector.sol


    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
        PositionBP memory positionInfo = registry.getPositionBP(vaultId, p.positionId);
        uint256 tokenId = abi.decode(p.data, (uint256));
        (address token0, address token1) = abi.decode(positionInfo.data, (address, address));
        uint256 amount0;
        uint256 amount1;
        (int24 tL, int24 tU, uint24 fee) = abi.decode(p.additionalData, (int24, int24, uint24));
        {
            IUniswapV3Pool pool = IUniswapV3Pool(factory.getPool(token0, token1, fee));
            bytes32 key = keccak256(abi.encodePacked(positionManager, tL, tU));

            (uint128 liquidity,,, uint128 tokensOwed0, uint128 tokensOwed1) = pool.positions(key);

            (uint160 sqrtPriceX96,,,,,,) = pool.slot0();
            (amount0, amount1) = LiquidityAmounts.getAmountsForLiquidity(
                sqrtPriceX96, TickMath.getSqrtRatioAtTick(tL), TickMath.getSqrtRatioAtTick(tU), liquidity
            );
            amount0 += tokensOwed0;
            amount1 += tokensOwed1;
        }

        tvl += valueOracle.getValue(token0, base, amount0);
        tvl += valueOracle.getValue(token1, base, amount1);
    }

    function _getUnderlyingTokens(uint256, bytes memory data) public pure override returns (address[] memory) {
        address[] memory tokens = new address[](2);
        (tokens[0], tokens[1]) = abi.decode(data, (address, address));
        return tokens;
    }

    function openPosition(MintParams memory p) external onlyManager nonReentrant returns (uint256 tokenId) {
        bytes32 positionId =
            registry.calculatePositionId(address(this), UNI_LP_POSITION_TYPE, abi.encode(p.token0, p.token1));
        p.recipient = address(this);
        // Approve NonfungiblePositionManager to spend `token0` and `token1`.
        _approveOperations(p.token0, address(positionManager), p.amount0Desired);
        _approveOperations(p.token1, address(positionManager), p.amount1Desired);

        // Supply liquidity to pool.
        (tokenId,,,) = positionManager.mint(p);
        bytes memory positionData = abi.encode(tokenId);
        registry.updateHoldingPosition(
            vaultId, positionId, positionData, abi.encode(p.tickLower, p.tickUpper, p.fee), false
        );
        _updateTokenInRegistry(p.token0);
        _updateTokenInRegistry(p.token1);
        emit OpenPosition(p, tokenId);
    }

    function decreasePosition(DecreaseLiquidityParams memory p) external onlyManager nonReentrant {
        (uint128 currentLiquidity, address token0, address token1) = getCurrentLiquidity(p.tokenId);
        if (p.liquidity > currentLiquidity) {
            revert IConnector_InvalidAmount();
        }
        positionManager.decreaseLiquidity(p);
        _collectFees(p.tokenId);
        _updateTokenInRegistry(token0);
        _updateTokenInRegistry(token1);

        if (currentLiquidity == p.liquidity) {
            positionManager.burn(p.tokenId);
            bytes32 positionId =
                registry.calculatePositionId(address(this), UNI_LP_POSITION_TYPE, abi.encode(token0, token1));
            bytes memory positionData = abi.encode(p.tokenId);
            registry.updateHoldingPosition(vaultId, positionId, positionData, "", true);
        }
        emit DecreasePosition(p);
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L63:81

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


    function _getPositionTVL(HoldingPI memory position, address) public view override returns (uint256) {
        uint256 positionTypeId = registry.getPositionBP(vaultId, position.positionId).positionTypeId;
        if (positionTypeId == OMNICHAIN_POSITION_ID) {
            return (abi.decode(position.additionalData, (uint256)));
        }
        return 0;
    }

    function updateTVL(uint256 chainId, uint256 tvl, uint256 updateTime) external nonReentrant {
        if (msg.sender != lzHelper) revert IConnector_InvalidSender();

        registry.updateHoldingPostionWithTime(
            vaultId,
            registry.calculatePositionId(address(this), OMNICHAIN_POSITION_ID, abi.encode(chainId)),
            "",
            abi.encode(tvl),
            tvl <= DUST_LEVEL,
            updateTime
        );
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L32:43

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol


    function _getPositionTVL(HoldingPI memory position, address base) public view override returns (uint256) {
        PositionBP memory bp = registry.getPositionBP(vaultId, position.positionId);
        if (bp.positionTypeId == 0) {
            address token = abi.decode(bp.data, (address));
            uint256 amount = IERC20(token).balanceOf(address(this));
            return _getValue(token, base, amount);
        }
        return 0;
    }

    function getTVL() public view returns (uint256) {
        (, address baseToken) = registry.getVaultAddresses(vaultId);
        return TVLHelper.getTVL(vaultId, registry, baseToken);
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol#L19:22

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


    receive() external payable { }

    function setChainInfo(uint256 chainId, uint32 lzChainId, address lzHelperAddress) public onlyOwner {
        require(lzHelperAddress != address(0));
        chainInfo[chainId] = ChainInfo(lzChainId, lzHelperAddress);
    }

    function addVaultInfo(uint256 vaultId, uint256 baseChainId, address omniChainManager) public onlyOwner {
        vaultIdToVaultInfo[vaultId] = VaultInfo(baseChainId, omniChainManager);
    }

    function updateTVL(uint256 vaultId, uint256 tvl, uint256 updateTime) public {
        if (msg.sender != vaultIdToVaultInfo[vaultId].omniChainManager) revert InvalidSender();

        uint32 lzChainId = chainInfo[vaultIdToVaultInfo[vaultId].baseChainId].lzChainId;
        bytes memory data = abi.encode(vaultId, tvl, updateTime);
        _lzSend(lzChainId, data, messageSetting, MessagingFee(address(this).balance, 0), payable(address(this))); // TODO: send event here
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L75:81

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


    function setChainInfo(uint256 chainId, uint32 lzChainId, address lzHelperAddress) public onlyOwner {
        require(lzHelperAddress != address(0));
        chainInfo[lzChainId] = ChainInfo(chainId, lzHelperAddress);
    }

    function addVaultInfo(uint256 vaultId, uint256 baseChainId, address omniChainManager) public onlyOwner {
        require(omniChainManager != address(0));
        vaultIdToVaultInfo[vaultId] = VaultInfo(baseChainId, omniChainManager);
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L52:55

```solidity
File: contracts/helpers/TVLHelper.sol


    function getTVL(uint256 vaultId, PositionRegistry registry, address baseToken) public view returns (uint256) {
        uint256 totalTVL;
        uint256 totalDebt;
        HoldingPI[] memory positions = registry.getHoldingPositions(vaultId);
        for (uint256 i = 0; i < positions.length; i++) {
            if (positions[i].calculatorConnector == address(0)) {
                continue;
            }
            uint256 tvl = IConnector(positions[i].calculatorConnector).getPositionTVL(positions[i], baseToken);
            bool isPositionDebt = registry.isPositionDebt(vaultId, positions[i].positionId);
            if (isPositionDebt) {
                totalDebt += tvl;
            } else {
                totalTVL += tvl;
            }
        }
        if (totalTVL < totalDebt) {
            return 0;
        }
        return (totalTVL - totalDebt);
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/TVLHelper.sol#L14:34

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


    function getValue(address asset, address baseToken, uint256 amount) public view returns (uint256) {
        if (asset == baseToken) {
            return amount;
        }

        (address primarySource, bool isPrimaryInverse) = getSourceOfAsset(asset, baseToken);
        if (primarySource == address(0)) {
            revert NoyaChainlinkOracle_PRICE_ORACLE_UNAVAILABLE(asset, baseToken, primarySource);
        }
        address decimalsSource = isPrimaryInverse ? baseToken : asset;
        decimalsSource = decimalsSource == ETH || decimalsSource == USD ? primarySource : decimalsSource;
        return getValueFromChainlinkFeed(
            AggregatorV3Interface(primarySource), amount, getTokenDecimals(decimalsSource), isPrimaryInverse
        );
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L89:103

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


    function getValue(address tokenIn, address baseToken, uint256 amount) public view returns (uint256 _amountOut) {
        uint128 amountIn128 = uint128(amount);
        address pool = assetToBaseToPool[tokenIn][baseToken];
        if (pool == address(0)) {
            pool = assetToBaseToPool[baseToken][tokenIn];
        }
        if (pool == address(0)) revert INoyaOracle_ValueOracleUnavailable(tokenIn, baseToken);

        // Code copied from OracleLibrary.sol, consult()
        uint32[] memory secondsAgos = new uint32[](2);
        secondsAgos[0] = period;
        secondsAgos[1] = 0;

        // Get the tick cumulatives from the pool for the periods
        (int56[] memory tickCumulatives,) = IUniswapV3Pool(pool).observe(secondsAgos);

        // Calculate the delta of the tick cumulatives
        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];

        // Calculate the time-weighted average tick
        // int56 / uint32 = int24
        int24 timeWeightedAverageTick = int24(tickCumulativesDelta / int56(int32(period)));
        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % int56(int32(period)) != 0)) {
            timeWeightedAverageTick--;
        }
        _amountOut = OracleLibrary.getQuoteAtTick(timeWeightedAverageTick, amountIn128, tokenIn, baseToken);
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L60:86

</details>

## NC058 - It is standard for all external and public functions to be override from an interface:

This is to ensure the whole API is extracted in an interface


<details>
<summary>Click to show 37 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


124         function updateValueOracle(INoyaValueOracle _valueOracle) public onlyMaintainer {
125             require(address(_valueOracle) != address(0));
126             valueOracle = _valueOracle;
127             emit ValueOracleUpdated(address(_valueOracle));
128         }
135         function setFeeReceivers(
136             address _withdrawFeeReceiver,
137             address _performanceFeeReceiver,
138             address _managementFeeReceiver
139         ) public onlyMaintainer {
140             require(_withdrawFeeReceiver != address(0));
141             require(_performanceFeeReceiver != address(0));
142             require(_managementFeeReceiver != address(0));
143             withdrawFeeReceiver = _withdrawFeeReceiver;
144             performanceFeeReceiver = _performanceFeeReceiver;
145             managementFeeReceiver = _managementFeeReceiver;
146             emit FeeRecepientsChanged(_withdrawFeeReceiver, _performanceFeeReceiver, _managementFeeReceiver);
147         }
150         function sendTokensToTrustedAddress(address token, uint256 amount, address _caller, bytes calldata _data)
151             external
152             returns (uint256)
153         {
154             emit TransferTokensToTrustedAddress(token, amount, _caller, _data);
155             if (registry.isAnActiveConnector(vaultId, msg.sender)) {
156                 IERC20(token).safeTransfer(address(msg.sender), amount);
157                 return amount;
158             }
159             return 0;
160         }
170         function setFees(uint256 _withdrawFee, uint256 _performanceFee, uint256 _managementFee) public onlyMaintainer {
171             if (
172                 _withdrawFee > WITHDRAWAL_MAX_FEE || _performanceFee > PERFORMANCE_MAX_FEE
173                     || _managementFee > MANAGEMENT_MAX_FEE
174             ) {
175                 revert NoyaAccounting_INVALID_FEE();
176             }
177             withdrawFee = _withdrawFee;
178             performanceFee = _performanceFee;
179             managementFee = _managementFee;
180             emit FeeRatesChanged(_withdrawFee, _performanceFee, _managementFee);
181         }
200         function deposit(address receiver, uint256 amount, address referrer) public nonReentrant whenNotPaused {
201             if (amount == 0) {
202                 revert NoyaAccounting_INVALID_AMOUNT();
203             }
204     
205             baseToken.safeTransferFrom(msg.sender, address(this), amount);
206     
207             if (amount > depositLimitPerTransaction) {
208                 revert NoyaAccounting_DepositLimitPerTransactionExceeded();
209             }
210     
211             if (TVL() > depositLimitTotalAmount) {
212                 revert NoyaAccounting_TotalDepositLimitExceeded();
213             }
214     
215             depositQueue.queue[depositQueue.last] = DepositRequest(receiver, block.timestamp, 0, amount, 0);
216             emit RecordDeposit(depositQueue.last, receiver, block.timestamp, amount, referrer);
217             depositQueue.last += 1;
218             depositQueue.totalAWFDeposit += amount;
219         }
226         function calculateDepositShares(uint256 maxIterations) public onlyManager nonReentrant whenNotPaused {
227             uint256 middleTemp = depositQueue.middle;
228             uint64 i = 0;
229     
230             uint256 oldestUpdateTime = TVLHelper.getLatestUpdateTime(vaultId, registry);
231     
232             while (
233                 depositQueue.last > middleTemp && depositQueue.queue[middleTemp].recordTime <= oldestUpdateTime
234                     && i < maxIterations
235             ) {
236                 i += 1;
237                 DepositRequest storage data = depositQueue.queue[middleTemp];
238     
239                 uint256 shares = previewDeposit(data.amount);
240                 data.shares = shares;
241                 data.calculationTime = block.timestamp;
242                 emit CalculateDeposit(
243                     middleTemp, data.receiver, block.timestamp, shares, data.amount, shares * 1e18 / data.amount
244                 );
245     
246                 middleTemp += 1;
247             }
248     
249             depositQueue.middle = middleTemp;
250         }
257         function executeDeposit(uint256 maxI, address connector, bytes memory addLPdata)
258             public
259             onlyManager
260             whenNotPaused
261             nonReentrant
262         {
263             uint256 firstTemp = depositQueue.first;
264             uint64 i = 0;
265             uint256 processedBaseTokenAmount = 0;
266     
267             while (
268                 depositQueue.middle > firstTemp
269                     && depositQueue.queue[firstTemp].calculationTime + depositWaitingTime <= block.timestamp && i < maxI
270             ) {
271                 i += 1;
272                 DepositRequest memory data = depositQueue.queue[firstTemp];
273     
274                 emit ExecuteDeposit(
275                     firstTemp, data.receiver, block.timestamp, data.shares, data.amount, data.shares * 1e18 / data.amount
276                 );
277                 // minting shares for receiver address
278                 _mint(data.receiver, data.shares);
279     
280                 processedBaseTokenAmount += data.amount;
281                 delete depositQueue.queue[firstTemp];
282                 firstTemp += 1;
283             }
284             depositQueue.totalAWFDeposit -= processedBaseTokenAmount;
285     
286             totalDepositedAmount += processedBaseTokenAmount;
287     
288             if (registry.isAnActiveConnector(vaultId, connector) && processedBaseTokenAmount > 0) {
289                 uint256[] memory amounts = new uint256[](1);
290                 amounts[0] = processedBaseTokenAmount;
291                 address[] memory tokens = new address[](1);
292                 tokens[0] = address(baseToken);
293                 IConnector(connector).addLiquidity(tokens, amounts, addLPdata);
294             } else {
295                 revert NoyaAccounting_INVALID_CONNECTOR();
296             }
297     
298             depositQueue.first = firstTemp;
299         }
304         function withdraw(uint256 share, address receiver) public nonReentrant whenNotPaused {
305             if (balanceOf(msg.sender) < share + withdrawRequestsByAddress[msg.sender]) {
306                 revert NoyaAccounting_INSUFFICIENT_FUNDS(
307                     balanceOf(msg.sender), share, withdrawRequestsByAddress[msg.sender]
308                 );
309             }
310             withdrawRequestsByAddress[msg.sender] += share;
311     
312             // adding the withdraw request to the withdraw queue
313             withdrawQueue.queue[withdrawQueue.last] = WithdrawRequest(msg.sender, receiver, block.timestamp, 0, share, 0);
314             emit RecordWithdraw(withdrawQueue.last, msg.sender, receiver, share, block.timestamp);
315             withdrawQueue.last += 1;
316         }
328         function calculateWithdrawShares(uint256 maxIterations) public onlyManager nonReentrant whenNotPaused {
329             uint256 middleTemp = withdrawQueue.middle;
330             uint64 i = 0;
331             uint256 processedShares = 0;
332             uint256 assetsNeededForWithdraw = 0;
333             uint256 oldestUpdateTime = TVLHelper.getLatestUpdateTime(vaultId, registry);
334     
335             if (currentWithdrawGroup.isFullfilled == false && currentWithdrawGroup.isStarted == true) {
336                 revert NoyaAccounting_ThereIsAnActiveWithdrawGroup();
337             }
338             while (
339                 withdrawQueue.last > middleTemp && withdrawQueue.queue[middleTemp].recordTime <= oldestUpdateTime
340                     && i < maxIterations
341             ) {
342                 i += 1;
343                 WithdrawRequest storage data = withdrawQueue.queue[middleTemp];
344                 uint256 assets = previewRedeem(data.shares);
345                 data.amount = assets;
346                 data.calculationTime = block.timestamp;
347                 assetsNeededForWithdraw += assets;
348                 processedShares += data.shares;
349                 emit CalculateWithdraw(middleTemp, data.owner, data.receiver, data.shares, assets, block.timestamp);
350     
351                 middleTemp += 1;
352             }
353             currentWithdrawGroup.totalCBAmount += assetsNeededForWithdraw;
354             withdrawQueue.middle = middleTemp;
355         }
360         function startCurrentWithdrawGroup() public onlyManager nonReentrant whenNotPaused {
361             require(currentWithdrawGroup.isStarted == false && currentWithdrawGroup.isFullfilled == false);
362             currentWithdrawGroup.isStarted = true;
363             currentWithdrawGroup.lastId = withdrawQueue.middle;
364             emit WithdrawGroupStarted(currentWithdrawGroup.lastId, currentWithdrawGroup.totalCBAmount);
365         }
370         function fulfillCurrentWithdrawGroup() public onlyManager nonReentrant whenNotPaused {
371             require(currentWithdrawGroup.isStarted == true && currentWithdrawGroup.isFullfilled == false);
372             uint256 neededAssets = neededAssetsForWithdraw();
373     
374             if (neededAssets != 0 && amountAskedForWithdraw != currentWithdrawGroup.totalCBAmount) {
375                 revert NoyaAccounting_NOT_READY_TO_FULFILL();
376             }
377             currentWithdrawGroup.isFullfilled = true;
378             amountAskedForWithdraw = 0;
379             uint256 availableAssets = baseToken.balanceOf(address(this)) - depositQueue.totalAWFDeposit;
380             if (availableAssets >= currentWithdrawGroup.totalCBAmount) {
381                 currentWithdrawGroup.totalABAmount = currentWithdrawGroup.totalCBAmount;
382             } else {
383                 currentWithdrawGroup.totalABAmount = availableAssets;
384             }
385             currentWithdrawGroup.totalCBAmountFullfilled = currentWithdrawGroup.totalCBAmount;
386             currentWithdrawGroup.totalCBAmount = 0;
387             emit WithdrawGroupFulfilled(
388                 currentWithdrawGroup.lastId, currentWithdrawGroup.totalCBAmount, currentWithdrawGroup.totalABAmount
389             );
390         }
396         function executeWithdraw(uint256 maxIterations) public onlyManager nonReentrant whenNotPaused {
397             if (currentWithdrawGroup.isFullfilled == false) {
398                 revert NoyaAccounting_ThereIsAnActiveWithdrawGroup();
399             }
400             uint64 i = 0;
401             uint256 firstTemp = withdrawQueue.first;
402     
403             uint256 withdrawFeeAmount = 0;
404             uint256 processedBaseTokenAmount = 0;
405             // loop through the withdraw queue and execute the withdraws
406             while (
407                 currentWithdrawGroup.lastId > firstTemp
408                     && withdrawQueue.queue[firstTemp].calculationTime + withdrawWaitingTime <= block.timestamp
409                     && i < maxIterations
410             ) {
411                 i += 1;
412                 WithdrawRequest memory data = withdrawQueue.queue[firstTemp];
413                 uint256 shares = data.shares;
414                 // calculate the base token amount that the user will receive based on the total available amount
415                 uint256 baseTokenAmount =
416                     data.amount * currentWithdrawGroup.totalABAmount / currentWithdrawGroup.totalCBAmountFullfilled;
417     
418                 withdrawRequestsByAddress[data.owner] -= shares;
419                 _burn(data.owner, shares);
420     
421                 processedBaseTokenAmount += data.amount;
422                 {
423                     uint256 feeAmount = baseTokenAmount * withdrawFee / FEE_PRECISION;
424                     withdrawFeeAmount += feeAmount;
425                     baseTokenAmount = baseTokenAmount - feeAmount;
426                 }
427     
428                 baseToken.safeTransfer(data.receiver, baseTokenAmount);
429                 emit ExecuteWithdraw(
430                     firstTemp, data.owner, data.receiver, shares, data.amount, baseTokenAmount, block.timestamp
431                 );
432                 delete withdrawQueue.queue[firstTemp];
433                 // increment the first index of the withdraw queue
434                 firstTemp += 1;
435             }
436             totalWithdrawnAmount += processedBaseTokenAmount;
437     
438             if (withdrawFeeAmount > 0) {
439                 baseToken.safeTransfer(withdrawFeeReceiver, withdrawFeeAmount);
440             }
441             withdrawQueue.first = firstTemp;
442             // if the withdraw group is fullfilled and there are no withdraws that are waiting for execution, we delete the withdraw group
443             if (currentWithdrawGroup.lastId == firstTemp) {
444                 delete currentWithdrawGroup;
445             }
446         }
453         function resetMiddle(uint256 newMiddle, bool depositOrWithdraw) public onlyManager {
454             if (depositOrWithdraw) {
455                 emit ResetMiddle(newMiddle, depositQueue.middle, depositOrWithdraw);
456     
457                 if (newMiddle > depositQueue.middle || newMiddle < depositQueue.first) {
458                     revert NoyaAccounting_INVALID_AMOUNT();
459                 }
460                 depositQueue.middle = newMiddle;
461             } else {
462                 emit ResetMiddle(newMiddle, withdrawQueue.middle, depositOrWithdraw);
463     
464                 if (newMiddle > withdrawQueue.middle || newMiddle < withdrawQueue.first || currentWithdrawGroup.isStarted) {
465                     revert NoyaAccounting_INVALID_AMOUNT();
466                 }
467                 withdrawQueue.middle = newMiddle;
468             }
469         }
475         function recordProfitForFee() public onlyManager nonReentrant {
476             storedProfitForFee = getProfit();
477             profitStoredTime = block.timestamp;
478     
479             if (storedProfitForFee < totalProfitCalculated) {
480                 return;
481             }
482     
483             preformanceFeeSharesWaitingForDistribution =
484                 previewDeposit(((storedProfitForFee - totalProfitCalculated) * performanceFee) / FEE_PRECISION);
485             emit RecordProfit(
486                 storedProfitForFee, totalProfitCalculated, preformanceFeeSharesWaitingForDistribution, block.timestamp
487             );
488         }
493         function checkIfTVLHasDroped() public nonReentrant {
494             uint256 currentProfit = getProfit();
495             if (currentProfit < storedProfitForFee) {
496                 emit ResetFee(currentProfit, storedProfitForFee, block.timestamp);
497                 preformanceFeeSharesWaitingForDistribution = 0;
498                 profitStoredTime = 0;
499             }
500         }
505         function collectManagementFees() public onlyManager nonReentrant returns (uint256, uint256) {
506             if (block.timestamp - lastFeeDistributionTime < 1 days) {
507                 return (0, 0);
508             }
509             uint256 timePassed = block.timestamp - lastFeeDistributionTime;
510             if (timePassed > 10 days) {
511                 timePassed = 10 days;
512             }
513             uint256 totalShares = totalSupply();
514             uint256 currentFeeShares = balanceOf(managementFeeReceiver) + balanceOf(performanceFeeReceiver)
515                 + preformanceFeeSharesWaitingForDistribution;
516     
517             uint256 managementFeeAmount =
518                 (timePassed * managementFee * (totalShares - currentFeeShares)) / FEE_PRECISION / 365 days;
519             _mint(managementFeeReceiver, managementFeeAmount);
520             emit CollectManagementFee(managementFeeAmount, timePassed, totalShares, currentFeeShares);
521             lastFeeDistributionTime = block.timestamp;
522             return (managementFeeAmount, timePassed);
523         }
526         function collectPerformanceFees() public onlyManager nonReentrant {
527             if (
528                 preformanceFeeSharesWaitingForDistribution == 0 || block.timestamp - profitStoredTime < 12 hours
529                     || block.timestamp - profitStoredTime > 48 hours
530             ) {
531                 return;
532             }
533     
534             _mint(performanceFeeReceiver, preformanceFeeSharesWaitingForDistribution);
535     
536             totalProfitCalculated = storedProfitForFee;
537     
538             emit CollectPerformanceFee(preformanceFeeSharesWaitingForDistribution);
539     
540             preformanceFeeSharesWaitingForDistribution = 0;
541         }
543         function burnShares(uint256 amount) public {
544             _burn(msg.sender, amount);
545         }
548         function retrieveTokensForWithdraw(RetrieveData[] calldata retrieveData) public onlyManager nonReentrant {
549             uint256 amountAskedForWithdraw_temp = 0;
550             uint256 neededAssets = neededAssetsForWithdraw();
551             for (uint256 i = 0; i < retrieveData.length; i++) {
552                 if (!registry.isAnActiveConnector(vaultId, retrieveData[i].connectorAddress)) {
553                     continue;
554                 }
555                 uint256 balanceBefore = baseToken.balanceOf(address(this));
556                 uint256 amount = IConnector(retrieveData[i].connectorAddress).sendTokensToTrustedAddress(
557                     address(baseToken), retrieveData[i].withdrawAmount, address(this), retrieveData[i].data
558                 );
559                 uint256 balanceAfter = baseToken.balanceOf(address(this));
560                 if (balanceBefore + amount > balanceAfter) revert NoyaAccounting_banalceAfterIsNotEnough();
561                 amountAskedForWithdraw_temp += retrieveData[i].withdrawAmount;
562                 emit RetrieveTokensForWithdraw(
563                     retrieveData[i].withdrawAmount,
564                     retrieveData[i].connectorAddress,
565                     amount,
566                     amountAskedForWithdraw + amountAskedForWithdraw_temp
567                 );
568             }
569             amountAskedForWithdraw += amountAskedForWithdraw_temp;
570             if (amountAskedForWithdraw_temp > neededAssets) {
571                 revert NoyaAccounting_INVALID_AMOUNT();
572             }
573         }
582         function getProfit() public view returns (uint256) {
583             uint256 tvl = TVL();
584             if (tvl + totalWithdrawnAmount > totalDepositedAmount) {
585                 return tvl + totalWithdrawnAmount - totalDepositedAmount;
586             }
587             return 0;
588         }
591         function totalAssets() public view override returns (uint256) {
592             return TVL();
593         }
596         function getQueueItems(bool depositOrWithdraw, uint256[] memory items)
597             public
598             view
599             returns (DepositRequest[] memory depositData, WithdrawRequest[] memory withdrawData)
600         {
601             if (depositOrWithdraw) {
602                 depositData = new DepositRequest[](items.length);
603                 for (uint256 i = 0; i < items.length; i++) {
604                     depositData[i] = depositQueue.queue[items[i]];
605                 }
606             } else {
607                 withdrawData = new WithdrawRequest[](items.length);
608                 for (uint256 i = 0; i < items.length; i++) {
609                     withdrawData[i] = withdrawQueue.queue[items[i]];
610                 }
611             }
612             return (depositData, withdrawData);
613         }
616         function neededAssetsForWithdraw() public view returns (uint256) {
617             uint256 availableAssets = baseToken.balanceOf(address(this)) - depositQueue.totalAWFDeposit;
618             if ( // check if the withdraw group is fullfilled
619                 currentWithdrawGroup.isStarted == false || currentWithdrawGroup.isFullfilled == true
620                     || availableAssets >= currentWithdrawGroup.totalCBAmount
621             ) {
622                 return 0;
623             }
624             return currentWithdrawGroup.totalCBAmount - availableAssets;
625         }
627         function TVL() public view returns (uint256) {
628             return TVLHelper.getTVL(vaultId, registry, address(baseToken)) + baseToken.balanceOf(address(this))
629                 - depositQueue.totalAWFDeposit;
630         }
632         function getPositionTVL(HoldingPI memory position, address base) public view returns (uint256) {
633             PositionBP memory p = registry.getPositionBP(vaultId, position.positionId);
634             if (p.positionTypeId == 0) {
635                 address token = abi.decode(p.data, (address));
636                 uint256 amount = IERC20(token).balanceOf(abi.decode(position.data, (address)));
637                 return _getValue(token, base, amount);
638             }
639             return 0;
640         }
649         function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {
650             if (positionTypeId == 0) {
651                 address[] memory tokens = new address[](1);
652                 tokens[0] = abi.decode(data, (address));
653                 return tokens;
654             }
655             return new address[](0);
656         }
659         function emergencyStop() public whenNotPaused onlyEmergency {
660             _pause();
661         }
663         function unpause() public whenPaused onlyEmergency {
664             _unpause();
665         }
667         function setDepositLimits(uint256 _depositLimitPerTransaction, uint256 _depositTotalAmount) public onlyMaintainer {
668             depositLimitPerTransaction = _depositLimitPerTransaction;
669             depositLimitTotalAmount = _depositTotalAmount;
670             emit SetDepositLimits(_depositLimitPerTransaction, _depositTotalAmount);
671         }
673         function changeDepositWaitingTime(uint256 _depositWaitingTime) public onlyMaintainer {
674             depositWaitingTime = _depositWaitingTime;
675             emit SetDepositWaitingTime(_depositWaitingTime);
676         }
678         function changeWithdrawWaitingTime(uint256 _withdrawWaitingTime) public onlyMaintainer {
679             withdrawWaitingTime = _withdrawWaitingTime;
680             emit SetWithdrawWaitingTime(_withdrawWaitingTime);
681         }
683         function rescue(address token, uint256 amount) public onlyEmergency nonReentrant {
684             if (token == address(0)) {
685                 (bool success,) = payable(msg.sender).call{ value: amount }("");
686                 require(success, "Transfer failed.");
687             } else {
688                 IERC20(token).safeTransfer(msg.sender, amount);
689             }
690             emit Rescue(msg.sender, token, amount);
691         }
693         function mint(uint256 shares, address receiver) public override returns (uint256) {
694             revert NoyaAccounting_NOT_ALLOWED();
695         }
697         function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256) {
698             revert NoyaAccounting_NOT_ALLOWED();
699         }
701         function redeem(uint256 shares, address receiver, address shareOwner) public override returns (uint256) {
702             revert NoyaAccounting_NOT_ALLOWED();
703         }
705         function deposit(uint256 assets, address receiver) public override returns (uint256) {
706             revert NoyaAccounting_NOT_ALLOWED();
707         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


23          function withdrawShares(uint256 amount) external onlyOwner {
24              AccountingManager(accountingManager).withdraw(amount, receiver);
25          }
27          function burnShares(uint256 amount) external onlyOwner {
28              AccountingManager(accountingManager).burnShares(amount);
29          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


79          function setMaxNumHoldingPositions(uint256 _maxNumHoldingPositions) external onlyRole(MAINTAINER_ROLE) {
80              require(_maxNumHoldingPositions <= MAX_NUM_HOLDING_POSITIONS);
81              maxNumHoldingPositions = _maxNumHoldingPositions;
82          }
84          function setFlashLoanAddress(address _flashLoan) external onlyRole(MAINTAINER_ROLE) {
85              emit updateFlashloanAddress(_flashLoan, flashLoan);
86              flashLoan = _flashLoan;
87          }
106         function addVault(
107             uint256 vaultId,
108             address _accountingManager,
109             address _baseToken,
110             address _governer,
111             address _maintainer,
112             address _maintainerWithoutTimelock,
113             address _keeperContract,
114             address _watcher,
115             address _emergency,
116             address[] calldata _trustedTokens
117         ) external onlyRole(MAINTAINER_ROLE) {
118             if (vaults[vaultId].accountManager != address(0)) revert AlreadyExists();
119             Vault storage vault = vaults[vaultId];
120             require(_governer != address(0));
121             require(_accountingManager != address(0));
122             require(_baseToken != address(0));
123             require(_maintainer != address(0));
124             require(_keeperContract != address(0));
125             require(_watcher != address(0));
126     
127             vault.accountManager = _accountingManager;
128             vault.baseToken = _baseToken;
129             vault.governer = _governer;
130             vault.maintainer = _maintainer;
131             vault.maintainerWithoutTimeLock = _maintainerWithoutTimelock;
132             vault.keeperContract = _keeperContract;
133             vault.watcherContract = _watcher;
134             vault.emergency = _emergency;
135             // Enable the accounting manager connector so the vault can use the "getValue" function of the accounting manager for calculating the value of tokens
136             vault.connectors[vault.accountManager].enabled = true;
137             vault.enabled = true;
138             for (uint256 i = 0; i < _trustedTokens.length; i++) {
139                 vault.connectors[vault.accountManager].trustedTokens[_trustedTokens[i]] = true;
140             }
141             vault.holdingPositions.push(HoldingPI(address(0), address(0), bytes32(0), "", "", type(uint256).max));
142             emit VaultAdded(vaultId, _accountingManager, _baseToken, _trustedTokens);
143             emit VaultAddressesChanged(
144                 vaultId, _governer, _maintainer, _maintainerWithoutTimelock, _keeperContract, _watcher, _emergency
145             );
146         }
158         function changeVaultAddresses(
159             uint256 vaultId,
160             address _governer,
161             address _maintainer,
162             address _maintainerWithoutTimelock,
163             address _keeperContract,
164             address _watcher,
165             address _emergency
166         ) external onlyVaultGoverner(vaultId) vaultExists(vaultId) {
167             require(_governer != address(0));
168             require(_maintainer != address(0));
169             require(_keeperContract != address(0));
170             require(_watcher != address(0));
171     
172             vaults[vaultId].governer = _governer;
173             vaults[vaultId].maintainer = _maintainer;
174             vaults[vaultId].maintainerWithoutTimeLock = _maintainerWithoutTimelock;
175             vaults[vaultId].keeperContract = _keeperContract;
176             vaults[vaultId].watcherContract = _watcher;
177             vaults[vaultId].emergency = _emergency;
178             emit VaultAddressesChanged(
179                 vaultId, _governer, _maintainer, _maintainerWithoutTimelock, _keeperContract, _watcher, _emergency
180             );
181         }
188         function addConnector(uint256 vaultId, address[] calldata _connectorAddresses, bool[] calldata _enableds)
189             external
190             onlyVaultMaintainer(vaultId)
191             vaultExists(vaultId)
192         {
193             Vault storage vault = vaults[vaultId];
194             for (uint256 i = 0; i < _connectorAddresses.length; i++) {
195                 vault.connectors[_connectorAddresses[i]].enabled = _enableds[i];
196                 emit ConnectorAdded(vaultId, _connectorAddresses[i]);
197             }
198         }
207         function updateConnectorTrustedTokens(
208             uint256 vaultId,
209             address _connectorAddress,
210             address[] calldata _tokens,
211             bool trusted
212         ) external onlyVaultMaintainer(vaultId) vaultExists(vaultId) {
213             Vault storage vault = vaults[vaultId];
214             for (uint256 i = 0; i < _tokens.length; i++) {
215                 vault.connectors[_connectorAddress].trustedTokens[_tokens[i]] = trusted;
216             }
217             emit ConnectorTrustedTokensUpdated(vaultId, _connectorAddress, _tokens, trusted);
218         }
224         function getPositionBP(uint256 vaultId, bytes32 _positionId) public view returns (PositionBP memory) {
225             return vaults[vaultId].trustedPositionsBP[_positionId];
226         }
238         function addTrustedPosition(
239             uint256 vaultId,
240             uint256 _positionTypeId,
241             address calculatorConnector,
242             bool onlyOwner,
243             bool _isDebt,
244             bytes calldata _data,
245             bytes calldata _additionalData
246         ) external onlyVaultMaintainerWithoutTimeLock(vaultId) vaultExists(vaultId) nonReentrant {
247             Vault storage vault = vaults[vaultId];
248             bytes32 positionId = calculatePositionId(calculatorConnector, _positionTypeId, _data);
249             {
250                 if (vault.trustedPositionsBP[positionId].isEnabled) revert AlreadyExists();
251                 if (vault.connectors[calculatorConnector].enabled == false) revert NotExist();
252                 address[] memory usingTokens = IConnector(calculatorConnector).getUnderlyingTokens(_positionTypeId, _data);
253                 for (uint256 i = 0; i < usingTokens.length; i++) {
254                     if (!isTokenTrusted(vaultId, usingTokens[i], calculatorConnector)) {
255                         revert TokenNotTrusted(usingTokens[i]);
256                     }
257                 }
258     
259                 vault.trustedPositionsBP[positionId] =
260                     PositionBP(calculatorConnector, _positionTypeId, onlyOwner, true, _isDebt, _data, _additionalData);
261             }
262             emit TrustedPositionAdded(vaultId, positionId, calculatorConnector, _positionTypeId, onlyOwner, _isDebt, _data);
263         }
266         function removeTrustedPosition(uint256 vaultId, bytes32 _positionId)
267             external
268             onlyVaultMaintainer(vaultId)
269             vaultExists(vaultId)
270         {
271             Vault storage vault = vaults[vaultId];
272             if (!vault.trustedPositionsBP[_positionId].isEnabled) revert NotExist();
273             uint256 length = vault.holdingPositions.length;
274             for (uint256 i = 0; i < length; i++) {
275                 if (vault.holdingPositions[i].positionId == _positionId) {
276                     revert CannotRemovePosition(vaultId, _positionId);
277                 }
278             }
279             emit TrustedPositionRemoved(vaultId, _positionId);
280             delete vault.trustedPositionsBP[_positionId];
281         }
335         function updateHoldingPosition(
336             uint256 vaultId,
337             bytes32 _positionId,
338             bytes calldata _data,
339             bytes calldata additionalData,
340             bool removePosition
341         ) public vaultExists(vaultId) returns (uint256) {
342             Vault storage vault = vaults[vaultId];
343             if (!vault.connectors[msg.sender].enabled) revert UnauthorizedAccess();
344             if (!vault.trustedPositionsBP[_positionId].isEnabled) revert InvalidPosition(_positionId);
345             bytes32 holdingPositionId = keccak256(abi.encode(msg.sender, _positionId, _data));
346             uint256 positionIndex = vault.isPositionUsed[holdingPositionId];
347             if (positionIndex == 0 && removePosition) return type(uint256).max;
348             if (removePosition) {
349                 if (positionIndex < vault.holdingPositions.length - 1) {
350                     vault.holdingPositions[positionIndex] = vault.holdingPositions[vault.holdingPositions.length - 1];
351                     vault.isPositionUsed[keccak256(
352                         abi.encode(
353                             vault.holdingPositions[positionIndex].calculatorConnector,
354                             vault.holdingPositions[positionIndex].positionId,
355                             vault.holdingPositions[positionIndex].data
356                         )
357                     )] = positionIndex;
358                 }
359                 vault.holdingPositions.pop();
360                 vault.isPositionUsed[holdingPositionId] = 0;
361                 emit HoldingPositionUpdated(vaultId, _positionId, _data, additionalData, removePosition, positionIndex);
362                 return type(uint256).max;
363             }
364             return
365                 updateHoldingPosition(vault, vaultId, _positionId, _data, additionalData, positionIndex, holdingPositionId);
366         }
370         function updateHoldingPostionWithTime(
371             uint256 vaultId,
372             bytes32 _positionId,
373             bytes calldata _data,
374             bytes calldata additionalData,
375             bool removePosition,
376             uint256 positionTimestamp
377         ) external vaultExists(vaultId) {
378             uint256 positionIndex = updateHoldingPosition(vaultId, _positionId, _data, additionalData, removePosition);
379             if (positionIndex != type(uint256).max) {
380                 vaults[vaultId].holdingPositions[positionIndex].positionTimestamp = positionTimestamp;
381             }
382         }
394         function getHoldingPositionIndex(uint256 vaultId, bytes32 _positionId, address _connector, bytes memory data)
395             public
396             view
397             returns (uint256)
398         {
399             bytes32 holdingPositionId = keccak256(abi.encode(_connector, _positionId, data));
400             return vaults[vaultId].isPositionUsed[holdingPositionId];
401         }
408         function getHoldingPosition(uint256 vaultId, uint256 i) public view returns (HoldingPI memory) {
409             return vaults[vaultId].holdingPositions[i];
410         }
416         function getHoldingPositions(uint256 vaultId) public view returns (HoldingPI[] memory) {
417             return vaults[vaultId].holdingPositions;
418         }
426         function isPositionTrusted(uint256 vaultId, bytes32 _positionId) public view returns (bool) {
427             return vaults[vaultId].trustedPositionsBP[_positionId].isEnabled;
428         }
436         function isPositionTrustedForConnector(uint256 vaultId, bytes32 _positionId, address connector)
437             public
438             view
439             returns (bool)
440         {
441             PositionBP memory position = vaults[vaultId].trustedPositionsBP[_positionId];
442             return position.isEnabled && (!position.onlyOwner || position.calculatorConnector == connector);
443         }
449         function getGovernanceAddresses(uint256 vaultId)
450             public
451             view
452             returns (address, address, address, address, address, address)
453         {
454             return (
455                 vaults[vaultId].governer,
456                 vaults[vaultId].maintainer,
457                 vaults[vaultId].maintainerWithoutTimeLock,
458                 vaults[vaultId].keeperContract,
459                 vaults[vaultId].watcherContract,
460                 vaults[vaultId].emergency
461             );
462         }
470         function isTokenTrusted(uint256 vaultId, address token, address connector) public view returns (bool) {
471             return (
472                 vaults[vaultId].connectors[vaults[vaultId].accountManager].trustedTokens[token]
473                     || vaults[vaultId].connectors[connector].trustedTokens[token]
474             );
475         }
486         function calculatePositionId(address calculatorConnector, uint256 positionTypeId, bytes memory data)
487             public
488             pure
489             returns (bytes32)
490         {
491             return keccak256(abi.encode(calculatorConnector, positionTypeId, data));
492         }
499         function isAnActiveConnector(uint256 vaultId, address connectorAddress) public view returns (bool) {
500             return vaults[vaultId].connectors[connectorAddress].enabled;
501         }
508         function isPositionDebt(uint256 vaultId, bytes32 _positionId) public view returns (bool) {
509             return vaults[vaultId].trustedPositionsBP[_positionId].isDebt;
510         }
516         function getVaultAddresses(uint256 vaultId) public view returns (address, address) {
517             return (vaults[vaultId].accountManager, vaults[vaultId].baseToken);
518         }
525         function isAddressTrusted(uint256 vaultId, address addr) public view returns (bool) {
526             if (addr == vaults[vaultId].accountManager) return true;
527             return isAnActiveConnector(vaultId, addr);
528         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


46          function supply(address supplyToken, uint256 amount) external onlyManager nonReentrant {
47              _approveOperations(supplyToken, pool, amount);
48              IPool(pool).supply(supplyToken, amount, address(this), 0);
49              registry.updateHoldingPosition(
50                  vaultId, registry.calculatePositionId(address(this), AAVE_POSITION_ID, ""), "", "", false
51              );
52              _updateTokenInRegistry(supplyToken);
53              emit Supply(supplyToken, amount);
54          }
62          function borrow(uint256 _amount, uint256 _interestRateMode, address _borrowAsset)
63              external
64              onlyManager
65              nonReentrant
66          {
67              if (!registry.isTokenTrusted(vaultId, _borrowAsset, address(this))) {
68                  revert IConnector_UntrustedToken(_borrowAsset);
69              }
70              IPool(pool).borrow(_borrowAsset, _amount, _interestRateMode, 0, address(this));
71              // get the health factor
72              (,,,,, uint256 healthFactor) = IPool(pool).getUserAccountData(address(this));
73              if (healthFactor < minimumHealthFactor) revert IConnector_LowHealthFactor(healthFactor);
74              _updateTokenInRegistry(_borrowAsset);
75              emit Borrow(_borrowAsset, _amount);
76          }
81          function repay(address asset, uint256 amount, uint256 i) external onlyManager nonReentrant {
82              _approveOperations(asset, pool, amount);
83              IPool(pool).repay(asset, amount, i, address(this));
84              _updateTokenInRegistry(asset);
85              emit Repay(asset, amount, i);
86          }
88          function repayWithCollateral(uint256 _amount, uint256 i, address _borrowAsset) external onlyManager {
89              IPool(pool).repayWithATokens(_borrowAsset, _amount, i);
90              emit RepayWithCollateral(_borrowAsset, _amount, i);
91          }
100         function withdrawCollateral(uint256 _collateralAmount, address _collateral) external onlyManager nonReentrant {
101             IPool(pool).withdraw(_collateral, _collateralAmount, address(this));
102             // get the health factor
103             (uint256 totalCollateralBase,,,,, uint256 healthFactor) = IPool(pool).getUserAccountData(address(this));
104             if (healthFactor < minimumHealthFactor) revert IConnector_LowHealthFactor(healthFactor);
105             _updateTokenInRegistry(_collateral);
106             if (totalCollateralBase <= DUST_LEVEL * 1e7) {
107                 registry.updateHoldingPosition(
108                     vaultId, registry.calculatePositionId(address(this), AAVE_POSITION_ID, ""), "", "", true
109                 );
110             }
111             emit WithdrawCollateral(_collateral, _collateralAmount);
112         }
114         function _getPositionTVL(HoldingPI memory, address base) public view override returns (uint256 tvl) {
115             (uint256 totalCollateralBase, uint256 totalDebtBase,,,,) = IPool(pool).getUserAccountData(address(this));
116             uint256 poolBaseAmount = totalCollateralBase - totalDebtBase;
117             return valueOracle.getValue(poolBaseToken, base, poolBaseAmount);
118         }
120         function _getUnderlyingTokens(uint256, bytes memory) public pure override returns (address[] memory) {
121             return new address[](0);
122         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


53          function supply(DepositData memory data) public onlyManager nonReentrant {
54              bytes32 positionId = registry.calculatePositionId(address(this), AERODROME_POSITION_TYPE, abi.encode(data.pool));
55              _approveOperations(IPool(data.pool).token0(), address(aerodromeRouter), data.amount0);
56              _approveOperations(IPool(data.pool).token1(), address(aerodromeRouter), data.amount1);
57              aerodromeRouter.addLiquidity(
58                  IPool(data.pool).token0(),
59                  IPool(data.pool).token1(),
60                  IPool(data.pool).stable(),
61                  data.amount0,
62                  data.amount1,
63                  data.min0Min,
64                  data.min1Min,
65                  address(this),
66                  data.deadline
67              );
68              registry.updateHoldingPosition(vaultId, positionId, "", "", false);
69              _updateTokenInRegistry(IPool(data.pool).token0());
70              _updateTokenInRegistry(IPool(data.pool).token1());
71      
72              emit Supply(data.pool, data.amount0, data.amount1);
73          }
79          function withdraw(WithdrawData memory data) public onlyManager nonReentrant {
80              bytes32 positionId = registry.calculatePositionId(address(this), AERODROME_POSITION_TYPE, abi.encode(data.pool));
81              _approveOperations(data.pool, address(aerodromeRouter), data.amountLiquidity);
82              aerodromeRouter.removeLiquidity(
83                  IPool(data.pool).token0(),
84                  IPool(data.pool).token1(),
85                  IPool(data.pool).stable(),
86                  data.amountLiquidity,
87                  data.min0Min,
88                  data.min1Min,
89                  address(this),
90                  data.deadline
91              );
92              if (IERC20(data.pool).balanceOf(address(this)) == 0) {
93                  registry.updateHoldingPosition(vaultId, positionId, "", "", true);
94              }
95              _updateTokenInRegistry(IPool(data.pool).token0());
96              _updateTokenInRegistry(IPool(data.pool).token1());
97              emit Withdraw(data.pool, data.amountLiquidity);
98          }
100         function stake(address pool, uint256 liquidity) public onlyManager nonReentrant {
101             address gauge = voter.gauges(pool);
102             IERC20(pool).forceApprove(address(gauge), liquidity);
103             IGauge(gauge).deposit(liquidity, address(this));
104         }
106         function unstake(address pool, uint256 liquidity) public onlyManager nonReentrant {
107             address gauge = voter.gauges(pool);
108             IGauge(gauge).withdraw(liquidity);
109         }
111         function claim(address pool) public onlyManager nonReentrant {
112             address gauge = voter.gauges(pool);
113             IGauge(gauge).getReward(address(this));
114             _updateTokenInRegistry(IGauge(gauge).rewardToken());
115         }
117         function _getUnderlyingTokens(uint256 p, bytes memory data) public view override returns (address[] memory) {
118             address[] memory tokens = new address[](2);
119             (address pool) = abi.decode(data, (address));
120             tokens[0] = IPool(pool).token0();
121             tokens[1] = IPool(pool).token1();
122             return tokens;
123         }
125         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {
126             PositionBP memory pBP = registry.getPositionBP(vaultId, p.positionId);
127             (address pool) = abi.decode(pBP.data, (address));
128             uint256 balance = IERC20(pool).balanceOf(address(this));
129             uint256 totalSupply = IERC20(pool).totalSupply();
130             (uint256 reserve0, uint256 reserve1,) = IPool(pool).getReserves();
131             uint256 amount0 = balance * reserve0 / totalSupply;
132             uint256 amount1 = balance * reserve1 / totalSupply;
133             return _getValue(IPool(pool).token0(), base, amount0) + _getValue(IPool(pool).token1(), base, amount1);
134         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


53          function harvestAuraRewards(address[] calldata rewardsPools) public onlyManager nonReentrant {
54              for (uint256 i = 0; i < rewardsPools.length; i++) {
55                  IRewardPool baseRewardPool = IRewardPool(rewardsPools[i]);
56                  baseRewardPool.getReward();
57              }
58              _updateTokenInRegistry(address(AURA));
59          }
64          function openPosition(
65              bytes32 poolId,
66              uint256[] memory amounts,
67              uint256[] memory amountsWithoutBPT,
68              uint256 minBPT,
69              uint256 auraAmount
70          ) public onlyManager nonReentrant {
71              address[] memory tokens;
72              {
73                  (tokens,,) = IBalancerVault(balancerVault).getPoolTokens(poolId);
74              }
75              address pool = IBalancerVault(balancerVault).getPool(poolId);
76      
77              for (uint256 i = 0; i < tokens.length; i++) {
78                  if (amounts[i] > 0) _approveOperations(tokens[i], balancerVault, amounts[i]);
79              }
80      
81              IBalancerVault(balancerVault).joinPool(
82                  poolId,
83                  address(this), // sender
84                  address(this), // recipient
85                  IBalancerVault.JoinPoolRequest(
86                      tokens,
87                      amounts,
88                      abi.encode(
89                          IBalancerVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,
90                          amountsWithoutBPT, //_noBptAmounts,
91                          minBPT // minimumBPT
92                      ),
93                      false
94                  )
95              );
96              bytes32 positionId = registry.calculatePositionId(address(this), BALANCER_LP_POSITION, abi.encode(poolId));
97              registry.updateHoldingPosition(vaultId, positionId, "", "", false);
98      
99              if (auraAmount > 0) {
100                 (PoolInfo memory _poolInfo,) = _getPoolInfo(poolId);
101     
102                 uint256 amount = IERC20(pool).balanceOf(address(this));
103                 _approveOperations(pool, _poolInfo.auraPoolAddress, amount);
104                 IRewardPool(_poolInfo.auraPoolAddress).deposit(auraAmount, address(this));
105             }
106             emit OpenPosition(poolId, amounts, amountsWithoutBPT, minBPT, auraAmount);
107         }
109         function depositIntoAuraBooster(bytes32 poolId, uint256 _amount) public onlyManager nonReentrant {
110             (PoolInfo memory _poolInfo,) = _getPoolInfo(poolId);
111             _approveOperations(_poolInfo.pool, _poolInfo.auraPoolAddress, _amount);
112             IRewardPool(_poolInfo.auraPoolAddress).deposit(_amount, address(this));
113         }
115         function decreasePosition(DecreasePositionParams memory p) public onlyManager nonReentrant {
116             if (p._auraAmount > 0) {
117                 (PoolInfo memory _poolInfo, bytes32 positionId) = _getPoolInfo(p.poolId);
118     
119                 IRewardPool(_poolInfo.auraPoolAddress).withdrawAndUnwrap(p._auraAmount, true);
120             }
121     
122             if (p._lpAmount > 0) {
123                 address[] memory tokens;
124                 {
125                     (tokens,,) = IBalancerVault(balancerVault).getPoolTokens(p.poolId);
126                 }
127                 uint256[] memory _amounts = new uint256[](tokens.length);
128                 _amounts[p.outerIndex] = p.minAmount;
129     
130                 IBalancerVault(balancerVault).exitPool(
131                     p.poolId,
132                     address(this), // sender
133                     payable(address(this)), // recipient
134                     IBalancerVault.ExitPoolRequest(
135                         tokens,
136                         _amounts,
137                         abi.encode(
138                             IBalancerVault.ExitKind.EXACT_BPT_IN_FOR_ONE_TOKEN_OUT,
139                             p._lpAmount,
140                             p.withdrawIndex // enterTokenIndex
141                         ),
142                         false
143                     )
144                 );
145     
146                 if (totalLpBalanceOf(p.poolId) == 0) {
147                     registry.updateHoldingPosition(
148                         vaultId,
149                         registry.calculatePositionId(address(this), BALANCER_LP_POSITION, abi.encode(p.poolId)),
150                         "",
151                         "",
152                         true
153                     );
154                 }
155                 _updateTokenInRegistry(tokens[p.outerIndex]);
156             }
157             _updateTokenInRegistry(AURA);
158             _updateTokenInRegistry(BAL);
159             emit DecreasePosition(p);
160         }
162         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {
163             PositionBP memory PTI = registry.getPositionBP(vaultId, p.positionId);
164             PoolInfo memory pool = abi.decode(PTI.additionalData, (PoolInfo));
165             uint256 lpBalance = totalLpBalanceOf(pool);
166             (, uint256[] memory _tokenBalances,) = IBalancerVault(balancerVault).getPoolTokens(pool.poolId);
167             uint256 _totalSupply = IERC20(pool.pool).totalSupply();
168     
169             uint256 _weight = pool.weights[pool.tokenIndex];
170     
171             uint256 token1bal = valueOracle.getValue(pool.tokens[pool.tokenIndex], base, _tokenBalances[pool.tokenIndex]);
172             return (((1e18 * token1bal * lpBalance) / _weight) / _totalSupply);
173         }
175         function totalLpBalanceOf(PoolInfo memory pool) public view returns (uint256) {
176             uint256 auraShares;
177             if (pool.auraPoolAddress != address(0)) {
178                 auraShares = IERC20(pool.auraPoolAddress).balanceOf(address(this));
179                 auraShares = IRewardPool(pool.auraPoolAddress).convertToAssets(auraShares);
180             }
181             return IERC20(pool.pool).balanceOf(address(this)) + auraShares;
182         }
184         function totalLpBalanceOf(bytes32 poolId) public view returns (uint256) {
185             (PoolInfo memory pool,) = _getPoolInfo(poolId);
186             return totalLpBalanceOf(pool);
187         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


37          function makeFlashLoan(IERC20[] memory tokens, uint256[] memory amounts, bytes memory userData)
38              external
39              nonReentrant
40          {
41              caller = msg.sender;
42              emit MakeFlashLoan(tokens, amounts);
43              vault.flashLoan(this, tokens, amounts, userData);
44              caller = address(0);
45          }
54          function receiveFlashLoan(
55              IERC20[] memory tokens,
56              uint256[] memory amounts,
57              uint256[] memory feeAmounts,
58              bytes memory userData
59          ) external override {
60              emit ReceiveFlashLoan(tokens, amounts, feeAmounts, userData);
61              require(msg.sender == address(vault));
62              (
63                  uint256 vaultId,
64                  address receiver,
65                  address[] memory destinationConnector,
66                  bytes[] memory callingData,
67                  uint256[] memory gas
68              ) = abi.decode(userData, (uint256, address, address[], bytes[], uint256[]));
69              (,,, address keeperContract,, address emergencyManager) = registry.getGovernanceAddresses(vaultId);
70              if (!(caller == keeperContract)) {
71                  revert Unauthorized(caller);
72              }
73              if (registry.isAnActiveConnector(vaultId, receiver)) {
74                  for (uint256 i = 0; i < tokens.length; i++) {
75                      // send the tokens to the receiver
76                      tokens[i].safeTransfer(receiver, amounts[i]);
77                      amounts[i] = amounts[i] + feeAmounts[i];
78                  }
79                  for (uint256 i = 0; i < destinationConnector.length; i++) {
80                      // execute the transactions
81                      (bool success,) = destinationConnector[i].call{ value: 0, gas: gas[i] }(callingData[i]);
82                      require(success, "BalancerFlashLoan: Flash loan failed");
83                  }
84                  for (uint256 i = 0; i < tokens.length; i++) {
85                      // send the tokens back to this contract
86                      BaseConnector(receiver).sendTokensToTrustedAddress(address(tokens[i]), amounts[i], address(this), "");
87                  }
88              }
89              for (uint256 i = 0; i < tokens.length; i++) {
90                  // send the tokens back to the vault
91                  tokens[i].safeTransfer(msg.sender, amounts[i]);
92                  require(tokens[i].balanceOf(address(this)) == 0, "BalancerFlashLoan: Flash loan extra tokens");
93              }
94          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


43          function addLiquidityInCamelotPool(CamelotAddLiquidityParams calldata p) external onlyManager nonReentrant {
44              _approveOperations(p.tokenA, address(router), p.amountA);
45              _approveOperations(p.tokenB, address(router), p.amountB);
46              router.addLiquidity(
47                  p.tokenA, p.tokenB, p.amountA, p.amountB, p.minAmountA, p.minAmountB, address(this), p.deadline
48              );
49              _updateTokenInRegistry(p.tokenA);
50              _updateTokenInRegistry(p.tokenB);
51              registry.updateHoldingPosition(
52                  vaultId,
53                  registry.calculatePositionId(address(this), CAMELOT_POSITION_ID, abi.encode(p.tokenA, p.tokenB)),
54                  "",
55                  "",
56                  false
57              );
58          }
65          function removeLiquidityFromCamelotPool(CamelotRemoveLiquidityParams calldata p)
66              external
67              onlyManager
68              nonReentrant
69          {
70              address pool = factory.getPair(p.tokenA, p.tokenB);
71              _approveOperations(pool, address(router), p.amountLiquidty);
72              router.removeLiquidity(
73                  p.tokenA, p.tokenB, p.amountLiquidty, p.minAmountA, p.minAmountB, address(this), p.deadline
74              );
75              _updateTokenInRegistry(p.tokenA);
76              _updateTokenInRegistry(p.tokenB);
77              if (IERC20(pool).balanceOf(address(this)) == 0) {
78                  registry.updateHoldingPosition(
79                      vaultId,
80                      registry.calculatePositionId(address(this), CAMELOT_POSITION_ID, abi.encode(p.tokenA, p.tokenB)),
81                      "",
82                      "",
83                      true
84                  );
85              }
86          }
88          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
89              (address tokenA, address tokenB) =
90                  abi.decode(registry.getPositionBP(vaultId, p.positionId).data, (address, address));
91              address pool = factory.getPair(tokenA, tokenB);
92              uint256 totalSupply = IERC20(pool).totalSupply();
93              (uint256 reserves0, uint256 reserves1,,) = ICamelotPair(pool).getReserves();
94      
95              uint256 balanceThis = IERC20(pool).balanceOf(address(this));
96              return balanceThis * (_getValue(tokenA, base, reserves0) + _getValue(tokenB, base, reserves1)) / totalSupply;
97          }
99          function _getUnderlyingTokens(uint256 id, bytes memory data) public view override returns (address[] memory) {
100             (address tokenA, address tokenB) = abi.decode(data, (address, address));
101             address[] memory tokens = new address[](2);
102             tokens[0] = tokenA;
103             tokens[1] = tokenB;
104             return tokens;
105         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


29          function supply(address market, address asset, uint256 amount) external onlyManager nonReentrant {
30              _approveOperations(asset, market, amount);
31              if (!registry.isTokenTrusted(vaultId, asset, address(this))) revert IConnector_UntrustedToken(asset);
32              IComet(market).supply(asset, amount);
33              registry.updateHoldingPosition(
34                  vaultId, registry.calculatePositionId(address(this), COMPOUND_LP, abi.encode(market)), "", "", false
35              );
36              _updateTokenInRegistry(asset);
37              emit Supply(market, asset, amount);
38          }
48          function withdrawOrBorrow(address _market, address asset, uint256 amount) external onlyManager nonReentrant {
49              IComet(_market).withdraw(asset, amount);
50              if (!registry.isTokenTrusted(vaultId, asset, address(this))) revert IConnector_UntrustedToken(asset);
51              uint256 healthFactor = getAccountHealthFactor(IComet(_market));
52              if (healthFactor < minimumHealthFactor) revert IConnector_LowHealthFactor(healthFactor);
53              if (getCollBlanace(IComet(_market), false) == 0) {
54                  registry.updateHoldingPosition(
55                      vaultId, registry.calculatePositionId(address(this), COMPOUND_LP, abi.encode(_market)), "", "", true
56                  );
57              }
58              _updateTokenInRegistry(asset);
59              emit WithdrawOrBorrow(_market, asset, amount);
60          }
63          function claimRewards(address rewardContract, address market) external onlyManager nonReentrant {
64              address rewardToken = IRewards(rewardContract).rewardConfig(market).token;
65              IRewards(rewardContract).claim(address(market), address(this), true);
66              _updateTokenInRegistry(rewardToken);
67              emit ClaimRewards(rewardContract, market);
68          }
74          function getAccountHealthFactor(IComet comet) public view returns (uint256) {
75              // Get the amount of base debt owed adjusted for price.
76              uint256 borrowBalanceInBase = getBorrowBalanceInBase(comet);
77              if (borrowBalanceInBase == 0) return type(uint256).max;
78              return getCollBlanace(comet, true) * 1e18 / borrowBalanceInBase;
79          }
84          function getBorrowBalanceInBase(IComet comet) public view returns (uint256 borrowBalanceInVirtualBase) {
85              uint256 borrowBalanceInBase = comet.borrowBalanceOf(address(this));
86              if (borrowBalanceInBase == 0) return 0;
87              address basePriceFeed = comet.baseTokenPriceFeed();
88              uint256 basePriceInVirtualBase = comet.getPrice(basePriceFeed);
89              borrowBalanceInVirtualBase = (borrowBalanceInBase * basePriceInVirtualBase) / comet.baseScale();
90          }
95          function getCollBlanace(IComet comet, bool riskAdjusted) public view returns (uint256 CollValue) {
96              IComet.UserBasic memory userBasic = comet.userBasic(address(this));
97              uint16 assetsIn = userBasic.assetsIn;
98              uint256 basePrice = comet.getPrice(comet.baseTokenPriceFeed());
99              uint256 baseScale = comet.baseScale();
100             if (userBasic.principal > 0) {
101                 uint256 principalInBase = uint256(uint104(userBasic.principal));
102                 CollValue += principalInBase;
103             }
104             uint8 numberOfAssets = comet.numAssets();
105     
106             // Iterate through assets, and determine the risk adjusted collateral value.
107             for (uint8 i; i < numberOfAssets; ++i) {
108                 if (isInAsset(assetsIn, i)) {
109                     IComet.AssetInfo memory info = comet.getAssetInfo(i);
110     
111                     // Check if we have a collateral balance.
112                     (uint256 collateralBalance,) = comet.userCollateral(address(this), info.asset);
113     
114                     // Get the value of collateral in virtual base.
115                     uint256 collateralPriceInVirtualBase = comet.getPrice(info.priceFeed);
116     
117                     uint256 collateralValueInVirtualBase =
118                         collateralBalance * collateralPriceInVirtualBase * baseScale / info.scale / basePrice;
119                     if (riskAdjusted) CollValue += collateralValueInVirtualBase * info.liquidateCollateralFactor / 1e18;
120                     else CollValue += collateralValueInVirtualBase;
121                 } // else user collateral is zero.
122             }
123         }
125         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {
126             address market = abi.decode(registry.getPositionBP(vaultId, p.positionId).data, (address));
127     
128             uint256 positiveBalance = getCollBlanace(IComet(market), false);
129             uint256 negativeBalance = getBorrowBalanceInBase(IComet(market));
130             uint256 balance = positiveBalance - negativeBalance;
131             return (valueOracle.getValue(IComet(market).baseToken(), base, balance));
132         }
134         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {
135             return new address[](0);
136         }
141         function isInAsset(uint16 assetsIn, uint8 assetOffset) public pure returns (bool) {
142             return (assetsIn & (uint16(1) << assetOffset) != 0);
143         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


68          function depositIntoGauge(address pool, uint256 amount) public onlyManager nonReentrant {
69              PoolInfo memory poolInfo = _getPoolInfo(pool);
70      
71              _approveOperations(poolInfo.lpToken, poolInfo.gauge, amount);
72              IRewardsGauge(poolInfo.gauge).deposit(amount);
73          }
81          function depositIntoPrisma(address pool, uint256 amount, bool curveOrConvex) public onlyManager nonReentrant {
82              PoolInfo memory poolInfo = _getPoolInfo(pool);
83      
84              // approve depositToken to spend lpToken
85              address lpToken = poolInfo.lpToken;
86              address depostiToken = poolInfo.prismaCurvePool;
87              if (!curveOrConvex) {
88                  depostiToken = poolInfo.prismaConvexPool;
89              }
90              _approveOperations(lpToken, depostiToken, amount);
91      
92              // stake LP in Prisma
93              IDepositToken(depostiToken).deposit(address(this), amount);
94          }
103         function depositIntoConvexBooster(address pool, uint256 pid, uint256 amount, bool stake) public onlyManager {
104             PoolInfo memory poolInfo = _getPoolInfo(pool);
105     
106             _approveOperations(poolInfo.lpToken, address(convexBooster), amount);
107             convexBooster.deposit(pid, amount, stake);
108         }
117         function openCurvePosition(address pool, uint256 depositIndex, uint256 amount, uint256 minAmount)
118             public
119             onlyManager
120             nonReentrant
121         {
122             bytes32 positionId = registry.calculatePositionId(address(this), CURVE_LP_POSITION, abi.encode(pool));
123             PositionBP memory p = registry.getPositionBP(vaultId, positionId);
124             PoolInfo memory poolInfo = abi.decode(p.additionalData, (PoolInfo));
125             address token = poolInfo.tokens[depositIndex];
126             address poolAddress = (poolInfo.tokens.length > 2 && poolInfo.zap != address(0)) ? poolInfo.zap : pool;
127             _approveOperations(token, poolAddress, amount);
128             if (poolInfo.tokens.length == 2) {
129                 uint256[2] memory amounts;
130                 amounts[depositIndex] = amount;
131                 ICurveSwap(poolAddress).add_liquidity(amounts, minAmount);
132             } else if (poolInfo.tokens.length == 3) {
133                 uint256[3] memory amounts;
134                 amounts[depositIndex] = amount;
135                 ICurveSwap(poolAddress).add_liquidity(amounts, minAmount);
136             } else if (poolInfo.tokens.length == 4) {
137                 uint256[4] memory amounts;
138                 amounts[depositIndex] = amount;
139                 ICurveSwap(poolAddress).add_liquidity(amounts, minAmount);
140             } else if (poolInfo.tokens.length == 5) {
141                 uint256[5] memory amounts;
142                 amounts[depositIndex] = amount;
143                 ICurveSwap(poolAddress).add_liquidity(amounts, minAmount);
144             } else if (poolInfo.tokens.length == 6) {
145                 uint256[6] memory amounts;
146                 amounts[depositIndex] = amount;
147                 ICurveSwap(poolAddress).add_liquidity(amounts, minAmount);
148             }
149             emit OpenCurvePosition(pool, depositIndex, amount, minAmount);
150             registry.updateHoldingPosition(vaultId, positionId, "", "", false);
151         }
160         function decreaseCurvePosition(address pool, uint256 withdrawIndex, uint256 amount, uint256 minAmount)
161             public
162             onlyManager
163             nonReentrant
164         {
165             PoolInfo memory poolInfo = _getPoolInfo(pool);
166             address token = poolInfo.tokens[withdrawIndex];
167             bytes32 positionId = registry.calculatePositionId(address(this), CURVE_LP_POSITION, abi.encode(pool));
168     
169             ICurveSwap(poolInfo.pool).remove_liquidity_one_coin(amount, int128(uint128(withdrawIndex)), minAmount);
170             _updateTokenInRegistry(token);
171             if (totalLpBalanceOf(poolInfo) == 0) {
172                 registry.updateHoldingPosition(vaultId, positionId, "", "", true);
173             }
174             emit DecreaseCurvePosition(pool, withdrawIndex, amount, minAmount);
175         }
182         function withdrawFromConvexBooster(uint256 pid, uint256 amount) public onlyManager {
183             convexBooster.withdraw(pid, amount);
184             emit WithdrawFromConvexBooster(pid, amount);
185         }
192         function withdrawFromConvexRewardPool(address pool, uint256 amount) public onlyManager {
193             IConvexBasicRewards(pool).withdraw(amount, true);
194             emit WithdrawFromConvexRewardPool(pool, amount);
195         }
202         function withdrawFromGauge(address pool, uint256 amount) public onlyManager {
203             IRewardsGauge(pool).withdraw(amount);
204             emit WithdrawFromGauge(pool, amount);
205         }
212         function withdrawFromPrisma(address depostiToken, uint256 amount) public onlyManager {
213             IDepositToken(depostiToken).withdraw(address(this), amount);
214             emit WithdrawFromPrisma(depostiToken, amount);
215         }
221         function harvestRewards(address[] calldata gauges) public onlyManager nonReentrant {
222             for (uint256 i = 0; i < gauges.length; i++) {
223                 IRewardsGauge(gauges[i]).claim_rewards(address(this));
224             }
225             _updateTokenInRegistry(CRV);
226             emit HarvestRewards(gauges);
227         }
233         function harvestPrismaRewards(address[] calldata pools) public onlyManager nonReentrant {
234             for (uint256 i = 0; i < pools.length; i++) {
235                 IDepositToken(pools[i]).claimReward(address(this));
236             }
237             _updateTokenInRegistry(PRISMA);
238             _updateTokenInRegistry(CRV);
239             _updateTokenInRegistry(CVX);
240             emit HarvestPrismaRewards(pools);
241         }
247         function harvestConvexRewards(address[] calldata rewardsPools) public onlyManager nonReentrant {
248             for (uint256 i = 0; i < rewardsPools.length; i++) {
249                 IConvexBasicRewards baseRewardPool = IConvexBasicRewards(rewardsPools[i]);
250                 baseRewardPool.getReward(address(this), true);
251             }
252             _updateTokenInRegistry(CVX);
253             _updateTokenInRegistry(CRV);
254             emit HarvestConvexRewards(rewardsPools);
255         }
265         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
266             PositionBP memory PTI = registry.getPositionBP(vaultId, p.positionId);
267             PoolInfo memory poolInfo = abi.decode(PTI.additionalData, (PoolInfo));
268             uint256 lpBalance = totalLpBalanceOf(poolInfo);
269             (uint256 amount, address token) = LPToUnder(poolInfo, lpBalance);
270             return _getValue(token, base, amount);
271         }
279         function LPToUnder(PoolInfo memory info, uint256 balance) public view returns (uint256, address) {
280             if (balance == 0) return (0, info.tokens[info.defaultWithdrawIndex]);
281             uint256 underlyingAssetAmount =
282                 estimateWithdrawAmount(ICurveSwap(info.pool), balance, info.defaultWithdrawIndex);
283             if (info.poolAddressIfDefaultWithdrawTokenIsAnotherPosition != address(0)) {
284                 return
285                     LPToUnder(_getPoolInfo(info.poolAddressIfDefaultWithdrawTokenIsAnotherPosition), underlyingAssetAmount);
286             }
287             return (underlyingAssetAmount, info.tokens[info.defaultWithdrawIndex]);
288         }
297         function estimateWithdrawAmount(ICurveSwap curvePool, uint256 amount, uint256 index)
298             public
299             view
300             returns (uint256)
301         {
302             int128 tokenIndex = int128(uint128(index));
303             return curvePool.calc_withdraw_one_coin(amount, tokenIndex);
304         }
311         function totalLpBalanceOf(PoolInfo memory info) public view returns (uint256) {
312             uint256 lpBalance = balanceOfLPToken(info);
313             uint256 rewardBalance = balanceOfRewardPool(info);
314             uint256 convexRewardBalance = balanceOfConvexRewardPool(info);
315             uint256 prismaBalance = balanceOfPrisma(info.prismaCurvePool);
316             uint256 prismaConvexBalance = balanceOfPrisma(info.prismaConvexPool);
317             return lpBalance + rewardBalance + convexRewardBalance + prismaBalance + prismaConvexBalance;
318         }
325         function balanceOfConvexRewardPool(PoolInfo memory info) public view returns (uint256) {
326             if (info.convexRewardPool == address(0)) return 0;
327             return IConvexBasicRewards(info.convexRewardPool).balanceOf(address(this));
328         }
335         function balanceOfLPToken(PoolInfo memory info) public view returns (uint256) {
336             return IERC20(info.lpToken).balanceOf(address(this));
337         }
344         function balanceOfRewardPool(PoolInfo memory info) public view returns (uint256) {
345             if (info.gauge == address(0)) return 0;
346             return IRewardsGauge(info.gauge).balanceOf(address(this));
347         }
354         function balanceOfPrisma(address prismaPool) public view returns (uint256) {
355             if (prismaPool == address(0)) return 0;
356             return IDepositToken(prismaPool).balanceOf(address(this));
357         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


30          function deposit(uint256 marketId, uint256 _amount) public onlyManager nonReentrant {
31              // get market token
32              address token = dolomiteMargin.getMarketTokenAddress(marketId);
33              // approve
34              _approveOperations(token, address(dolomiteMargin), _amount);
35              depositWithdrawalProxy.depositWeiIntoDefaultAccount(marketId, _amount);
36              // Update token
37              _updateTokenInRegistry(token);
38              registry.updateHoldingPosition(
39                  vaultId, registry.calculatePositionId(address(this), DOL_POSITION_ID, ""), abi.encode(0), "", false
40              );
41          }
43          function withdraw(uint256 marketId, uint256 _amount) public onlyManager nonReentrant {
44              address token = dolomiteMargin.getMarketTokenAddress(marketId);
45              depositWithdrawalProxy.withdrawWeiFromDefaultAccount(
46                  marketId, _amount, AccountBalanceHelper.BalanceCheckFlag.None
47              );
48              // Update token
49              _updateTokenInRegistry(token);
50              (uint256[] memory markets,,,) = dolomiteMargin.getAccountBalances(Info(address(this), 0));
51              if (markets.length == 0) {
52                  registry.updateHoldingPosition(
53                      vaultId, registry.calculatePositionId(address(this), DOL_POSITION_ID, ""), abi.encode(0), "", true
54                  );
55              }
56          }
58          function openBorrowPosition(uint256 marketId, uint256 _amountWei, uint256 accountId)
59              public
60              onlyManager
61              nonReentrant
62          {
63              address token = dolomiteMargin.getMarketTokenAddress(marketId);
64      
65              if (!registry.isTokenTrusted(vaultId, token, address(this))) {
66                  revert IConnector_UntrustedToken(token);
67              }
68              // borrow
69              borrowPositionProxy.openBorrowPosition(
70                  0, accountId, marketId, _amountWei, AccountBalanceHelper.BalanceCheckFlag.None
71              );
72              registry.updateHoldingPosition(
73                  vaultId, registry.calculatePositionId(address(this), DOL_POSITION_ID, ""), abi.encode(accountId), "", true
74              );
75          }
77          function transferBetweenAccounts(uint256 accountId, uint256 marketId, uint256 _amountWei, bool borrowOrRepay)
78              public
79              onlyManager
80              nonReentrant
81          {
82              address token = dolomiteMargin.getMarketTokenAddress(marketId);
83      
84              if (!registry.isTokenTrusted(vaultId, token, address(this))) {
85                  revert IConnector_UntrustedToken(token);
86              }
87              if (borrowOrRepay) {
88                  borrowPositionProxy.transferBetweenAccounts(
89                      accountId, 0, marketId, _amountWei, AccountBalanceHelper.BalanceCheckFlag.None
90                  );
91              } else {
92                  borrowPositionProxy.transferBetweenAccounts(
93                      0, accountId, marketId, _amountWei, AccountBalanceHelper.BalanceCheckFlag.None
94                  );
95              }
96          }
98          function closeBorrowPosition(uint256[] memory marketIds, uint256 accountId) public onlyManager nonReentrant {
99              // repay
100             borrowPositionProxy.closeBorrowPosition(accountId, 0, marketIds);
101             registry.updateHoldingPosition(
102                 vaultId, registry.calculatePositionId(address(this), DOL_POSITION_ID, ""), abi.encode(accountId), "", true
103             );
104         }
106         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
107             uint256 accountId = abi.decode(p.data, (uint256));
108     
109             (uint256[] memory markets, address[] memory tokens,, Types.Wei[] memory amounts) =
110                 dolomiteMargin.getAccountBalances(Info(address(this), accountId));
111             uint256 totalDebt = 0;
112             uint256 totalCollateral = 0;
113             for (uint256 i = 0; i < markets.length; i++) {
114                 uint256 value = valueOracle.getValue(tokens[i], base, amounts[i].value);
115                 if (amounts[i].sign) {
116                     totalCollateral += value;
117                 } else {
118                     totalDebt += value;
119                 }
120             }
121             return totalCollateral - totalDebt;
122         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


38          function borrowAndSupply(IFraxPair pool, uint256 borrowAmount, uint256 collateralAmount)
39              external
40              onlyManager
41              nonReentrant
42          {
43              bytes32 positionId =
44                  registry.calculatePositionId(address(this), COLLATERAL_AND_DEBT_POSITION_TYPE, abi.encode(pool));
45              IERC20 token = IERC20(pool.collateralContract());
46              if (collateralAmount > 0) {
47                  _approveOperations(address(token), address(pool), collateralAmount);
48              }
49              if (borrowAmount > 0) {
50                  pool.borrowAsset(borrowAmount, collateralAmount, address(this));
51                  _updateTokenInRegistry(pool.asset());
52              } else if (collateralAmount > 0) {
53                  pool.addCollateral(collateralAmount, address(this));
54              }
55              if (collateralAmount > 0) {
56                  _updateTokenInRegistry(address(token));
57              }
58              registry.updateHoldingPosition(vaultId, positionId, "", "", false);
59              verifyHealthFactor(pool);
60              emit BorrowAndSupply(address(pool), borrowAmount, collateralAmount);
61          }
68          function withdraw(IFraxPair pool, uint256 withdrawAmount) public onlyManager nonReentrant {
69              uint256 currentCollateral = pool.userCollateralBalance(address(this));
70              if (withdrawAmount == currentCollateral) {
71                  bytes32 positionId =
72                      registry.calculatePositionId(address(this), COLLATERAL_AND_DEBT_POSITION_TYPE, abi.encode(pool));
73      
74                  registry.updateHoldingPosition(vaultId, positionId, "", "", true);
75              }
76              pool.removeCollateral(withdrawAmount, address(this));
77              _updateTokenInRegistry(pool.collateralContract());
78              verifyHealthFactor(pool);
79              emit Withdraw(address(pool), withdrawAmount);
80          }
87          function repay(IFraxPair pool, uint256 sharesToRepay) public onlyManager nonReentrant {
88              uint256 repayTokenAmount = pool.toBorrowAmount(sharesToRepay, true);
89              uint256 sharesOwed = pool.userBorrowShares(address(this));
90              address asset = pool.asset();
91              if (sharesToRepay > sharesOwed) {
92                  revert IConnector_InvalidInput();
93              }
94              _approveOperations(asset, address(pool), repayTokenAmount);
95              IFraxPair(pool).repayAsset(sharesToRepay, address(this));
96              _updateTokenInRegistry(asset);
97              emit Repay(address(pool), sharesToRepay);
98          }
104         function verifyHealthFactor(IFraxPair pool) public view {
105             // Check health factor is still satisfactory
106             uint256 exchangeRate = pool.exchangeRateInfo().exchangeRate;
107             // Check if borrower is insolvent after this borrow tx, revert if they are
108             uint256 healthFactor = _getHealthFactor(pool, exchangeRate);
109             if (minimumHealthFactor > healthFactor) {
110                 revert IConnector_LowHealthFactor(healthFactor);
111             }
112         }
142         function _getUnderlyingTokens(uint256 p, bytes memory data) public view override returns (address[] memory) {
143             address[] memory tokens = new address[](2);
144             (address pool) = abi.decode(data, (address));
145             tokens[0] = IFraxPair(pool).collateralContract();
146             tokens[1] = IFraxPair(pool).asset();
147             return tokens;
148         }
150         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
151             PositionBP memory positionInfo = registry.getPositionBP(vaultId, p.positionId);
152             IFraxPair pool = IFraxPair(abi.decode(positionInfo.data, (address)));
153             uint256 collateralAmount = pool.userCollateralBalance(address(this));
154             uint256 borrowerShares = pool.userBorrowShares(address(this));
155             uint256 _borrowerAmount = pool.toBorrowAmount(borrowerShares, true);
156     
157             uint256 borrowValue = _getValue(pool.asset(), base, _borrowerAmount);
158             uint256 collateralValue = _getValue(pool.collateralContract(), base, collateralAmount);
159             if (collateralValue > borrowValue) {
160                 return collateralValue - borrowValue;
161             }
162             return tvl;
163         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


24          function openAccount(address facade, uint256 ref) public onlyManager {
25              address c = ICreditFacadeV3(facade).openCreditAccount(address(this), new MultiCall[](0), ref);
26              registry.updateHoldingPosition(
27                  vaultId,
28                  registry.calculatePositionId(address(this), GEARBOX_POSITION_ID, abi.encode(facade)),
29                  abi.encode(c),
30                  "",
31                  false
32              );
33              emit OpenAccount(facade, ref);
34          }
41          function closeAccount(address facade, address creditAccount) public onlyManager nonReentrant {
42              ICreditFacadeV3(facade).closeCreditAccount(creditAccount, new MultiCall[](0));
43      
44              registry.updateHoldingPosition(
45                  vaultId,
46                  registry.calculatePositionId(address(this), GEARBOX_POSITION_ID, abi.encode(facade)),
47                  abi.encode(creditAccount),
48                  "",
49                  true
50              );
51              emit CloseAccount(facade, creditAccount);
52          }
62          function executeCommands(
63              address facade,
64              address creditAccount,
65              MultiCall[] calldata calls,
66              address approvalToken,
67              uint256 amount
68          ) public onlyManager nonReentrant {
69              for (uint256 i = 0; i < calls.length; i++) {
70                  if (calls[i].target != facade) revert IConnector_InvalidTarget(calls[i].target);
71                  bytes4 method = bytes4(calls[i].callData[:4]);
72      
73                  if (method == ICreditFacadeV3Multicall.enableToken.selector) {
74                      (address token) = abi.decode(calls[i].callData[4:], (address));
75                      _updateTokenInRegistry(token);
76                  }
77              }
78              if (approvalToken != address(0)) {
79                  _approveOperations(approvalToken, ICreditFacadeV3(facade).creditManager(), amount);
80              }
81              ICreditFacadeV3(facade).multicall(creditAccount, calls);
82              if (approvalToken != address(0)) {
83                  _revokeApproval(approvalToken, ICreditFacadeV3(facade).creditManager());
84              }
85              emit ExecuteCommands(facade, creditAccount, calls, approvalToken, amount);
86          }
93          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
94              address creditAccount = abi.decode(p.data, (address));
95              PositionBP memory positionInfo = registry.getPositionBP(vaultId, p.positionId);
96              ICreditFacadeV3 facade = ICreditFacadeV3(abi.decode(positionInfo.data, (address)));
97              CollateralDebtData memory d = ICreditManagerV3(facade.creditManager()).calcDebtAndCollateral(
98                  creditAccount, CollateralCalcTask.DEBT_COLLATERAL_SAFE_PRICES
99              );
100             if (d.totalDebtUSD > d.totalValueUSD) {
101                 return 0;
102             }
103             return _getValue(address(840), base, (d.totalValueUSD - d.totalDebtUSD));
104         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


37          function deposit(uint256 amountIn) external onlyManager nonReentrant {
38              IWETH(weth).withdraw(amountIn);
39              // deposit recieved eth into Lido
40              // refferal address can be different
41              ILido(lido).submit{ value: amountIn }(address(0));
42              _updateTokenInRegistry(steth);
43              _updateTokenInRegistry(weth);
44              emit Deposit(amountIn);
45          }
51          function requestWithdrawals(uint256 amount) public onlyManager nonReentrant {
52              _approveOperations(steth, lidoWithdrawal, amount);
53              // prepare inputs for requestWithdrawals
54              uint256[] memory amounts = new uint256[](1);
55              amounts[0] = amount;
56              // request for withdrawal
57              uint256[] memory requestIds = ILidoWithdrawal(lidoWithdrawal).requestWithdrawals(amounts, address(this));
58              bytes32 positionId = registry.calculatePositionId(address(this), LIDO_WITHDRAWAL_REQUEST_ID, "");
59              registry.updateHoldingPosition(vaultId, positionId, abi.encode(requestIds[0]), abi.encode(amount), false);
60      
61              _updateTokenInRegistry(steth);
62              emit RequestWithdrawals(amount);
63          }
69          function claimWithdrawal(uint256 requestId) public onlyManager nonReentrant {
70              // approve to lidoWithdrawal to spend withdrawal NFT
71              ILidoWithdrawal(lidoWithdrawal).approve(lidoWithdrawal, requestId);
72              // eth balance before claim
73              uint256 beforeClaimBalance = address(this).balance;
74              // claim request withdrawal
75              ILidoWithdrawal(lidoWithdrawal).claimWithdrawal(requestId);
76              // emit ClaimWithdrawal event
77              IWETH(weth).deposit{ value: address(this).balance - beforeClaimBalance }();
78              registry.updateHoldingPosition(
79                  vaultId,
80                  registry.calculatePositionId(address(this), LIDO_WITHDRAWAL_REQUEST_ID, ""),
81                  abi.encode(requestId),
82                  "",
83                  true
84              );
85              _updateTokenInRegistry(weth);
86              emit ClaimWithdrawal(requestId);
87          }
89          receive() external payable { }
91          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
92              (uint256 amount) = abi.decode(p.additionalData, (uint256));
93              return _getValue(steth, base, amount);
94          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


56          receive() external payable { }
64          function stake(uint256 amount, uint256 duration, bool doDelegation) external onlyManager nonReentrant {
65              // approve veMav to spend mav
66              _approveOperations(mav, veMav, amount);
67              // stake mav
68              IveMAV(veMav).stake(amount, duration, doDelegation);
69              _updateTokenInRegistry(mav);
70              _updateTokenInRegistry(veMav);
71              emit Stake(amount, duration, doDelegation);
72          }
78          function unstake(uint256 lockupId) external onlyManager nonReentrant {
79              // unstake veMav
80              IveMAV(veMav).unstake(lockupId);
81              _updateTokenInRegistry(mav);
82              _updateTokenInRegistry(veMav);
83              emit Unstake(lockupId);
84          }
91          function addLiquidityInMaverickPool(MavericAddLiquidityParams calldata p) external onlyManager nonReentrant {
92              uint256 sendEthAmount = p.ethPoolIncluded ? p.tokenARequiredAllowance : 0;
93              _approveOperations(p.pool.tokenA(), maverickRouter, p.tokenARequiredAllowance); // TODO: check token A is eth
94              _approveOperations(p.pool.tokenB(), maverickRouter, p.tokenBRequiredAllowance);
95              // add liquidity
96              uint256 tokenId;
97              {
98                  (tokenId,,,) = IMaverickRouter(maverickRouter).addLiquidityToPool{ value: sendEthAmount }(
99                      p.pool, 0, p.params, p.minTokenAAmount, p.minTokenBAmount, p.deadline
100                 );
101             }
102             registry.updateHoldingPosition(
103                 vaultId, registry.calculatePositionId(address(this), MAVERICK_LP, abi.encode(p.pool)), "", "", false
104             );
105             _updateTokenInRegistry(p.pool.tokenA());
106             _updateTokenInRegistry(p.pool.tokenB());
107             emit AddLiquidityInMaverickPool(p);
108         }
115         function removeLiquidityFromMaverickPool(MavericRemoveLiquidityParams calldata p)
116             external
117             onlyManager
118             nonReentrant
119         {
120             IMaverickPosition position = IMaverickRouter(maverickRouter).position();
121             position.approve(maverickRouter, p.tokenId);
122             IMaverickRouter(maverickRouter).removeLiquidity(
123                 p.pool, address(this), p.tokenId, p.params, p.minTokenAAmount, p.minTokenBAmount, p.deadline
124             );
125             registry.updateHoldingPosition(
126                 vaultId, registry.calculatePositionId(address(this), MAVERICK_LP, abi.encode(p.pool)), "", "", true
127             );
128             _updateTokenInRegistry(p.pool.tokenA());
129             _updateTokenInRegistry(p.pool.tokenB());
130             emit RemoveLiquidityFromMaverickPool(p);
131         }
137         function claimBoostedPositionRewards(IMaverickReward rewardContract) external onlyManager nonReentrant {
138             IMaverickReward.EarnedInfo[] memory earnedInfo = rewardContract.earned(address(this));
139             uint8 tokenIndex;
140             for (uint256 i = 0; i < earnedInfo.length; i++) {
141                 if (earnedInfo[i].earned != 0) {
142                     tokenIndex = rewardContract.tokenIndex(address(earnedInfo[i].rewardToken));
143                     rewardContract.getReward(address(this), tokenIndex);
144                 }
145             }
146             emit ClaimBoostedPositionRewards(rewardContract);
147         }
149         function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {
150             return this.onERC721Received.selector;
151         }
153         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
154             PositionBP memory position = registry.getPositionBP(vaultId, p.positionId);
155             IMaverickPool pool = abi.decode(position.data, (IMaverickPool));
156     
157             (uint256 a, uint256 b) = positionInspector.addressBinReservesAllKindsAllTokenIds(address(this), pool);
158             return _getValue(pool.tokenA(), base, a) + _getValue(pool.tokenB(), base, b);
159         }
161         function _getUnderlyingTokens(uint256 id, bytes memory data) public view override returns (address[] memory) {
162             (address pool) = abi.decode(data, (address));
163             address[] memory tokens = new address[](2);
164             tokens[0] = IMaverickPool(pool).tokenA();
165             tokens[1] = IMaverickPool(pool).tokenB();
166             return tokens;
167         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


35          function supply(uint256 amount, Id id, bool sOrC) external onlyManager nonReentrant {
36              MarketParams memory params = morphoBlue.idToMarketParams(id);
37              if (sOrC) {
38                  _approveOperations(params.loanToken, address(morphoBlue), amount);
39                  morphoBlue.supply(params, amount, 0, address(this), "");
40                  _updateTokenInRegistry(params.loanToken);
41              } else {
42                  _approveOperations(params.collateralToken, address(morphoBlue), amount);
43                  morphoBlue.supplyCollateral(params, amount, address(this), "");
44                  _updateTokenInRegistry(params.collateralToken);
45              }
46              registry.updateHoldingPosition(
47                  vaultId, registry.calculatePositionId(address(this), MORPHO_POSITION_ID, abi.encode(id)), "", "", false
48              );
49              emit Supply(amount, id, sOrC);
50          }
58          function withdraw(uint256 amount, Id id, bool sOrC) external onlyManager nonReentrant {
59              MarketParams memory params = morphoBlue.idToMarketParams(id);
60              if (sOrC) {
61                  morphoBlue.withdraw(params, amount, 0, address(this), address(this));
62              } else {
63                  morphoBlue.withdrawCollateral(params, amount, address(this), address(this));
64              }
65              Position memory p = morphoBlue.position(id, address(this));
66              if (p.collateral == 0 && p.supplyShares == 0) {
67                  registry.updateHoldingPosition(
68                      vaultId, registry.calculatePositionId(address(this), MORPHO_POSITION_ID, abi.encode(id)), "", "", true
69                  );
70              }
71              _updateTokenInRegistry(params.collateralToken);
72              emit Withdraw(amount, id, sOrC);
73          }
80          function borrow(uint256 amount, Id id) external onlyManager nonReentrant {
81              MarketParams memory market = morphoBlue.idToMarketParams(id);
82              morphoBlue.borrow(market, amount, 0, address(this), address(this));
83              if (getHealthFactor(id, morphoBlue.market(id)) < minimumHealthFactor) {
84                  revert IConnector_LowHealthFactor(getHealthFactor(id, morphoBlue.market(id)));
85              }
86              _updateTokenInRegistry(market.loanToken);
87              emit Borrow(amount, id);
88          }
95          function repay(uint256 amount, Id id) public onlyManager nonReentrant {
96              MarketParams memory params = morphoBlue.idToMarketParams(id);
97              _approveOperations(params.loanToken, address(morphoBlue), amount);
98              morphoBlue.repay(params, amount, 0, address(this), "");
99              _updateTokenInRegistry(params.loanToken);
100             emit Repay(amount, id);
101         }
108         function getHealthFactor(Id _id, Market memory _market) public view returns (uint256) {
109             MarketParams memory market = morphoBlue.idToMarketParams(_id);
110             Position memory p = morphoBlue.position(_id, address(this));
111             uint256 borrowAmount = uint256(p.borrowShares).toAssetsUp(_market.totalBorrowAssets, _market.totalBorrowShares);
112             if (borrowAmount == 0) return type(uint256).max;
113     
114             // get collateralAmount in borrowAmount for LTV calculations
115             return market.lltv * convertCToL(p.collateral, market.oracle, market.collateralToken) / borrowAmount;
116         }
118         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
119             PositionBP memory positionInfo = registry.getPositionBP(vaultId, p.positionId);
120             if (positionInfo.positionTypeId == MORPHO_POSITION_ID) {
121                 Id id = abi.decode(positionInfo.data, (Id));
122                 MarketParams memory params = morphoBlue.idToMarketParams(id);
123                 Market memory market = morphoBlue.market(id);
124                 Position memory pos = morphoBlue.position(id, address(this));
125                 uint256 borrowAmount =
126                     uint256(pos.borrowShares).toAssetsUp(market.totalBorrowAssets, market.totalBorrowShares);
127                 uint256 supplyAmount =
128                     uint256(pos.supplyShares).toAssetsUp(market.totalSupplyAssets, market.totalSupplyShares);
129                 tvl = _getValue(
130                     params.loanToken,
131                     base,
132                     supplyAmount + borrowAmount + convertCToL(pos.collateral, params.oracle, params.collateralToken)
133                 );
134             }
135         }
137         function convertCToL(uint256 amount, address marketOracle, address collateral) public view returns (uint256) {
138             return amount * IOracle(marketOracle).price() / ORACLE_PRICE_SCALE;
139         }
141         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {
142             Id id = abi.decode(data, (Id));
143             MarketParams memory params = morphoBlue.idToMarketParams(id);
144             address[] memory tokens = new address[](2);
145             tokens[0] = params.loanToken;
146             tokens[1] = params.collateralToken;
147             return tokens;
148         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


31          function sendPositionToMasterChef(uint256 tokenId) external onlyManager nonReentrant {
32              IERC721(address(positionManager)).safeTransferFrom(address(this), address(masterchef), tokenId);
33              emit SendPositionToMasterChef(tokenId);
34          }
40          function updatePosition(uint256 tokenId) public onlyManager nonReentrant {
41              masterchef.updateLiquidity(tokenId);
42              _updateTokenInRegistry(masterchef.CAKE());
43              emit UpdatePosition(tokenId);
44          }
50          function withdraw(uint256 tokenId) public onlyManager nonReentrant {
51              masterchef.withdraw(tokenId, address(this));
52              _updateTokenInRegistry(masterchef.CAKE());
53              emit Withdraw(tokenId);
54          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


78          function supply(address market, uint256 amount) external onlyManager nonReentrant {
79              (IPStandardizedYield _SY, IPPrincipalToken _PT,) = IPMarket(market).readTokens();
80      
81              (, address _underlyingToken,) = _SY.assetInfo();
82      
83              _approveOperations(_underlyingToken, address(_SY), amount);
84              // Mint SY from underlying token
85              uint256 syMinted = _SY.deposit(address(this), _underlyingToken, amount, 1);
86      
87              bytes32 positionId = registry.calculatePositionId(address(this), PENDLE_POSITION_ID, abi.encode(market));
88              registry.updateHoldingPosition(vaultId, positionId, "", "", false);
89              emit Supply(market, syMinted);
90          }
97          function mintPTAndYT(address market, uint256 syAmount) external onlyManager nonReentrant {
98              (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
99              IERC20(address(_SY)).safeTransfer(address(_YT), syAmount);
100             _YT.mintPY(address(this), address(this));
101             emit MintPTAndYT(market, syAmount);
102         }
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
113             (IPStandardizedYield _SY, IPPrincipalToken _PT,) = IPMarket(market).readTokens();
114             IERC20(address(_SY)).safeTransfer(address(market), SYamount);
115             IERC20(address(_PT)).safeTransfer(address(market), PTamount);
116             market.mint(address(this), SYamount, PTamount);
117             market.skim();
118             emit DepositIntoMarket(address(market), SYamount, PTamount);
119         }
126         function depositIntoPenpie(address _market, uint256 _amount) public onlyManager nonReentrant {
127             _approveOperations(_market, pendleMarketDepositHelper.pendleStaking(), _amount);
128             pendleMarketDepositHelper.depositMarket(_market, _amount);
129             emit DepositIntoPenpie(_market, _amount);
130         }
137         function withdrawFromPenpie(address _market, uint256 _amount) public onlyManager nonReentrant {
138             pendleMarketDepositHelper.withdrawMarketWithClaim(_market, _amount, true);
139             emit WithdrawFromPenpie(_market, _amount);
140         }
149         function swapYTForPT(address market, uint256 exactYTIn, uint256 min, ApproxParams memory guess)
150             external
151             onlyManager
152         {
153             (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
154             _approveOperations(address(_YT), address(pendleRouter), exactYTIn);
155             pendleRouter.swapExactYtForPt(address(this), market, exactYTIn, min, guess);
156             emit SwapYTForPT(market, exactYTIn, min, guess);
157         }
166         function swapYTForSY(address market, uint256 exactYTIn, uint256 min, LimitOrderData memory orderData)
167             public
168             onlyManager
169         {
170             (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
171             _approveOperations(address(_YT), address(pendleRouter), exactYTIn);
172             pendleRouter.swapExactYtForSy(address(this), market, exactYTIn, min, orderData);
173             emit SwapYTForSY(market, exactYTIn, min, orderData);
174         }
183         function swapExactPTForSY(IPMarket market, uint256 exactPTIn, bytes calldata swapData, uint256 minSY)
184             external
185             onlyManager
186             nonReentrant
187         {
188             (IPStandardizedYield _SY, IPPrincipalToken _PT,) = IPMarket(market).readTokens();
189             IERC20(address(_PT)).safeTransfer(address(market), exactPTIn);
190             (uint256 netSyOut, uint256 netSyFee) = market.swapExactPtForSy(address(this), exactPTIn, swapData);
191             if (netSyOut < minSY) {
192                 revert InsufficientSyOut(netSyOut, minSY);
193             }
194             market.skim();
195             emit SwapExactPTForSY(address(market), exactPTIn, swapData, minSY);
196         }
203         function burnLP(IPMarket market, uint256 amount) external onlyManager nonReentrant {
204             IERC20(address(market)).safeTransfer(address(market), amount);
205             market.burn(address(this), address(market), amount);
206             market.skim();
207             emit BurnLP(address(market), amount);
208         }
216         function decreasePosition(IPMarket market, uint256 _amount, bool closePosition) external onlyManager nonReentrant {
217             (IPStandardizedYield SY,,) = market.readTokens();
218             (, address _underlyingToken,) = SY.assetInfo();
219     
220             // redeems an amount of base tokens by burning SY
221             IERC20(address(SY)).safeTransfer(address(SY), _amount);
222             IPStandardizedYield(address(SY)).redeem(address(this), _amount, _underlyingToken, 1, true);
223             if (closePosition && isMarketEmpty(market)) {
224                 registry.updateHoldingPosition(
225                     vaultId,
226                     registry.calculatePositionId(address(this), PENDLE_POSITION_ID, abi.encode(market)),
227                     "",
228                     "",
229                     true
230                 );
231             }
232             emit DecreasePosition(address(market), _amount, closePosition);
233         }
241         function claimRewards(IPMarket market) external onlyManager nonReentrant {
242             market.redeemRewards(address(this));
243             address[] memory rewardTokens = market.getRewardTokens();
244             for (uint256 i = 0; i < rewardTokens.length; i++) {
245                 _updateTokenInRegistry(rewardTokens[i]);
246             }
247             emit ClaimRewards(address(market));
248         }
257         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
258             PositionBP memory positionInfo = registry.getPositionBP(vaultId, p.positionId);
259             if (positionInfo.positionTypeId == PENDLE_POSITION_ID) {
260                 uint256 underlyingBalance = 0;
261                 address market = abi.decode(positionInfo.data, (address));
262                 (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
263                 (, address _underlyingToken,) = _SY.assetInfo();
264     
265                 uint256 SYAmount = _SY.balanceOf(address(this));
266     
267                 //
268                 uint256 lpBalance =
269                     IERC20(market).balanceOf(address(this)) + pendleMarketDepositHelper.balance(market, address(this));
270                 if (lpBalance > 0) {
271                     SYAmount += lpBalance * IPMarket(market).getLpToAssetRate(10) / 1e18;
272                 }
273     
274                 uint256 PTAmount = _PT.balanceOf(address(this));
275                 if (PTAmount > 0) SYAmount += PTAmount * IPMarket(market).getPtToAssetRate(10) / 1e18;
276     
277                 uint256 YTBalance = _YT.balanceOf(address(this));
278                 if (YTBalance > 0) SYAmount += getYTValue(market, YTBalance);
279     
280                 if (SYAmount > 0) underlyingBalance += SYAmount * _SY.exchangeRate() / 1e18;
281     
282                 tvl = valueOracle.getValue(_underlyingToken, base, underlyingBalance);
283             }
284             return tvl;
285         }
293         function getYTValue(address market, uint256 balance) public view returns (uint256) {
294             (uint256 netSyOut,,,,,,) = staticRouter.swapExactYtForSyStatic(market, balance);
295             return netSyOut;
296         }
303         function isMarketEmpty(IPMarket market) public view returns (bool) {
304             (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
305             return (
306                 _SY.balanceOf(address(this)) == 0 && _PT.balanceOf(address(this)) == 0 && _YT.balanceOf(address(this)) == 0
307                     && market.balanceOf(address(this)) == 0
308             );
309         }
311         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {
312             address market = abi.decode(data, (address));
313             (IPStandardizedYield SY,,) = IPMarket(market).readTokens();
314             address[] memory tokens = new address[](1);
315             (, tokens[0],) = SY.assetInfo();
316             return tokens;
317         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


33          function approveZap(IStakeNTroveZap zap, address tm, bool approve) public onlyManager nonReentrant {
34              if (approve) {
35                  bytes32 positionId = registry.calculatePositionId(address(this), PRISMA_POSITION_ID, abi.encode(zap, tm));
36      
37                  if (!registry.isPositionTrustedForConnector(vaultId, positionId, address(this))) {
38                      revert IConnector_InvalidPosition(positionId);
39                  }
40              }
41              IBorrowerOperations(zap.borrowerOps()).setDelegateApproval(address(zap), approve);
42          }
52          function openTrove(IStakeNTroveZap zap, address tm, uint256 maxFee, uint256 dAmount, uint256 bAmount)
53              public
54              onlyManager
55              nonReentrant
56          {
57              bytes32 positionId = registry.calculatePositionId(address(this), PRISMA_POSITION_ID, abi.encode(zap, tm));
58              PositionBP memory positionInfo = registry.getPositionBP(vaultId, positionId);
59              address collateral = abi.decode(positionInfo.additionalData, (address));
60              address debTtoken = ITroveManager(tm).debtToken();
61              _approveOperations(collateral, address(zap), dAmount);
62              zap.openTrove(tm, maxFee, dAmount, bAmount, address(this), address(this));
63              registry.updateHoldingPosition(vaultId, positionId, "", "", false);
64              _updateTokenInRegistry(collateral);
65              _updateTokenInRegistry(debTtoken);
66              emit OpenTrove(address(zap), tm, maxFee, dAmount, bAmount);
67          }
75          function addColl(IStakeNTroveZap zapContract, address tm, uint256 amountIn) public onlyManager nonReentrant {
76              bytes32 positionId =
77                  registry.calculatePositionId(address(this), PRISMA_POSITION_ID, abi.encode(zapContract, tm));
78              PositionBP memory positionInfo = registry.getPositionBP(vaultId, positionId);
79              if (registry.getHoldingPositionIndex(vaultId, positionId, address(this), "") == 0) {
80                  revert IConnector_InvalidPosition(positionId);
81              }
82              address collateral = abi.decode(positionInfo.additionalData, (address));
83              _approveOperations(collateral, address(zapContract), amountIn);
84              zapContract.addColl(tm, amountIn, address(this), address(this));
85              emit AddColl(address(zapContract), tm, amountIn);
86          }
97          function adjustTrove(
98              IStakeNTroveZap zapContract,
99              address tm,
100             uint256 mFee,
101             uint256 wAmount,
102             uint256 bAmount,
103             bool isBorrowing
104         ) public onlyManager nonReentrant {
105             bytes32 positionId =
106                 registry.calculatePositionId(address(this), PRISMA_POSITION_ID, abi.encode(zapContract, tm));
107             if (registry.getHoldingPositionIndex(vaultId, positionId, address(this), "") == 0) {
108                 revert IConnector_InvalidPosition(positionId);
109             }
110             IBorrowerOperations borrowerOps = zapContract.borrowerOps();
111             if (bAmount > 0 && !isBorrowing) {
112                 _approveOperations(ITroveManager(tm).debtToken(), address(borrowerOps), bAmount);
113             }
114             borrowerOps.adjustTrove(tm, address(this), mFee, 0, wAmount, bAmount, isBorrowing, address(this), address(this));
115             _updateTokenInRegistry(ITroveManager(tm).debtToken());
116             // get health factor
117             uint256 healthFactor = ITroveManager(tm).getNominalICR(address(this));
118             if (minimumHealthFactor > healthFactor) {
119                 revert IConnector_LowHealthFactor(healthFactor);
120             }
121             emit AdjustTrove(address(zapContract), tm, mFee, wAmount, bAmount, isBorrowing);
122         }
129         function closeTrove(IStakeNTroveZap zapContract, address troveManager) public onlyManager nonReentrant {
130             bytes32 positionId =
131                 registry.calculatePositionId(address(this), PRISMA_POSITION_ID, abi.encode(zapContract, troveManager));
132             IBorrowerOperations borrowerOperations = zapContract.borrowerOps();
133             borrowerOperations.closeTrove(troveManager, address(this));
134             registry.updateHoldingPosition(vaultId, positionId, "", "", true);
135             emit CloseTrove(address(zapContract), troveManager);
136         }
145         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
146             PositionBP memory positionInfo = registry.getPositionBP(vaultId, p.positionId);
147             if (positionInfo.positionTypeId == PRISMA_POSITION_ID) {
148                 (address zap, address troveManager) = abi.decode(positionInfo.data, (address, address));
149                 IBorrowerOperations borrowerOperations = IStakeNTroveZap(zap).borrowerOps();
150                 address collateral = borrowerOperations.troveManagersData(troveManager).collateralToken;
151                 address debTtoken = ITroveManager(troveManager).debtToken();
152                 (uint256 collateralBalance, uint256 debtBalance) =
153                     ITroveManager(troveManager).getTroveCollAndDebt(address(this));
154                 return _getValue(collateral, base, collateralBalance) - _getValue(debTtoken, base, debtBalance);
155             }
156         }
164         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {
165             (address zap, address troveManager) = abi.decode(data, (address, address));
166             IBorrowerOperations borrowerOperations = IStakeNTroveZap(zap).borrowerOps();
167             address collateral = borrowerOperations.troveManagersData(troveManager).collateralToken;
168             address debTtoken = ITroveManager(troveManager).debtToken();
169             address[] memory tokens = new address[](2);
170             tokens[0] = collateral;
171             tokens[1] = debTtoken;
172             return tokens;
173         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


25          function createAccount() public onlyManager {
26              // Create account
27              SNXCoreProxy.createAccount();
28          }
30          function deposit(address _token, uint256 _amount, uint128 _accountId) public onlyManager {
31              // Deposit
32              _approveOperations(_token, address(SNXCoreProxy), _amount);
33      
34              SNXCoreProxy.deposit(_accountId, _token, _amount);
35              registry.updateHoldingPosition(
36                  vaultId,
37                  registry.calculatePositionId(address(this), SNX_POSITION_ID, ""),
38                  abi.encode(_accountId, _token),
39                  "",
40                  false
41              );
42              // Update token
43              _updateTokenInRegistry(_token);
44          }
46          function withdraw(address _token, uint256 _amount, uint128 _accountId) public onlyManager {
47              // Deposit
48              _approveOperations(_token, address(SNXCoreProxy), _amount);
49              SNXCoreProxy.withdraw(_accountId, _token, _amount);
50              (uint256 c,,) = SNXCoreProxy.getAccountCollateral(_accountId, _token);
51              if (c == 0) {
52                  registry.updateHoldingPosition(
53                      vaultId,
54                      registry.calculatePositionId(address(this), SNX_POSITION_ID, ""),
55                      abi.encode(_accountId, _token),
56                      "",
57                      true
58                  );
59              }
60              // Update token
61              _updateTokenInRegistry(_token);
62          }
64          function onERC721Received(address, address, uint256, bytes memory) external pure override returns (bytes4) {
65              return this.onERC721Received.selector;
66          }
68          function delegateIntoPreferredPool(
69              uint128 _accountId,
70              address collateralType,
71              uint256 newCollateralAmountD18,
72              uint256 leverage
73          ) public onlyManager {
74              // Delegate
75      
76              uint128 poolId = SNXCoreProxy.getPreferredPool();
77      
78              SNXCoreProxy.delegateCollateral(_accountId, poolId, collateralType, newCollateralAmountD18, leverage);
79          }
81          function delegateIntoApprovedPool(
82              uint256 poolIndex,
83              uint128 _accountId,
84              address collateralType,
85              uint256 newCollateralAmountD18,
86              uint256 leverage
87          ) public onlyManager {
88              uint256[] memory poolIds = SNXCoreProxy.getApprovedPools();
89              SNXCoreProxy.delegateCollateral(
90                  _accountId, uint128(poolIds[poolIndex]), collateralType, newCollateralAmountD18, leverage
91              );
92          }
94          function claimRewards(uint128 accountId, uint128 poolId, address collateralType, address distributor)
95              public
96              onlyManager
97          {
98              SNXCoreProxy.claimRewards(accountId, poolId, collateralType, distributor);
99              _updateTokenInRegistry(collateralType);
100         }
102         function mintOrBurnSUSD(
103             uint256 _amount,
104             uint128 _accountId,
105             uint128 poolId,
106             address collateralType,
107             bool mintOrBurn
108         ) public onlyManager {
109             // Mint or burn
110             address usdToken = SNXCoreProxy.getUsdToken();
111             if (mintOrBurn) {
112                 SNXCoreProxy.mintUsd(_accountId, poolId, collateralType, _amount);
113             } else {
114                 _approveOperations(usdToken, address(SNXCoreProxy), _amount);
115                 SNXCoreProxy.burnUsd(_accountId, poolId, collateralType, _amount);
116             }
117             _updateTokenInRegistry(collateralType);
118             _updateTokenInRegistry(usdToken);
119         }
121         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
122             (uint128 accountId, address collateralType) = abi.decode(p.data, (uint128, address));
123             (uint256 totalDeposited, uint256 totalAssigned, uint256 totalLocked) =
124                 SNXCoreProxy.getAccountCollateral(accountId, collateralType);
125             tvl = _getValue(collateralType, base, totalDeposited + totalAssigned);
126         }
128         function _getUnderlyingTokens(uint256, bytes memory) public pure override returns (address[] memory) {
129             return new address[](0);
130         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


33          function deposit(address siloToken, address dToken, uint256 amount, bool oC) external onlyManager nonReentrant {
34              ISilo silo = ISilo(siloRepository.getSilo(siloToken));
35              _approveOperations(dToken, address(silo), amount);
36              silo.deposit(dToken, amount, oC);
37              _updateTokenInRegistry(dToken);
38              registry.updateHoldingPosition(
39                  vaultId, registry.calculatePositionId(address(this), SILO_LP_ID, abi.encode(siloToken)), "", "", false
40              );
41              emit Deposit(siloToken, dToken, amount, oC);
42          }
52          function withdraw(address siloToken, address wToken, uint256 amount, bool oC, bool closePosition)
53              external
54              onlyManager
55              nonReentrant
56          {
57              ISilo silo = ISilo(siloRepository.getSilo(siloToken));
58              silo.withdraw(wToken, amount, oC);
59              _updateTokenInRegistry(wToken);
60              if (closePosition && isSiloEmpty(silo)) {
61                  registry.updateHoldingPosition(
62                      vaultId, registry.calculatePositionId(address(this), SILO_LP_ID, abi.encode(siloToken)), "", "", true
63                  );
64              }
65              if (!SolvencyV2.isSolvent(silo, address(this), minimumHealthFactor)) {
66                  revert IConnector_LowHealthFactor(0);
67              }
68              emit Withdraw(siloToken, wToken, amount, oC, closePosition);
69          }
71          function getData(address siloToken)
72              public
73              view
74              returns (uint256 userLTV, uint256 LiquidationThreshold, bool isSolvent)
75          {
76              return SolvencyV2.getData(ISilo(siloRepository.getSilo(siloToken)), address(this), minimumHealthFactor);
77          }
85          function borrow(address siloToken, address bToken, uint256 amount) external onlyManager nonReentrant {
86              ISilo silo = ISilo(siloRepository.getSilo(siloToken));
87              silo.borrow(bToken, amount);
88              _updateTokenInRegistry(bToken);
89              emit Borrow(siloToken, bToken, amount);
90          }
98          function repay(address siloToken, address rToken, uint256 amount) external onlyManager nonReentrant {
99              ISilo silo = ISilo(siloRepository.getSilo(siloToken));
100             _approveOperations(rToken, address(silo), amount);
101             silo.repay(rToken, amount);
102             _updateTokenInRegistry(rToken);
103             if (!SolvencyV2.isSolvent(silo, address(this), minimumHealthFactor)) {
104                 revert IConnector_LowHealthFactor(0);
105             }
106             emit Repay(siloToken, rToken, amount);
107         }
109         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
110             PositionBP memory bp = registry.getPositionBP(vaultId, p.positionId);
111             (address siloToken) = abi.decode(bp.data, (address));
112             ISilo silo = ISilo(siloRepository.getSilo(siloToken));
113             (address[] memory assets, IBaseSilo.AssetStorage[] memory assetsS) = silo.getAssetsWithState();
114             uint256 totalDepositAmount = 0;
115             uint256 totalBAmount = 0;
116             for (uint256 i = 0; i < assets.length; i++) {
117                 uint256 depositAmount = IERC20(assetsS[i].collateralToken).balanceOf(address(this));
118                 depositAmount += IERC20(assetsS[i].collateralOnlyToken).balanceOf(address(this));
119                 uint256 borrowAmount = IERC20(assetsS[i].debtToken).balanceOf(address(this));
120                 if (depositAmount == 0 && borrowAmount == 0) {
121                     continue;
122                 }
123                 uint256 price = _getValue(assets[i], base, 1e18);
124                 totalDepositAmount += depositAmount * price / 1e18;
125                 totalBAmount += borrowAmount * price / 1e18;
126             }
127             tvl = totalDepositAmount - totalBAmount;
128         }
130         function isSiloEmpty(ISilo silo) public view returns (bool) {
131             (, IBaseSilo.AssetStorage[] memory assetsS) = silo.getAssetsWithState();
132             for (uint256 i = 0; i < assetsS.length; i++) {
133                 if (
134                     IERC20(assetsS[i].collateralToken).balanceOf(address(this))
135                         + IERC20(assetsS[i].collateralOnlyToken).balanceOf(address(this)) > 0
136                 ) {
137                     return false;
138                 }
139             }
140             return true;
141         }
143         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {
144             (address siloToken) = abi.decode(data, (address));
145             ISilo silo = ISilo(siloRepository.getSilo(siloToken));
146             (address[] memory assets,) = silo.getAssetsWithState();
147             return assets;
148         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


49          function depositIntoStargatePool(StargateRequest calldata depositRequest) external onlyManager nonReentrant {
50              address lpAddress = LPStaking.poolInfo(depositRequest.poolId).lpToken;
51              address underlyingToken = IStargatePool(lpAddress).token();
52              if (depositRequest.routerAmount > 0) {
53                  _approveOperations(underlyingToken, address(stargateRouter), depositRequest.routerAmount);
54                  stargateRouter.addLiquidity(depositRequest.poolId, depositRequest.routerAmount, address(this));
55                  _updateTokenInRegistry(underlyingToken);
56              }
57              if (depositRequest.LPStakingAmount > 0) {
58                  uint256 stakingAmount = depositRequest.LPStakingAmount;
59                  if (depositRequest.LPStakingAmount == type(uint256).max) {
60                      stakingAmount = IERC20(lpAddress).balanceOf(address(this));
61                  }
62                  _approveOperations(lpAddress, address(LPStaking), stakingAmount);
63                  LPStaking.deposit(depositRequest.poolId, stakingAmount);
64              }
65              _updateTokenInRegistry(rewardToken);
66              bytes32 positionId =
67                  registry.calculatePositionId(address(this), STARGATE_LP_POSITION_TYPE, abi.encode(depositRequest.poolId));
68              registry.updateHoldingPosition(vaultId, positionId, "", "", false);
69              emit DepositIntoStargatePool(depositRequest);
70          }
76          function withdrawFromStargatePool(StargateRequest calldata withdrawRequest) external onlyManager nonReentrant {
77              address lpAddress = LPStaking.poolInfo(withdrawRequest.poolId).lpToken;
78              address underlyingToken = IStargatePool(lpAddress).token();
79              if (withdrawRequest.LPStakingAmount > 0) {
80                  IStargateLPStaking(LPStaking).withdraw(withdrawRequest.poolId, withdrawRequest.LPStakingAmount);
81              }
82              if (withdrawRequest.routerAmount > 0) {
83                  stargateRouter.instantRedeemLocal(
84                      uint16(withdrawRequest.poolId), withdrawRequest.routerAmount, address(this)
85                  );
86                  _updateTokenInRegistry(underlyingToken);
87              }
88              uint256 LPAmount = LPStaking.userInfo(withdrawRequest.poolId, address(this)).amount;
89              if (IERC20(lpAddress).balanceOf(address(this)) + LPAmount == 0) {
90                  bytes32 positionId = registry.calculatePositionId(
91                      address(this), STARGATE_LP_POSITION_TYPE, abi.encode(withdrawRequest.poolId)
92                  );
93                  registry.updateHoldingPosition(vaultId, positionId, "", "", true);
94              }
95              _updateTokenInRegistry(rewardToken);
96              emit WithdrawFromStargatePool(withdrawRequest);
97          }
103         function claimStargateRewards(uint256 poolId) external onlyManager nonReentrant {
104             LPStaking.deposit(poolId, 0);
105             _updateTokenInRegistry(rewardToken);
106             emit ClaimStargateRewards(poolId);
107         }
110         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
111             PositionBP memory pBP = registry.getPositionBP(vaultId, p.positionId);
112             uint256 poolId = abi.decode(pBP.data, (uint256));
113             address lpAddress = LPStaking.poolInfo(poolId).lpToken;
114             uint256 lpAmount = LPStaking.userInfo(poolId, address(this)).amount + IERC20(lpAddress).balanceOf(address(this));
115             if (lpAmount == 0) {
116                 return 0;
117             }
118             address underlyingToken = IStargatePool(lpAddress).token();
119             uint256 underlyingAmount = IStargatePool(lpAddress).amountLPtoLD(lpAmount);
120             return _getValue(underlyingToken, base, underlyingAmount);
121         }
123         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {
124             uint256 poolId = abi.decode(data, (uint256));
125             address lpAddress = LPStaking.poolInfo(poolId).lpToken;
126             address[] memory tokens = new address[](1);
127             tokens[0] = IStargatePool(lpAddress).token();
128             return tokens;
129         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


40          function openPosition(MintParams memory p) external onlyManager nonReentrant returns (uint256 tokenId) {
41              bytes32 positionId =
42                  registry.calculatePositionId(address(this), UNI_LP_POSITION_TYPE, abi.encode(p.token0, p.token1));
43              p.recipient = address(this);
44              // Approve NonfungiblePositionManager to spend `token0` and `token1`.
45              _approveOperations(p.token0, address(positionManager), p.amount0Desired);
46              _approveOperations(p.token1, address(positionManager), p.amount1Desired);
47      
48              // Supply liquidity to pool.
49              (tokenId,,,) = positionManager.mint(p);
50              bytes memory positionData = abi.encode(tokenId);
51              registry.updateHoldingPosition(
52                  vaultId, positionId, positionData, abi.encode(p.tickLower, p.tickUpper, p.fee), false
53              );
54              _updateTokenInRegistry(p.token0);
55              _updateTokenInRegistry(p.token1);
56              emit OpenPosition(p, tokenId);
57          }
63          function decreasePosition(DecreaseLiquidityParams memory p) external onlyManager nonReentrant {
64              (uint128 currentLiquidity, address token0, address token1) = getCurrentLiquidity(p.tokenId);
65              if (p.liquidity > currentLiquidity) {
66                  revert IConnector_InvalidAmount();
67              }
68              positionManager.decreaseLiquidity(p);
69              _collectFees(p.tokenId);
70              _updateTokenInRegistry(token0);
71              _updateTokenInRegistry(token1);
72      
73              if (currentLiquidity == p.liquidity) {
74                  positionManager.burn(p.tokenId);
75                  bytes32 positionId =
76                      registry.calculatePositionId(address(this), UNI_LP_POSITION_TYPE, abi.encode(token0, token1));
77                  bytes memory positionData = abi.encode(p.tokenId);
78                  registry.updateHoldingPosition(vaultId, positionId, positionData, "", true);
79              }
80              emit DecreasePosition(p);
81          }
87          function increasePosition(IncreaseLiquidityParams memory p) external onlyManager nonReentrant {
88              (, address token0, address token1) = getCurrentLiquidity(p.tokenId);
89              // Approve NonfungiblePositionManager to spend `token0` and `token1`.
90              _approveOperations(token0, address(positionManager), p.amount0Desired);
91              _approveOperations(token1, address(positionManager), p.amount1Desired);
92              positionManager.increaseLiquidity(p);
93              _updateTokenInRegistry(token0);
94              _updateTokenInRegistry(token1);
95              emit IncreasePosition(p);
96          }
101         function collectAllFees(uint256[] memory tokenIds) public onlyManager nonReentrant {
102             for (uint256 i = 0; i < tokenIds.length; i++) {
103                 (, address token0, address token1) = getCurrentLiquidity(tokenIds[i]);
104                 _collectFees(tokenIds[i]);
105                 _updateTokenInRegistry(token0);
106                 _updateTokenInRegistry(token1);
107                 emit CollectFees(tokenIds[i]);
108             }
109         }
116         function getCurrentLiquidity(uint256 tokenId) public view returns (uint128, address, address) {
117             (,, address token0, address token1,,,, uint128 liquidity,,,,) = positionManager.positions(tokenId);
118             return (liquidity, token0, token1);
119         }
127         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
128             PositionBP memory positionInfo = registry.getPositionBP(vaultId, p.positionId);
129             uint256 tokenId = abi.decode(p.data, (uint256));
130             (address token0, address token1) = abi.decode(positionInfo.data, (address, address));
131             uint256 amount0;
132             uint256 amount1;
133             (int24 tL, int24 tU, uint24 fee) = abi.decode(p.additionalData, (int24, int24, uint24));
134             {
135                 IUniswapV3Pool pool = IUniswapV3Pool(factory.getPool(token0, token1, fee));
136                 bytes32 key = keccak256(abi.encodePacked(positionManager, tL, tU));
137     
138                 (uint128 liquidity,,, uint128 tokensOwed0, uint128 tokensOwed1) = pool.positions(key);
139     
140                 (uint160 sqrtPriceX96,,,,,,) = pool.slot0();
141                 (amount0, amount1) = LiquidityAmounts.getAmountsForLiquidity(
142                     sqrtPriceX96, TickMath.getSqrtRatioAtTick(tL), TickMath.getSqrtRatioAtTick(tU), liquidity
143                 );
144                 amount0 += tokensOwed0;
145                 amount1 += tokensOwed1;
146             }
147     
148             tvl += valueOracle.getValue(token0, base, amount0);
149             tvl += valueOracle.getValue(token1, base, amount1);
150         }
152         function _getUnderlyingTokens(uint256, bytes memory data) public pure override returns (address[] memory) {
153             address[] memory tokens = new address[](2);
154             (tokens[0], tokens[1]) = abi.decode(data, (address, address));
155             return tokens;
156         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


42          function updateOwners(address[] memory _owners, bool[] memory addOrRemove) public onlyOwner {
43              uint256 numOwnersTemp = numOwners;
44              for (uint256 i = 0; i < _owners.length; i++) {
45                  if (addOrRemove[i] && !isOwner[_owners[i]]) {
46                      isOwner[_owners[i]] = true;
47                      numOwnersTemp++;
48                  } else if (!addOrRemove[i] && isOwner[_owners[i]]) {
49                      isOwner[_owners[i]] = false;
50                      numOwnersTemp--;
51                  }
52              }
53              require(numOwnersTemp <= 10 && threshold <= numOwnersTemp && threshold > 1);
54              numOwners = numOwnersTemp;
55              emit UpdateOwners(_owners, addOrRemove);
56          }
63          function setThreshold(uint8 _threshold) public onlyOwner {
64              require(_threshold <= numOwners && _threshold > 1);
65              threshold = _threshold;
66              emit UpdateThreshold(_threshold);
67          }
84          function execute(
85              address destination,
86              bytes calldata data,
87              uint256 gasLimit,
88              address executor,
89              bytes32[] memory sigR,
90              bytes32[] memory sigS,
91              uint8[] memory sigV,
92              uint256 deadline
93          ) public {
94              require(isOwner[msg.sender], "Not an owner");
95              require(sigR.length == threshold, "Not enough signatures");
96              require(sigR.length == sigS.length && sigR.length == sigV.length, "Lengths do not match");
97              require(executor == msg.sender, "Invalid executor");
98              require(block.timestamp <= deadline, "Transaction expired");
99              {
100                 bytes32 txInputHash =
101                     keccak256(abi.encode(TXTYPE_HASH, nonce, destination, data, gasLimit, executor, deadline));
102                 bytes32 totalHash = keccak256(abi.encodePacked("\x19\x01", _domainSeparatorV4(), txInputHash));
103                 address lastAdd = address(0);
104                 for (uint256 i = 0; i < threshold;) {
105                     address recovered = ECDSA.recover(totalHash, sigV[i], sigR[i], sigS[i]);
106                     require(recovered > lastAdd && isOwner[recovered]);
107                     lastAdd = recovered;
108                     unchecked {
109                         ++i;
110                     }
111                 }
112     
113                 nonce++;
114             }
115             emit Execute(destination, data, gasLimit, executor, deadline);
116             (bool success,) = destination.call{ gas: gasLimit }(data);
117             require(success, "Transaction execution reverted.");
118         }
124         function domainSeparatorV4() public view returns (bytes32) {
125             return _domainSeparatorV4();
126         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/governance/Watchers.sol


8           function verifyRemoveLiquidity(uint256 withdrawAmount, uint256 sentAmount, bytes memory data) external view { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Watchers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


45          function updateMinimumHealthFactor(uint256 _minimumHealthFactor) external onlyMaintainer {
46              if (_minimumHealthFactor < MINIMUM_HEALTH_FACTOR) {
47                  revert IConnector_LowHealthFactor(_minimumHealthFactor);
48              }
49              minimumHealthFactor = _minimumHealthFactor;
50              emit MinimumHealthFactorUpdated(_minimumHealthFactor);
51          }
58          function updateSwapHandler(address payable _swapHandler) external onlyMaintainer {
59              swapHandler = SwapAndBridgeHandler(_swapHandler);
60              emit SwapHandlerUpdated(_swapHandler);
61          }
67          function updateValueOracle(address _valueOracle) external onlyMaintainer {
68              valueOracle = INoyaValueOracle(_valueOracle);
69              emit ValueOracleUpdated(_valueOracle);
70          }
84          function sendTokensToTrustedAddress(address token, uint256 amount, address caller, bytes memory data)
85              external
86              returns (uint256)
87          {
88              emit TransferTokensToTrustedAddress(token, amount, caller, data);
89              (address accountingManager,) = registry.getVaultAddresses(vaultId);
90              if (msg.sender == accountingManager) {
91                  (,,,, address watcherContract,) = registry.getGovernanceAddresses(vaultId);
92      
93                  (uint256 newAmount, bytes memory newData) = abi.decode(data, (uint256, bytes));
94                  Watchers(watcherContract).verifyRemoveLiquidity(amount, newAmount, newData);
95      
96                  IERC20(token).safeTransfer(address(accountingManager), newAmount);
97                  amount = newAmount;
98              } else if (registry.isAnActiveConnector(vaultId, msg.sender) || msg.sender == registry.flashLoan()) {
99                  IERC20(token).safeTransfer(address(msg.sender), amount);
100             } else {
101                 uint256 routeId = abi.decode(data, (uint256));
102                 swapHandler.verifyRoute(routeId, msg.sender);
103                 if (caller != address(this)) revert IConnector_InvalidAddress(caller);
104                 IERC20(token).safeTransfer(msg.sender, amount);
105             }
106             _updateTokenInRegistry(token);
107             return amount;
108         }
122         function transferPositionToAnotherConnector(
123             address[] memory tokens,
124             uint256[] memory amounts,
125             bytes memory data,
126             address connector
127         ) external onlyManager nonReentrant {
128             emit TransferPositionToConnector(tokens, amounts, connector, data);
129             if (registry.isAnActiveConnector(vaultId, connector)) {
130                 IConnector(connector).addLiquidity(tokens, amounts, data);
131             }
132         }
153         function updateTokenInRegistry(address token) public onlyManager {
154             _updateTokenInRegistry(token);
155         }
169         function addLiquidity(address[] memory tokens, uint256[] memory amounts, bytes memory data)
170             external
171             override
172             nonReentrant
173         {
174             if (!registry.isAddressTrusted(vaultId, msg.sender)) {
175                 revert IConnector_InvalidAddress(msg.sender);
176             }
177     
178             for (uint256 i = 0; i < tokens.length; i++) {
179                 // gather all of the tokens
180                 uint256 _balance = IERC20(tokens[i]).balanceOf(address(this));
181                 ITokenTransferCallBack(msg.sender).sendTokensToTrustedAddress(tokens[i], amounts[i], msg.sender, "");
182                 uint256 _balanceAfter = IERC20(tokens[i]).balanceOf(address(this));
183                 if (_balanceAfter < amounts[i] + _balance) {
184                     revert IConnector_InsufficientDepositAmount(_balanceAfter - _balance, amounts[i]);
185                 }
186             }
187             _addLiquidity(tokens, amounts, data); // call the specific implementation if the connector needs to do something after the liquidity is added
188     
189             for (uint256 i = 0; i < tokens.length; i++) {
190                 _updateTokenInRegistry(tokens[i]); // update the token in the registry
191             }
192             emit AddLiquidity(tokens, amounts, data);
193         }
204         function swapHoldings(
205             address[] memory tokensIn,
206             address[] memory tokensOut,
207             uint256[] memory amountsIn,
208             bytes[] memory swapData,
209             uint256[] memory routeIds
210         ) external onlyManager nonReentrant {
211             for (uint256 i = 0; i < tokensIn.length; i++) {
212                 _executeSwap(
213                     SwapRequest(address(this), routeIds[i], amountsIn[i], tokensIn[i], tokensOut[i], swapData[i], true, 0)
214                 );
215                 _updateTokenInRegistry(tokensIn[i]);
216                 _updateTokenInRegistry(tokensOut[i]);
217                 emit SwapHoldings(tokensIn[i], tokensOut[i], amountsIn[i], swapData[i]);
218             }
219         }
232         function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {
233             if (positionTypeId == 0) {
234                 address[] memory tokens = new address[](1);
235                 tokens[0] = abi.decode(data, (address));
236                 return tokens;
237             }
238             return _getUnderlyingTokens(positionTypeId, data);
239         }
249         function getPositionTVL(HoldingPI memory p, address baseToken) public view returns (uint256) {
250             return _getPositionTVL(p, baseToken);
251         }
263         function _getUnderlyingTokens(uint256, bytes memory) public view virtual returns (address[] memory) {
264             return new address[](0);
265         }
271         function _getPositionTVL(HoldingPI memory, address) public view virtual returns (uint256 tvl) {
272             return 0;
273         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


27          function sendTokensToTrustedAddress(address token, uint256 amount, address caller, bytes memory data)
28              external
29              returns (uint256)
30          {
31              if (data.length == 0) {
32                  IERC20(token).safeTransfer(msg.sender, amount);
33                  return amount;
34              }
35              (uint256 amountToSend, uint256 amountToReturn) = abi.decode(data, (uint256, uint256));
36              IERC20(token).safeTransfer(msg.sender, amountToSend);
37              return amountToReturn;
38          }
40          function addLiquidity(address[] memory tokens, uint256[] memory amounts, bytes memory data) external {
41              for (uint256 i = 0; i < tokens.length; i++) {
42                  // gather all of the tokens
43      
44                  ITokenTransferCallBack(msg.sender).sendTokensToTrustedAddress(tokens[i], amounts[i], msg.sender, "");
45              }
46              for (uint256 i = 0; i < tokens.length; i++) {
47                  _updateTokenInRegistry(tokens[i]); // update the token in the registry
48              }
49          }
51          function updatePositionToRegistryUsingType(bytes32 _positionId, bytes memory data, bool remove) external {
52              registry.updateHoldingPosition(vaultId, _positionId, data, "", remove);
53          }
59          function addPositionToRegistryUsingType(uint256 _positionType, bytes memory data) external {
60              registry.updateHoldingPosition(
61                  vaultId, registry.calculatePositionId(address(this), _positionType, ""), data, "", false
62              );
63          }
65          function addPositionToRegistry(bytes memory data) external {
66              registry.updateHoldingPosition(
67                  vaultId, registry.calculatePositionId(address(this), positionType, ""), data, "", false
68              );
69          }
71          function getPositionTVL(HoldingPI memory p, address baseToken) public view returns (uint256) {
72              return 0;
73          }
75          function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {
76              return new address[](0);
77          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


40          function setChainInfo(uint256 chainId, uint32 lzChainId, address lzHelperAddress) public onlyOwner {
41              require(lzHelperAddress != address(0));
42              chainInfo[lzChainId] = ChainInfo(chainId, lzHelperAddress);
43          }
52          function addVaultInfo(uint256 vaultId, uint256 baseChainId, address omniChainManager) public onlyOwner {
53              require(omniChainManager != address(0));
54              vaultIdToVaultInfo[vaultId] = VaultInfo(baseChainId, omniChainManager);
55          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


27          receive() external payable { }
36          function updateMessageSetting(bytes memory _messageSetting) public onlyOwner {
37              messageSetting = _messageSetting;
38          }
51          function setChainInfo(uint256 chainId, uint32 lzChainId, address lzHelperAddress) public onlyOwner {
52              require(lzHelperAddress != address(0));
53              chainInfo[chainId] = ChainInfo(lzChainId, lzHelperAddress);
54          }
63          function addVaultInfo(uint256 vaultId, uint256 baseChainId, address omniChainManager) public onlyOwner {
64              vaultIdToVaultInfo[vaultId] = VaultInfo(baseChainId, omniChainManager);
65          }
75          function updateTVL(uint256 vaultId, uint256 tvl, uint256 updateTime) public {
76              if (msg.sender != vaultIdToVaultInfo[vaultId].omniChainManager) revert InvalidSender();
77      
78              uint32 lzChainId = chainInfo[vaultIdToVaultInfo[vaultId].baseChainId].lzChainId;
79              bytes memory data = abi.encode(vaultId, tvl, updateTime);
80              _lzSend(lzChainId, data, messageSetting, MessagingFee(address(this).balance, 0), payable(address(this))); // TODO: send event here
81          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


32          function updateTVL(uint256 chainId, uint256 tvl, uint256 updateTime) external nonReentrant {
33              if (msg.sender != lzHelper) revert IConnector_InvalidSender();
34      
35              registry.updateHoldingPostionWithTime(
36                  vaultId,
37                  registry.calculatePositionId(address(this), OMNICHAIN_POSITION_ID, abi.encode(chainId)),
38                  "",
39                  abi.encode(tvl),
40                  tvl <= DUST_LEVEL,
41                  updateTime
42              );
43          }
51          function _getPositionTVL(HoldingPI memory position, address) public view override returns (uint256) {
52              uint256 positionTypeId = registry.getPositionBP(vaultId, position.positionId).positionTypeId;
53              if (positionTypeId == OMNICHAIN_POSITION_ID) {
54                  return (abi.decode(position.additionalData, (uint256)));
55              }
56              return 0;
57          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol


19          function getTVL() public view returns (uint256) {
20              (, address baseToken) = registry.getVaultAddresses(vaultId);
21              return TVLHelper.getTVL(vaultId, registry, baseToken);
22          }
28          function updateTVLInfo() external onlyManager {
29              uint256 tvl = getTVL();
30              LZHelperSender(lzHelper).updateTVL(vaultId, tvl, block.timestamp);
31          }
33          function _getPositionTVL(HoldingPI memory position, address base) public view override returns (uint256) {
34              PositionBP memory bp = registry.getPositionBP(vaultId, position.positionId);
35              if (bp.positionTypeId == 0) {
36                  address token = abi.decode(bp.data, (address));
37                  uint256 amount = IERC20(token).balanceOf(address(this));
38                  return _getValue(token, base, amount);
39              }
40              return 0;
41          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


48          function setValueOracle(address _valueOracle) external onlyMaintainerOrEmergency {
49              valueOracle = INoyaValueOracle(_valueOracle);
50              emit SetValueOracle(_valueOracle);
51          }
57          function setGeneralSlippageTolerance(uint256 _slippageTolerance) external onlyMaintainerOrEmergency {
58              genericSlippageTolerance = _slippageTolerance;
59              emit SetSlippageTolerance(address(0), address(0), _slippageTolerance);
60          }
68          function setSlippageTolerance(address _inputToken, address _outputToken, uint256 _slippageTolerance)
69              external
70              onlyMaintainerOrEmergency
71          {
72              slippageTolerance[_inputToken][_outputToken] = _slippageTolerance;
73              emit SetSlippageTolerance(_inputToken, _outputToken, _slippageTolerance);
74          }
80          function addEligibleUser(address _user) external onlyMaintainerOrEmergency {
81              isEligibleToUse[_user] = true;
82              emit AddEligibleUser(_user);
83          }
90          function executeSwap(SwapRequest memory _swapRequest)
91              external
92              payable
93              onlyEligibleUser
94              onlyExistingRoute(_swapRequest.routeId)
95              nonReentrant
96              returns (uint256 _amountOut)
97          {
98              if (_swapRequest.amount == 0) revert InvalidAmount();
99              RouteData memory swapImplInfo = routes[_swapRequest.routeId];
100             if (swapImplInfo.isBridge) revert RouteNotAllowedForThisAction();
101     
102             if (_swapRequest.checkForSlippage && _swapRequest.minAmount == 0) {
103                 // set minAmount so that slippage can be checked
104                 uint256 _slippageTolerance = slippageTolerance[_swapRequest.inputToken][_swapRequest.outputToken];
105                 if (_slippageTolerance == 0) {
106                     _slippageTolerance = genericSlippageTolerance;
107                 }
108                 INoyaValueOracle _priceOracle = INoyaValueOracle(valueOracle);
109                 uint256 _outputTokenValue =
110                     _priceOracle.getValue(_swapRequest.inputToken, _swapRequest.outputToken, _swapRequest.amount);
111     
112                 _swapRequest.minAmount = (((1e6 - _slippageTolerance) * _outputTokenValue) / 1e6);
113             }
114     
115             _amountOut = ISwapAndBridgeImplementation(swapImplInfo.route).performSwapAction(msg.sender, _swapRequest);
116     
117             emit ExecutionCompleted(
118                 _swapRequest.routeId, _swapRequest.amount, _amountOut, _swapRequest.inputToken, _swapRequest.outputToken
119             );
120         }
126         function executeBridge(BridgeRequest calldata _bridgeRequest)
127             external
128             payable
129             onlyEligibleUser
130             onlyExistingRoute(_bridgeRequest.routeId)
131             nonReentrant
132         {
133             RouteData memory bridgeImplInfo = routes[_bridgeRequest.routeId];
134     
135             if (!bridgeImplInfo.isBridge) revert RouteNotAllowedForThisAction();
136     
137             ISwapAndBridgeImplementation(bridgeImplInfo.route).performBridgeAction(msg.sender, _bridgeRequest);
138     
139             emit BridgeExecutionCompleted(_bridgeRequest);
140         }
147         function addRoutes(RouteData[] memory _routes) public onlyMaintainer {
148             for (uint256 i = 0; i < _routes.length;) {
149                 routes.push(_routes[i]);
150                 emit NewRouteAdded(i, _routes[i].route, _routes[i].isEnabled, _routes[i].isBridge);
151                 unchecked {
152                     i++;
153                 }
154             }
155         }
158         function setEnableRoute(uint256 _routeId, bool enable) external onlyMaintainerOrEmergency {
159             routes[_routeId].isEnabled = enable;
160             emit RouteUpdate(_routeId, false);
161         }
164         function verifyRoute(uint256 _routeId, address addr) external view onlyExistingRoute(_routeId) {
165             if (routes[_routeId].route != addr) {
166                 revert RouteNotFound();
167             }
168         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


45          function addHandler(address _handler, bool state) external onlyOwner {
46              isHandler[_handler] = state;
47              emit AddedHandler(_handler, state);
48          }
55          function addChain(uint256 _chainId, bool state) external onlyOwner {
56              isChainSupported[_chainId] = state;
57              emit AddedChain(_chainId, state);
58          }
65          function addBridgeBlacklist(string memory bridgeName, bool state) external onlyOwner {
66              isBridgeWhiteListed[bridgeName] = state;
67              emit AddedBridgeBlacklist(bridgeName, state);
68          }
77          function performSwapAction(address caller, SwapRequest calldata _request)
78              external
79              payable
80              override
81              onlyHandler
82              returns (uint256)
83          {
84              require(verifySwapData(_request), "LifiImplementation: INVALID_SWAP_DATA");
85              uint256 balanceOut0 = 0;
86              if (_request.outputToken == address(0)) {
87                  balanceOut0 = address(_request.from).balance;
88              } else {
89                  balanceOut0 = IERC20(_request.outputToken).balanceOf(_request.from);
90              }
91              _forward(IERC20(_request.inputToken), _request.from, _request.amount, caller, _request.data, _request.routeId);
92              uint256 balanceOut1 = 0;
93              if (_request.outputToken == address(0)) {
94                  balanceOut1 = address(_request.from).balance;
95              } else {
96                  balanceOut1 = IERC20(_request.outputToken).balanceOf(_request.from);
97              }
98      
99              emit Swapped(balanceOut0, balanceOut1, _request.outputToken);
100     
101             return balanceOut1 - balanceOut0;
102         }
110         function verifySwapData(SwapRequest calldata _request) public view override returns (bool) {
111             bytes4 selector = bytes4(_request.data[:4]);
112             if (selector != LI_FI_GENERIC_SWAP_SELECTOR) {
113                 revert InvalidSelector();
114             }
115             (address sendingAssetId, uint256 amount, address from, address receivingAssetId, uint256 receivingAmount) =
116                 ILiFi(lifi).extractGenericSwapParameters(_request.data);
117     
118             if (from != _request.from) revert InvalidReceiver(from, _request.from);
119             if (receivingAmount < _request.minAmount) revert InvalidMinAmount();
120             if (sendingAssetId != _request.inputToken) revert InvalidInputToken();
121             if (receivingAssetId != _request.outputToken) revert InvalidOutputToken();
122             if (amount != _request.amount) revert InvalidAmount();
123     
124             return true;
125         }
133         function performBridgeAction(address caller, BridgeRequest calldata _request)
134             external
135             payable
136             override
137             onlyHandler
138         {
139             verifyBridgeData(_request);
140             _forward(IERC20(_request.inputToken), _request.from, _request.amount, caller, _request.data, _request.routeId);
141             emit Bridged(_request.from, _request.inputToken, _request.amount, _request.data);
142         }
150         function verifyBridgeData(BridgeRequest calldata _request) public view override returns (bool) {
151             ILiFi.BridgeData memory bridgeData = ILiFi(lifi).extractBridgeData(_request.data);
152     
153             if (isBridgeWhiteListed[bridgeData.bridge] == false) revert BridgeBlacklisted();
154             if (isChainSupported[bridgeData.destinationChainId] == false) revert InvalidChainId();
155             if (bridgeData.sendingAssetId != _request.inputToken) revert InvalidFromToken();
156             if (bridgeData.receiver != _request.receiverAddress) {
157                 revert InvalidReceiver(bridgeData.receiver, _request.receiverAddress);
158             }
159             if (bridgeData.minAmount > _request.amount) revert InvalidMinAmount();
160             if (bridgeData.destinationChainId != _request.destChainId) revert InvalidToChainId();
161     
162             return true;
163         }
193         function rescueFunds(address token, address userAddress, uint256 amount) external onlyOwner {
194             if (token == address(0)) {
195                 (bool success,) = payable(userAddress).call{ value: amount }("");
196                 require(success, "Transfer failed.");
197             } else {
198                 IERC20(token).safeTransfer(userAddress, amount);
199             }
200             emit Rescued(token, userAddress, amount);
201         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


37          function updateDefaultPriceSource(address[] calldata baseCurrencies, INoyaValueOracle[] calldata oracles)
38              public
39              onlyMaintainer
40          {
41              for (uint256 i = 0; i < baseCurrencies.length; i++) {
42                  defaultPriceSource[baseCurrencies[i]] = oracles[i];
43              }
44              emit UpdatedDefaultPriceSource(baseCurrencies, oracles);
45          }
51          function updateAssetPriceSource(address[] calldata asset, address[] calldata baseToken, address[] calldata oracle)
52              external
53              onlyMaintainer
54          {
55              for (uint256 i = 0; i < oracle.length; i++) {
56                  priceSource[asset[i]][baseToken[i]] = INoyaValueOracle(oracle[i]);
57              }
58              emit UpdatedAssetPriceSource(asset, baseToken, oracle);
59          }
61          function updatePriceRoute(address asset, address base, address[] calldata s) external onlyMaintainer {
62              priceRoutes[asset][base] = s;
63              emit UpdatedPriceRoute(asset, base, s);
64          }
71          function getValue(address asset, address baseToken, uint256 amount) public view returns (uint256) {
72              if (asset == baseToken || amount == 0) {
73                  return amount;
74              }
75      
76              address[] memory sources = priceRoutes[asset][baseToken];
77      
78              return _getValue(asset, baseToken, amount, sources);
79          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


56          function updateChainlinkPriceAgeThreshold(uint256 _chainlinkPriceAgeThreshold) external onlyMaintainer {
57              if (_chainlinkPriceAgeThreshold <= 1 hours || _chainlinkPriceAgeThreshold >= 10 days) {
58                  revert NoyaChainlinkOracle_INVALID_INPUT();
59              }
60              chainlinkPriceAgeThreshold = _chainlinkPriceAgeThreshold;
61              emit ChainlinkPriceAgeThresholdUpdated(_chainlinkPriceAgeThreshold);
62          }
70          function setAssetSources(address[] calldata assets, address[] calldata baseTokens, address[] calldata sources)
71              external
72              onlyMaintainer
73          {
74              for (uint256 i = 0; i < assets.length; i++) {
75                  assetsSources[assets[i]][baseTokens[i]] = sources[i];
76                  emit AssetSourceUpdated(assets[i], baseTokens[i], sources[i]);
77              }
78          }
89          function getValue(address asset, address baseToken, uint256 amount) public view returns (uint256) {
90              if (asset == baseToken) {
91                  return amount;
92              }
93      
94              (address primarySource, bool isPrimaryInverse) = getSourceOfAsset(asset, baseToken);
95              if (primarySource == address(0)) {
96                  revert NoyaChainlinkOracle_PRICE_ORACLE_UNAVAILABLE(asset, baseToken, primarySource);
97              }
98              address decimalsSource = isPrimaryInverse ? baseToken : asset;
99              decimalsSource = decimalsSource == ETH || decimalsSource == USD ? primarySource : decimalsSource;
100             return getValueFromChainlinkFeed(
101                 AggregatorV3Interface(primarySource), amount, getTokenDecimals(decimalsSource), isPrimaryInverse
102             );
103         }
115         function getValueFromChainlinkFeed(
116             AggregatorV3Interface source,
117             uint256 amountIn,
118             uint256 sourceTokenUnit,
119             bool isInverse
120         ) public view returns (uint256) {
121             int256 price;
122             uint256 updatedAt;
123             (, price,, updatedAt,) = source.latestRoundData();
124             uint256 uintprice = uint256(price);
125             if (block.timestamp - updatedAt > chainlinkPriceAgeThreshold) {
126                 revert NoyaChainlinkOracle_DATA_OUT_OF_DATE();
127             }
128             if (price <= 0) {
129                 revert NoyaChainlinkOracle_PRICE_ORACLE_UNAVAILABLE(address(source), address(0), address(0));
130             }
131             if (isInverse) {
132                 return (amountIn * sourceTokenUnit) / uintprice;
133             }
134             return (amountIn * uintprice) / (sourceTokenUnit);
135         }
138         function getTokenDecimals(address token) public view returns (uint256) {
139             uint256 decimals = IERC20Metadata(token).decimals();
140             return 10 ** decimals;
141         }
143         function getSourceOfAsset(address asset, address baseToken) public view returns (address source, bool isInverse) {
144             if (assetsSources[asset][baseToken] != address(0)) {
145                 return (assetsSources[asset][baseToken], false);
146             } else if (assetsSources[baseToken][asset] != address(0)) {
147                 return (assetsSources[baseToken][asset], true);
148             }
149             return (address(0), false);
150         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


38          function setPeriod(uint32 _period) external onlyMaintainer {
39              if (_period == 0) revert INoyaValueOracle_InvalidInput();
40              period = _period;
41              emit NewPeriod(_period);
42          }
48          function addPool(address tokenIn, address baseToken, uint24 fee) external onlyMaintainer {
49              address pool = IUniswapV3Factory(factory).getPool(tokenIn, baseToken, fee);
50              require(pool != address(0), "pool doesn't exist");
51              assetToBaseToPool[tokenIn][baseToken] = pool;
52              emit PoolsForAsset(tokenIn, baseToken, pool);
53          }
60          function getValue(address tokenIn, address baseToken, uint256 amount) public view returns (uint256 _amountOut) {
61              uint128 amountIn128 = uint128(amount);
62              address pool = assetToBaseToPool[tokenIn][baseToken];
63              if (pool == address(0)) {
64                  pool = assetToBaseToPool[baseToken][tokenIn];
65              }
66              if (pool == address(0)) revert INoyaOracle_ValueOracleUnavailable(tokenIn, baseToken);
67      
68              // Code copied from OracleLibrary.sol, consult()
69              uint32[] memory secondsAgos = new uint32[](2);
70              secondsAgos[0] = period;
71              secondsAgos[1] = 0;
72      
73              // Get the tick cumulatives from the pool for the periods
74              (int56[] memory tickCumulatives,) = IUniswapV3Pool(pool).observe(secondsAgos);
75      
76              // Calculate the delta of the tick cumulatives
77              int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];
78      
79              // Calculate the time-weighted average tick
80              // int56 / uint32 = int24
81              int24 timeWeightedAverageTick = int24(tickCumulativesDelta / int56(int32(period)));
82              if (tickCumulativesDelta < 0 && (tickCumulativesDelta % int56(int32(period)) != 0)) {
83                  timeWeightedAverageTick--;
84              }
85              _amountOut = OracleLibrary.getQuoteAtTick(timeWeightedAverageTick, amountIn128, tokenIn, baseToken);
86          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/WETH_Oracle.sol


5           function latestRoundData()
6               external
7               view
8               returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)
9           {
10              return (0, 1e18, 0, block.timestamp, 0);
11          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/WETH_Oracle.sol#L0:0

</details>

## NC059 - Consider adding formal verification proofs:

Consider using formal verification to mathematically prove that your code does what is intended, and does not have any edge cases with unexpected behavior. The solidity compiler itself has this functionality [built in based off of SMTChecker](https://docs.soliditylang.org/en/latest/smtchecker.html#smtchecker-and-formal-verification).


```solidity
File: Various Files


None

```

## NC060 - Common functions should be refactored to a common base contract:

The functions below have the same implementation as is seen in other files. The functions should be refactored into functions of a common base contract.


<details>
<summary>Click to show 4 findings</summary>

```solidity
File: contracts/connectors/SNXConnector.sol


/// @audit seen in hottings/contracts/connectors/AaveConnector.sol
    function _getUnderlyingTokens(uint256, bytes memory) public pure override returns (address[] memory) {
        return new address[](0);
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L128:130

```solidity
File: contracts/connectors/MaverickConnector.sol


/// @audit seen in hottings/contracts/connectors/LidoConnector.sol
    receive() external payable { }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L56:56

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


/// @audit seen in hottings/contracts/connectors/LidoConnector.sol
    receive() external payable { }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L27:27

```solidity
File: contracts/helpers/ConnectorMock2.sol


/// @audit seen in hottings/contracts/helpers/BaseConnector.sol
    function _updateTokenInRegistry(address token) internal {
        _updateTokenInRegistry(token, IERC20(token).balanceOf(address(this)) == 0);
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L91:93

</details>

## NC061 - Polymorphic functions make security audits more time-consuming and error-prone:

The instances below point to one of two functions with the same name. Consider naming each function differently, in order to make code navigation and analysis easier.


<details>
<summary>Click to show 6 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


705         function deposit(uint256 assets, address receiver) public override returns (uint256) {
697         function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


335         function updateHoldingPosition(


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


184         function totalLpBalanceOf(bytes32 poolId) public view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


158         function _updateTokenInRegistry(address token) internal {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


91          function _updateTokenInRegistry(address token) internal {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


95          function _getValue(address quotingToken, address baseToken, uint256 amount) internal view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

</details>

## NC062 - Event names should use CamelCase:

According to the Solidity [style guide](https://docs.soliditylang.org/en/latest/style-guide.html#event-names) event names should be in `CamelCase`.


```solidity
File: contracts/connectors/PendleConnector.sol


41          event SwapYTForSY(address market, uint256 exactYTIn, uint256 min, LimitOrderData orderData);
36          event MintPTAndYT(address market, uint256 syAmount);
40          event SwapYTForPT(address market, uint256 exactYTIn, uint256 min, ApproxParams guess);
42          event SwapExactPTForSY(address market, uint256 exactPTIn, bytes swapData, uint256 minSY);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

## NC063 - Consider using `AccessControlDefaultAdminRules` rather than `AccessControl`:

`AccessControlDefaultAdminRules` implements multiple [security best practices](https://docs.openzeppelin.com/contracts/4.x/api/access#AccessControlDefaultAdminRules) on top of the normal `AccessControl` rules, so consider using it instead.


```solidity
File: contracts/accountingManager/Registry.sol


12      contract PositionRegistry is AccessControl, IPositionRegistry, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

## NC064 - Missing timelock for critical parameter change:

Timelocks prevent users from being surprised by changes.


<details>
<summary>Click to show 5 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


143             withdrawFeeReceiver = _withdrawFeeReceiver;
144             performanceFeeReceiver = _performanceFeeReceiver;
145             managementFeeReceiver = _managementFeeReceiver;
177             withdrawFee = _withdrawFee;
178             performanceFee = _performanceFee;
179             managementFee = _managementFee;
668             depositLimitPerTransaction = _depositLimitPerTransaction;
669             depositLimitTotalAmount = _depositTotalAmount;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


81              maxNumHoldingPositions = _maxNumHoldingPositions;
86              flashLoan = _flashLoan;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


65              threshold = _threshold;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


49              valueOracle = INoyaValueOracle(_valueOracle);
58              genericSlippageTolerance = _slippageTolerance;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


40              period = _period;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## NC065 - Setters should prevent re-setting of the same value:

This especially problematic when the setter also emits the same value, which may be confusing to offline parsers.


<details>
<summary>Click to show 9 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


135         function setFeeReceivers(
136             address _withdrawFeeReceiver,
137             address _performanceFeeReceiver,
138             address _managementFeeReceiver
139         ) public onlyMaintainer {
140             require(_withdrawFeeReceiver != address(0));
141             require(_performanceFeeReceiver != address(0));
142             require(_managementFeeReceiver != address(0));
143             withdrawFeeReceiver = _withdrawFeeReceiver;
144             performanceFeeReceiver = _performanceFeeReceiver;
145             managementFeeReceiver = _managementFeeReceiver;
146             emit FeeRecepientsChanged(_withdrawFeeReceiver, _performanceFeeReceiver, _managementFeeReceiver);
147         }
170         function setFees(uint256 _withdrawFee, uint256 _performanceFee, uint256 _managementFee) public onlyMaintainer {
171             if (
172                 _withdrawFee > WITHDRAWAL_MAX_FEE || _performanceFee > PERFORMANCE_MAX_FEE
173                     || _managementFee > MANAGEMENT_MAX_FEE
174             ) {
175                 revert NoyaAccounting_INVALID_FEE();
176             }
177             withdrawFee = _withdrawFee;
178             performanceFee = _performanceFee;
179             managementFee = _managementFee;
180             emit FeeRatesChanged(_withdrawFee, _performanceFee, _managementFee);
181         }
667         function setDepositLimits(uint256 _depositLimitPerTransaction, uint256 _depositTotalAmount) public onlyMaintainer {
668             depositLimitPerTransaction = _depositLimitPerTransaction;
669             depositLimitTotalAmount = _depositTotalAmount;
670             emit SetDepositLimits(_depositLimitPerTransaction, _depositTotalAmount);
671         }
673         function changeDepositWaitingTime(uint256 _depositWaitingTime) public onlyMaintainer {
674             depositWaitingTime = _depositWaitingTime;
675             emit SetDepositWaitingTime(_depositWaitingTime);
676         }
678         function changeWithdrawWaitingTime(uint256 _withdrawWaitingTime) public onlyMaintainer {
679             withdrawWaitingTime = _withdrawWaitingTime;
680             emit SetWithdrawWaitingTime(_withdrawWaitingTime);
681         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


79          function setMaxNumHoldingPositions(uint256 _maxNumHoldingPositions) external onlyRole(MAINTAINER_ROLE) {
80              require(_maxNumHoldingPositions <= MAX_NUM_HOLDING_POSITIONS);
81              maxNumHoldingPositions = _maxNumHoldingPositions;
82          }
84          function setFlashLoanAddress(address _flashLoan) external onlyRole(MAINTAINER_ROLE) {
85              emit updateFlashloanAddress(_flashLoan, flashLoan);
86              flashLoan = _flashLoan;
87          }
158         function changeVaultAddresses(
159             uint256 vaultId,
160             address _governer,
161             address _maintainer,
162             address _maintainerWithoutTimelock,
163             address _keeperContract,
164             address _watcher,
165             address _emergency
166         ) external onlyVaultGoverner(vaultId) vaultExists(vaultId) {
167             require(_governer != address(0));
168             require(_maintainer != address(0));
169             require(_keeperContract != address(0));
170             require(_watcher != address(0));
171     
172             vaults[vaultId].governer = _governer;
173             vaults[vaultId].maintainer = _maintainer;
174             vaults[vaultId].maintainerWithoutTimeLock = _maintainerWithoutTimelock;
175             vaults[vaultId].keeperContract = _keeperContract;
176             vaults[vaultId].watcherContract = _watcher;
177             vaults[vaultId].emergency = _emergency;
178             emit VaultAddressesChanged(
179                 vaultId, _governer, _maintainer, _maintainerWithoutTimelock, _keeperContract, _watcher, _emergency
180             );
181         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


63          function setThreshold(uint8 _threshold) public onlyOwner {
64              require(_threshold <= numOwners && _threshold > 1);
65              threshold = _threshold;
66              emit UpdateThreshold(_threshold);
67          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


40          function setChainInfo(uint256 chainId, uint32 lzChainId, address lzHelperAddress) public onlyOwner {
41              require(lzHelperAddress != address(0));
42              chainInfo[lzChainId] = ChainInfo(chainId, lzHelperAddress);
43          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


51          function setChainInfo(uint256 chainId, uint32 lzChainId, address lzHelperAddress) public onlyOwner {
52              require(lzHelperAddress != address(0));
53              chainInfo[chainId] = ChainInfo(lzChainId, lzHelperAddress);
54          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


48          function setValueOracle(address _valueOracle) external onlyMaintainerOrEmergency {
49              valueOracle = INoyaValueOracle(_valueOracle);
50              emit SetValueOracle(_valueOracle);
51          }
57          function setGeneralSlippageTolerance(uint256 _slippageTolerance) external onlyMaintainerOrEmergency {
58              genericSlippageTolerance = _slippageTolerance;
59              emit SetSlippageTolerance(address(0), address(0), _slippageTolerance);
60          }
68          function setSlippageTolerance(address _inputToken, address _outputToken, uint256 _slippageTolerance)
69              external
70              onlyMaintainerOrEmergency
71          {
72              slippageTolerance[_inputToken][_outputToken] = _slippageTolerance;
73              emit SetSlippageTolerance(_inputToken, _outputToken, _slippageTolerance);
74          }
158         function setEnableRoute(uint256 _routeId, bool enable) external onlyMaintainerOrEmergency {
159             routes[_routeId].isEnabled = enable;
160             emit RouteUpdate(_routeId, false);
161         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


185         function _setAllowance(IERC20 token, address spender, uint256 amount) internal {
186             token.forceApprove(spender, amount);
187         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


70          function setAssetSources(address[] calldata assets, address[] calldata baseTokens, address[] calldata sources)
71              external
72              onlyMaintainer
73          {
74              for (uint256 i = 0; i < assets.length; i++) {
75                  assetsSources[assets[i]][baseTokens[i]] = sources[i];
76                  emit AssetSourceUpdated(assets[i], baseTokens[i], sources[i]);
77              }
78          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


38          function setPeriod(uint32 _period) external onlyMaintainer {
39              if (_period == 0) revert INoyaValueOracle_InvalidInput();
40              period = _period;
41              emit NewPeriod(_period);
42          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## NC066 - Consider splitting long calculations:

The longer a string of operations is, the harder it is to understand it. Consider splitting the full calculation into more steps, with more descriptive temporary variable names, and add extensive comments.


```solidity
File: contracts/accountingManager/AccountingManager.sol


517             uint256 managementFeeAmount =
518                 (timePassed * managementFee * (totalShares - currentFeeShares)) / FEE_PRECISION / 365 days;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

## NC067 - Use of override is unnecessary:

Starting with Solidity version 0.8.8, using the override keyword when the function solely overrides an interface function, and the function doesn't exist in multiple base contracts, is unnecessary.


<details>
<summary>Click to show 49 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


    function _update(address from, address to, uint256 amount) internal override {
        if (!(from == address(0)) && balanceOf(from) < amount + withdrawRequestsByAddress[from]) {
            revert NoyaAccounting_INSUFFICIENT_FUNDS(balanceOf(from), amount, withdrawRequestsByAddress[from]);
        }
        super._update(from, to, amount);
    }

    function totalAssets() public view override returns (uint256) {
        return TVL();
    }

    function mint(uint256 shares, address receiver) public override returns (uint256) {
        revert NoyaAccounting_NOT_ALLOWED();
    }

    function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256) {
        revert NoyaAccounting_NOT_ALLOWED();
    }

    function redeem(uint256 shares, address receiver, address shareOwner) public override returns (uint256) {
        revert NoyaAccounting_NOT_ALLOWED();
    }

    function deposit(uint256 assets, address receiver) public override returns (uint256) {
        revert NoyaAccounting_NOT_ALLOWED();
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L705:707

```solidity
File: contracts/connectors/AaveConnector.sol


    function _getPositionTVL(HoldingPI memory, address base) public view override returns (uint256 tvl) {
        (uint256 totalCollateralBase, uint256 totalDebtBase,,,,) = IPool(pool).getUserAccountData(address(this));
        uint256 poolBaseAmount = totalCollateralBase - totalDebtBase;
        return valueOracle.getValue(poolBaseToken, base, poolBaseAmount);
    }

    function _getUnderlyingTokens(uint256, bytes memory) public pure override returns (address[] memory) {
        return new address[](0);
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L120:122

```solidity
File: contracts/connectors/AerodromeConnector.sol


    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {
        PositionBP memory pBP = registry.getPositionBP(vaultId, p.positionId);
        (address pool) = abi.decode(pBP.data, (address));
        uint256 balance = IERC20(pool).balanceOf(address(this));
        uint256 totalSupply = IERC20(pool).totalSupply();
        (uint256 reserve0, uint256 reserve1,) = IPool(pool).getReserves();
        uint256 amount0 = balance * reserve0 / totalSupply;
        uint256 amount1 = balance * reserve1 / totalSupply;
        return _getValue(IPool(pool).token0(), base, amount0) + _getValue(IPool(pool).token1(), base, amount1);
    }

    function _getUnderlyingTokens(uint256 p, bytes memory data) public view override returns (address[] memory) {
        address[] memory tokens = new address[](2);
        (address pool) = abi.decode(data, (address));
        tokens[0] = IPool(pool).token0();
        tokens[1] = IPool(pool).token1();
        return tokens;
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L117:123

```solidity
File: contracts/connectors/BalancerConnector.sol


    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {
        PositionBP memory PTI = registry.getPositionBP(vaultId, p.positionId);
        PoolInfo memory pool = abi.decode(PTI.additionalData, (PoolInfo));
        uint256 lpBalance = totalLpBalanceOf(pool);
        (, uint256[] memory _tokenBalances,) = IBalancerVault(balancerVault).getPoolTokens(pool.poolId);
        uint256 _totalSupply = IERC20(pool.pool).totalSupply();

        uint256 _weight = pool.weights[pool.tokenIndex];

        uint256 token1bal = valueOracle.getValue(pool.tokens[pool.tokenIndex], base, _tokenBalances[pool.tokenIndex]);
        return (((1e18 * token1bal * lpBalance) / _weight) / _totalSupply);
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L162:173

```solidity
File: contracts/connectors/CamelotConnector.sol


    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
        (address tokenA, address tokenB) =
            abi.decode(registry.getPositionBP(vaultId, p.positionId).data, (address, address));
        address pool = factory.getPair(tokenA, tokenB);
        uint256 totalSupply = IERC20(pool).totalSupply();
        (uint256 reserves0, uint256 reserves1,,) = ICamelotPair(pool).getReserves();

        uint256 balanceThis = IERC20(pool).balanceOf(address(this));
        return balanceThis * (_getValue(tokenA, base, reserves0) + _getValue(tokenB, base, reserves1)) / totalSupply;
    }

    function _getUnderlyingTokens(uint256 id, bytes memory data) public view override returns (address[] memory) {
        (address tokenA, address tokenB) = abi.decode(data, (address, address));
        address[] memory tokens = new address[](2);
        tokens[0] = tokenA;
        tokens[1] = tokenB;
        return tokens;
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L99:105

```solidity
File: contracts/connectors/CompoundConnector.sol


    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {
        address market = abi.decode(registry.getPositionBP(vaultId, p.positionId).data, (address));

        uint256 positiveBalance = getCollBlanace(IComet(market), false);
        uint256 negativeBalance = getBorrowBalanceInBase(IComet(market));
        uint256 balance = positiveBalance - negativeBalance;
        return (valueOracle.getValue(IComet(market).baseToken(), base, balance));
    }

    function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {
        return new address[](0);
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L134:136

```solidity
File: contracts/connectors/CurveConnector.sol


    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
        PositionBP memory PTI = registry.getPositionBP(vaultId, p.positionId);
        PoolInfo memory poolInfo = abi.decode(PTI.additionalData, (PoolInfo));
        uint256 lpBalance = totalLpBalanceOf(poolInfo);
        (uint256 amount, address token) = LPToUnder(poolInfo, lpBalance);
        return _getValue(token, base, amount);
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L265:271

```solidity
File: contracts/connectors/Dolomite.sol


    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
        uint256 accountId = abi.decode(p.data, (uint256));

        (uint256[] memory markets, address[] memory tokens,, Types.Wei[] memory amounts) =
            dolomiteMargin.getAccountBalances(Info(address(this), accountId));
        uint256 totalDebt = 0;
        uint256 totalCollateral = 0;
        for (uint256 i = 0; i < markets.length; i++) {
            uint256 value = valueOracle.getValue(tokens[i], base, amounts[i].value);
            if (amounts[i].sign) {
                totalCollateral += value;
            } else {
                totalDebt += value;
            }
        }
        return totalCollateral - totalDebt;
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L106:122

```solidity
File: contracts/connectors/FraxConnector.sol


    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
        PositionBP memory positionInfo = registry.getPositionBP(vaultId, p.positionId);
        IFraxPair pool = IFraxPair(abi.decode(positionInfo.data, (address)));
        uint256 collateralAmount = pool.userCollateralBalance(address(this));
        uint256 borrowerShares = pool.userBorrowShares(address(this));
        uint256 _borrowerAmount = pool.toBorrowAmount(borrowerShares, true);

        uint256 borrowValue = _getValue(pool.asset(), base, _borrowerAmount);
        uint256 collateralValue = _getValue(pool.collateralContract(), base, collateralAmount);
        if (collateralValue > borrowValue) {
            return collateralValue - borrowValue;
        }
        return tvl;
    }

    function _getUnderlyingTokens(uint256 p, bytes memory data) public view override returns (address[] memory) {
        address[] memory tokens = new address[](2);
        (address pool) = abi.decode(data, (address));
        tokens[0] = IFraxPair(pool).collateralContract();
        tokens[1] = IFraxPair(pool).asset();
        return tokens;
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L142:148

```solidity
File: contracts/connectors/GearBoxV3.sol


    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
        address creditAccount = abi.decode(p.data, (address));
        PositionBP memory positionInfo = registry.getPositionBP(vaultId, p.positionId);
        ICreditFacadeV3 facade = ICreditFacadeV3(abi.decode(positionInfo.data, (address)));
        CollateralDebtData memory d = ICreditManagerV3(facade.creditManager()).calcDebtAndCollateral(
            creditAccount, CollateralCalcTask.DEBT_COLLATERAL_SAFE_PRICES
        );
        if (d.totalDebtUSD > d.totalValueUSD) {
            return 0;
        }
        return _getValue(address(840), base, (d.totalValueUSD - d.totalDebtUSD));
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L93:104

```solidity
File: contracts/connectors/LidoConnector.sol


    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
        (uint256 amount) = abi.decode(p.additionalData, (uint256));
        return _getValue(steth, base, amount);
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L91:94

```solidity
File: contracts/connectors/MaverickConnector.sol


    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
        PositionBP memory position = registry.getPositionBP(vaultId, p.positionId);
        IMaverickPool pool = abi.decode(position.data, (IMaverickPool));

        (uint256 a, uint256 b) = positionInspector.addressBinReservesAllKindsAllTokenIds(address(this), pool);
        return _getValue(pool.tokenA(), base, a) + _getValue(pool.tokenB(), base, b);
    }

    function _getUnderlyingTokens(uint256 id, bytes memory data) public view override returns (address[] memory) {
        (address pool) = abi.decode(data, (address));
        address[] memory tokens = new address[](2);
        tokens[0] = IMaverickPool(pool).tokenA();
        tokens[1] = IMaverickPool(pool).tokenB();
        return tokens;
    }

    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {
        return this.onERC721Received.selector;
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L149:151

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
        PositionBP memory positionInfo = registry.getPositionBP(vaultId, p.positionId);
        if (positionInfo.positionTypeId == MORPHO_POSITION_ID) {
            Id id = abi.decode(positionInfo.data, (Id));
            MarketParams memory params = morphoBlue.idToMarketParams(id);
            Market memory market = morphoBlue.market(id);
            Position memory pos = morphoBlue.position(id, address(this));
            uint256 borrowAmount =
                uint256(pos.borrowShares).toAssetsUp(market.totalBorrowAssets, market.totalBorrowShares);
            uint256 supplyAmount =
                uint256(pos.supplyShares).toAssetsUp(market.totalSupplyAssets, market.totalSupplyShares);
            tvl = _getValue(
                params.loanToken,
                base,
                supplyAmount + borrowAmount + convertCToL(pos.collateral, params.oracle, params.collateralToken)
            );
        }
    }

    function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {
        Id id = abi.decode(data, (Id));
        MarketParams memory params = morphoBlue.idToMarketParams(id);
        address[] memory tokens = new address[](2);
        tokens[0] = params.loanToken;
        tokens[1] = params.collateralToken;
        return tokens;
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L141:148

```solidity
File: contracts/connectors/PendleConnector.sol


    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
        PositionBP memory positionInfo = registry.getPositionBP(vaultId, p.positionId);
        if (positionInfo.positionTypeId == PENDLE_POSITION_ID) {
            uint256 underlyingBalance = 0;
            address market = abi.decode(positionInfo.data, (address));
            (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
            (, address _underlyingToken,) = _SY.assetInfo();

            uint256 SYAmount = _SY.balanceOf(address(this));

            //
            uint256 lpBalance =
                IERC20(market).balanceOf(address(this)) + pendleMarketDepositHelper.balance(market, address(this));
            if (lpBalance > 0) {
                SYAmount += lpBalance * IPMarket(market).getLpToAssetRate(10) / 1e18;
            }

            uint256 PTAmount = _PT.balanceOf(address(this));
            if (PTAmount > 0) SYAmount += PTAmount * IPMarket(market).getPtToAssetRate(10) / 1e18;

            uint256 YTBalance = _YT.balanceOf(address(this));
            if (YTBalance > 0) SYAmount += getYTValue(market, YTBalance);

            if (SYAmount > 0) underlyingBalance += SYAmount * _SY.exchangeRate() / 1e18;

            tvl = valueOracle.getValue(_underlyingToken, base, underlyingBalance);
        }
        return tvl;
    }

    function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {
        address market = abi.decode(data, (address));
        (IPStandardizedYield SY,,) = IPMarket(market).readTokens();
        address[] memory tokens = new address[](1);
        (, tokens[0],) = SY.assetInfo();
        return tokens;
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L311:317

```solidity
File: contracts/connectors/PrismaConnector.sol


    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
        PositionBP memory positionInfo = registry.getPositionBP(vaultId, p.positionId);
        if (positionInfo.positionTypeId == PRISMA_POSITION_ID) {
            (address zap, address troveManager) = abi.decode(positionInfo.data, (address, address));
            IBorrowerOperations borrowerOperations = IStakeNTroveZap(zap).borrowerOps();
            address collateral = borrowerOperations.troveManagersData(troveManager).collateralToken;
            address debTtoken = ITroveManager(troveManager).debtToken();
            (uint256 collateralBalance, uint256 debtBalance) =
                ITroveManager(troveManager).getTroveCollAndDebt(address(this));
            return _getValue(collateral, base, collateralBalance) - _getValue(debTtoken, base, debtBalance);
        }
    }

    function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {
        (address zap, address troveManager) = abi.decode(data, (address, address));
        IBorrowerOperations borrowerOperations = IStakeNTroveZap(zap).borrowerOps();
        address collateral = borrowerOperations.troveManagersData(troveManager).collateralToken;
        address debTtoken = ITroveManager(troveManager).debtToken();
        address[] memory tokens = new address[](2);
        tokens[0] = collateral;
        tokens[1] = debTtoken;
        return tokens;
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L164:173

```solidity
File: contracts/connectors/SNXConnector.sol


    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
        (uint128 accountId, address collateralType) = abi.decode(p.data, (uint128, address));
        (uint256 totalDeposited, uint256 totalAssigned, uint256 totalLocked) =
            SNXCoreProxy.getAccountCollateral(accountId, collateralType);
        tvl = _getValue(collateralType, base, totalDeposited + totalAssigned);
    }

    function _getUnderlyingTokens(uint256, bytes memory) public pure override returns (address[] memory) {
        return new address[](0);
    }

    function onERC721Received(address, address, uint256, bytes memory) external pure override returns (bytes4) {
        return this.onERC721Received.selector;
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L64:66

```solidity
File: contracts/connectors/SiloConnector.sol


    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
        PositionBP memory bp = registry.getPositionBP(vaultId, p.positionId);
        (address siloToken) = abi.decode(bp.data, (address));
        ISilo silo = ISilo(siloRepository.getSilo(siloToken));
        (address[] memory assets, IBaseSilo.AssetStorage[] memory assetsS) = silo.getAssetsWithState();
        uint256 totalDepositAmount = 0;
        uint256 totalBAmount = 0;
        for (uint256 i = 0; i < assets.length; i++) {
            uint256 depositAmount = IERC20(assetsS[i].collateralToken).balanceOf(address(this));
            depositAmount += IERC20(assetsS[i].collateralOnlyToken).balanceOf(address(this));
            uint256 borrowAmount = IERC20(assetsS[i].debtToken).balanceOf(address(this));
            if (depositAmount == 0 && borrowAmount == 0) {
                continue;
            }
            uint256 price = _getValue(assets[i], base, 1e18);
            totalDepositAmount += depositAmount * price / 1e18;
            totalBAmount += borrowAmount * price / 1e18;
        }
        tvl = totalDepositAmount - totalBAmount;
    }

    function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {
        (address siloToken) = abi.decode(data, (address));
        ISilo silo = ISilo(siloRepository.getSilo(siloToken));
        (address[] memory assets,) = silo.getAssetsWithState();
        return assets;
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L143:148

```solidity
File: contracts/connectors/StargateConnector.sol


    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
        PositionBP memory pBP = registry.getPositionBP(vaultId, p.positionId);
        uint256 poolId = abi.decode(pBP.data, (uint256));
        address lpAddress = LPStaking.poolInfo(poolId).lpToken;
        uint256 lpAmount = LPStaking.userInfo(poolId, address(this)).amount + IERC20(lpAddress).balanceOf(address(this));
        if (lpAmount == 0) {
            return 0;
        }
        address underlyingToken = IStargatePool(lpAddress).token();
        uint256 underlyingAmount = IStargatePool(lpAddress).amountLPtoLD(lpAmount);
        return _getValue(underlyingToken, base, underlyingAmount);
    }

    function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {
        uint256 poolId = abi.decode(data, (uint256));
        address lpAddress = LPStaking.poolInfo(poolId).lpToken;
        address[] memory tokens = new address[](1);
        tokens[0] = IStargatePool(lpAddress).token();
        return tokens;
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L123:129

```solidity
File: contracts/connectors/UNIv3Connector.sol


    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
        PositionBP memory positionInfo = registry.getPositionBP(vaultId, p.positionId);
        uint256 tokenId = abi.decode(p.data, (uint256));
        (address token0, address token1) = abi.decode(positionInfo.data, (address, address));
        uint256 amount0;
        uint256 amount1;
        (int24 tL, int24 tU, uint24 fee) = abi.decode(p.additionalData, (int24, int24, uint24));
        {
            IUniswapV3Pool pool = IUniswapV3Pool(factory.getPool(token0, token1, fee));
            bytes32 key = keccak256(abi.encodePacked(positionManager, tL, tU));

            (uint128 liquidity,,, uint128 tokensOwed0, uint128 tokensOwed1) = pool.positions(key);

            (uint160 sqrtPriceX96,,,,,,) = pool.slot0();
            (amount0, amount1) = LiquidityAmounts.getAmountsForLiquidity(
                sqrtPriceX96, TickMath.getSqrtRatioAtTick(tL), TickMath.getSqrtRatioAtTick(tU), liquidity
            );
            amount0 += tokensOwed0;
            amount1 += tokensOwed1;
        }

        tvl += valueOracle.getValue(token0, base, amount0);
        tvl += valueOracle.getValue(token1, base, amount1);
    }

    function _getUnderlyingTokens(uint256, bytes memory data) public pure override returns (address[] memory) {
        address[] memory tokens = new address[](2);
        (tokens[0], tokens[1]) = abi.decode(data, (address, address));
        return tokens;
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L152:156

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


    function _getPositionTVL(HoldingPI memory position, address) public view override returns (uint256) {
        uint256 positionTypeId = registry.getPositionBP(vaultId, position.positionId).positionTypeId;
        if (positionTypeId == OMNICHAIN_POSITION_ID) {
            return (abi.decode(position.additionalData, (uint256)));
        }
        return 0;
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L51:57

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol


    function _getPositionTVL(HoldingPI memory position, address base) public view override returns (uint256) {
        PositionBP memory bp = registry.getPositionBP(vaultId, position.positionId);
        if (bp.positionTypeId == 0) {
            address token = abi.decode(bp.data, (address));
            uint256 amount = IERC20(token).balanceOf(address(this));
            return _getValue(token, base, amount);
        }
        return 0;
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol#L33:41

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


    function receiveFlashLoan(
        IERC20[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory feeAmounts,
        bytes memory userData
    ) external override {
        emit ReceiveFlashLoan(tokens, amounts, feeAmounts, userData);
        require(msg.sender == address(vault));
        (
            uint256 vaultId,
            address receiver,
            address[] memory destinationConnector,
            bytes[] memory callingData,
            uint256[] memory gas
        ) = abi.decode(userData, (uint256, address, address[], bytes[], uint256[]));
        (,,, address keeperContract,, address emergencyManager) = registry.getGovernanceAddresses(vaultId);
        if (!(caller == keeperContract)) {
            revert Unauthorized(caller);
        }
        if (registry.isAnActiveConnector(vaultId, receiver)) {
            for (uint256 i = 0; i < tokens.length; i++) {
                // send the tokens to the receiver
                tokens[i].safeTransfer(receiver, amounts[i]);
                amounts[i] = amounts[i] + feeAmounts[i];
            }
            for (uint256 i = 0; i < destinationConnector.length; i++) {
                // execute the transactions
                (bool success,) = destinationConnector[i].call{ value: 0, gas: gas[i] }(callingData[i]);
                require(success, "BalancerFlashLoan: Flash loan failed");
            }
            for (uint256 i = 0; i < tokens.length; i++) {
                // send the tokens back to this contract
                BaseConnector(receiver).sendTokensToTrustedAddress(address(tokens[i]), amounts[i], address(this), "");
            }
        }
        for (uint256 i = 0; i < tokens.length; i++) {
            // send the tokens back to the vault
            tokens[i].safeTransfer(msg.sender, amounts[i]);
            require(tokens[i].balanceOf(address(this)) == 0, "BalancerFlashLoan: Flash loan extra tokens");
        }
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L54:94

```solidity
File: contracts/helpers/BaseConnector.sol


    function addLiquidity(address[] memory tokens, uint256[] memory amounts, bytes memory data)
        external
        override
        nonReentrant
    {
        if (!registry.isAddressTrusted(vaultId, msg.sender)) {
            revert IConnector_InvalidAddress(msg.sender);
        }

        for (uint256 i = 0; i < tokens.length; i++) {
            // gather all of the tokens
            uint256 _balance = IERC20(tokens[i]).balanceOf(address(this));
            ITokenTransferCallBack(msg.sender).sendTokensToTrustedAddress(tokens[i], amounts[i], msg.sender, "");
            uint256 _balanceAfter = IERC20(tokens[i]).balanceOf(address(this));
            if (_balanceAfter < amounts[i] + _balance) {
                revert IConnector_InsufficientDepositAmount(_balanceAfter - _balance, amounts[i]);
            }
        }
        _addLiquidity(tokens, amounts, data); // call the specific implementation if the connector needs to do something after the liquidity is added

        for (uint256 i = 0; i < tokens.length; i++) {
            _updateTokenInRegistry(tokens[i]); // update the token in the registry
        }
        emit AddLiquidity(tokens, amounts, data);
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L169:193

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


    function _lzReceive(Origin calldata _origin, bytes32, bytes calldata _message, address, bytes calldata)
        internal
        override
    {
        (uint256 vaultId, uint256 tvl, uint256 updateTime) = abi.decode(_message, (uint256, uint256, uint256));
        uint256 _srcChainId = chainInfo[_origin.srcEid].chainId;
        OmnichainManagerBaseChain(vaultIdToVaultInfo[vaultId].omniChainManager).updateTVL(_srcChainId, tvl, updateTime);
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L65:72

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


    function _payNative(uint256 amount) internal override returns (uint256) {
        return amount;
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L40:42

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


    function performSwapAction(address caller, SwapRequest calldata _request)
        external
        payable
        override
        onlyHandler
        returns (uint256)
    {
        require(verifySwapData(_request), "LifiImplementation: INVALID_SWAP_DATA");
        uint256 balanceOut0 = 0;
        if (_request.outputToken == address(0)) {
            balanceOut0 = address(_request.from).balance;
        } else {
            balanceOut0 = IERC20(_request.outputToken).balanceOf(_request.from);
        }
        _forward(IERC20(_request.inputToken), _request.from, _request.amount, caller, _request.data, _request.routeId);
        uint256 balanceOut1 = 0;
        if (_request.outputToken == address(0)) {
            balanceOut1 = address(_request.from).balance;
        } else {
            balanceOut1 = IERC20(_request.outputToken).balanceOf(_request.from);
        }

        emit Swapped(balanceOut0, balanceOut1, _request.outputToken);

        return balanceOut1 - balanceOut0;
    }

    function verifySwapData(SwapRequest calldata _request) public view override returns (bool) {
        bytes4 selector = bytes4(_request.data[:4]);
        if (selector != LI_FI_GENERIC_SWAP_SELECTOR) {
            revert InvalidSelector();
        }
        (address sendingAssetId, uint256 amount, address from, address receivingAssetId, uint256 receivingAmount) =
            ILiFi(lifi).extractGenericSwapParameters(_request.data);

        if (from != _request.from) revert InvalidReceiver(from, _request.from);
        if (receivingAmount < _request.minAmount) revert InvalidMinAmount();
        if (sendingAssetId != _request.inputToken) revert InvalidInputToken();
        if (receivingAssetId != _request.outputToken) revert InvalidOutputToken();
        if (amount != _request.amount) revert InvalidAmount();

        return true;
    }

    function performBridgeAction(address caller, BridgeRequest calldata _request)
        external
        payable
        override
        onlyHandler
    {
        verifyBridgeData(_request);
        _forward(IERC20(_request.inputToken), _request.from, _request.amount, caller, _request.data, _request.routeId);
        emit Bridged(_request.from, _request.inputToken, _request.amount, _request.data);
    }

    function verifyBridgeData(BridgeRequest calldata _request) public view override returns (bool) {
        ILiFi.BridgeData memory bridgeData = ILiFi(lifi).extractBridgeData(_request.data);

        if (isBridgeWhiteListed[bridgeData.bridge] == false) revert BridgeBlacklisted();
        if (isChainSupported[bridgeData.destinationChainId] == false) revert InvalidChainId();
        if (bridgeData.sendingAssetId != _request.inputToken) revert InvalidFromToken();
        if (bridgeData.receiver != _request.receiverAddress) {
            revert InvalidReceiver(bridgeData.receiver, _request.receiverAddress);
        }
        if (bridgeData.minAmount > _request.amount) revert InvalidMinAmount();
        if (bridgeData.destinationChainId != _request.destChainId) revert InvalidToChainId();

        return true;
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L150:163

</details>

## NC068 - Non-`external`/`public` function names should begin with an underscore:

According to the Solidity Style Guide, non-`external`/`public` function names should begin with an underscore


```solidity
File: contracts/accountingManager/Registry.sol


293         function updateHoldingPosition(


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

## NC069 - Unused import:

The identifier is imported but never used within the file


<details>
<summary>Click to show 5 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


5       import { ERC4626, ERC20 } from "hottings/node_modules/@openzeppelin/contracts-5.0/token/ERC20/extensions/ERC4626.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


6       import { PositionRegistry, PositionBP } from "../accountingManager/Registry.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/governance/NoyaGovernanceBase.sol


4       import { PositionRegistry, PositionBP } from "../accountingManager/Registry.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


6       import { PositionRegistry, PositionBP } from "../accountingManager/Registry.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


5       import {
6           SwapAndBridgeHandler,
7           SwapRequest,
8           BridgeRequest
9       } from "contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol";
5       import {
6           SwapAndBridgeHandler,
7           SwapRequest,
8           BridgeRequest
9       } from "contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol";
5       import {
6           SwapAndBridgeHandler,
7           SwapRequest,
8           BridgeRequest
9       } from "contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol";


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

</details>

## NC070 - Unused function parameter:

Comment out the variable name to suppress compiler warnings.


<details>
<summary>Click to show 9 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


693         function mint(uint256 shares, address receiver) public override returns (uint256) {
694             revert NoyaAccounting_NOT_ALLOWED();
695         }
693         function mint(uint256 shares, address receiver) public override returns (uint256) {
694             revert NoyaAccounting_NOT_ALLOWED();
695         }
697         function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256) {
698             revert NoyaAccounting_NOT_ALLOWED();
699         }
697         function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256) {
698             revert NoyaAccounting_NOT_ALLOWED();
699         }
697         function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256) {
698             revert NoyaAccounting_NOT_ALLOWED();
699         }
701         function redeem(uint256 shares, address receiver, address shareOwner) public override returns (uint256) {
702             revert NoyaAccounting_NOT_ALLOWED();
703         }
701         function redeem(uint256 shares, address receiver, address shareOwner) public override returns (uint256) {
702             revert NoyaAccounting_NOT_ALLOWED();
703         }
701         function redeem(uint256 shares, address receiver, address shareOwner) public override returns (uint256) {
702             revert NoyaAccounting_NOT_ALLOWED();
703         }
705         function deposit(uint256 assets, address receiver) public override returns (uint256) {
706             revert NoyaAccounting_NOT_ALLOWED();
707         }
705         function deposit(uint256 assets, address receiver) public override returns (uint256) {
706             revert NoyaAccounting_NOT_ALLOWED();
707         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


117         function _getUnderlyingTokens(uint256 p, bytes memory data) public view override returns (address[] memory) {
118             address[] memory tokens = new address[](2);
119             (address pool) = abi.decode(data, (address));
120             tokens[0] = IPool(pool).token0();
121             tokens[1] = IPool(pool).token1();
122             return tokens;
123         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


99          function _getUnderlyingTokens(uint256 id, bytes memory data) public view override returns (address[] memory) {
100             (address tokenA, address tokenB) = abi.decode(data, (address, address));
101             address[] memory tokens = new address[](2);
102             tokens[0] = tokenA;
103             tokens[1] = tokenB;
104             return tokens;
105         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


134         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {
135             return new address[](0);
136         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


142         function _getUnderlyingTokens(uint256 p, bytes memory data) public view override returns (address[] memory) {
143             address[] memory tokens = new address[](2);
144             (address pool) = abi.decode(data, (address));
145             tokens[0] = IFraxPair(pool).collateralContract();
146             tokens[1] = IFraxPair(pool).asset();
147             return tokens;
148         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


161         function _getUnderlyingTokens(uint256 id, bytes memory data) public view override returns (address[] memory) {
162             (address pool) = abi.decode(data, (address));
163             address[] memory tokens = new address[](2);
164             tokens[0] = IMaverickPool(pool).tokenA();
165             tokens[1] = IMaverickPool(pool).tokenB();
166             return tokens;
167         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


137         function convertCToL(uint256 amount, address marketOracle, address collateral) public view returns (uint256) {
138             return amount * IOracle(marketOracle).price() / ORACLE_PRICE_SCALE;
139         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/governance/Watchers.sol


8           function verifyRemoveLiquidity(uint256 withdrawAmount, uint256 sentAmount, bytes memory data) external view { }
8           function verifyRemoveLiquidity(uint256 withdrawAmount, uint256 sentAmount, bytes memory data) external view { }
8           function verifyRemoveLiquidity(uint256 withdrawAmount, uint256 sentAmount, bytes memory data) external view { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Watchers.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


27          function sendTokensToTrustedAddress(address token, uint256 amount, address caller, bytes memory data)
28              external
29              returns (uint256)
30          {
31              if (data.length == 0) {
32                  IERC20(token).safeTransfer(msg.sender, amount);
33                  return amount;
34              }
35              (uint256 amountToSend, uint256 amountToReturn) = abi.decode(data, (uint256, uint256));
36              IERC20(token).safeTransfer(msg.sender, amountToSend);
37              return amountToReturn;
38          }
40          function addLiquidity(address[] memory tokens, uint256[] memory amounts, bytes memory data) external {
41              for (uint256 i = 0; i < tokens.length; i++) {
42                  // gather all of the tokens
43      
44                  ITokenTransferCallBack(msg.sender).sendTokensToTrustedAddress(tokens[i], amounts[i], msg.sender, "");
45              }
46              for (uint256 i = 0; i < tokens.length; i++) {
47                  _updateTokenInRegistry(tokens[i]); // update the token in the registry
48              }
49          }
71          function getPositionTVL(HoldingPI memory p, address baseToken) public view returns (uint256) {
72              return 0;
73          }
71          function getPositionTVL(HoldingPI memory p, address baseToken) public view returns (uint256) {
72              return 0;
73          }
75          function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {
76              return new address[](0);
77          }
75          function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {
76              return new address[](0);
77          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

</details>

## NC071 - Unsafe conversion from unsigned to signed values:

Solidity follows [two's complement](https://en.wikipedia.org/wiki/Two%27s_complement) rules for its integers, meaning that the most significant bit for signed integers is used to denote the sign, and converting between the two requires inverting all of the bits and adding one. Because of this, casting an unsigned integer to a signed one may result in a change of the sign and or magnitude of the value. For example, `int8(type(uint8).max)` is not equal to `type(int8).max`, but is equal to `-1`. `type(uint8).max` in binary is `11111111`, which if cast to a signed value, means the first binary `1` indicates a negative value, and the binary `1`s, invert to all zeroes, and when one is added, it becomes one, but negative, and therefore the decimal value of binary `11111111` is `-1`.


```solidity
File: contracts/connectors/CurveConnector.sol


169             ICurveSwap(poolInfo.pool).remove_liquidity_one_coin(amount, int128(uint128(withdrawIndex)), minAmount);
302             int128 tokenIndex = int128(uint128(index));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


82              if (tickCumulativesDelta < 0 && (tickCumulativesDelta % int56(int32(period)) != 0)) {
81              int24 timeWeightedAverageTick = int24(tickCumulativesDelta / int56(int32(period)));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

## NC072 - Put all system-wide constants in one file:

Putting all the system-wide constants in a single file improves code readability, makes it easier to understand the basic configuration and limitations of the system, and makes maintenance easier.


<details>
<summary>Click to show 29 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


52          uint256 public constant FEE_PRECISION = 1e6;


53          uint256 public constant WITHDRAWAL_MAX_FEE = 5e4;


54          uint256 public constant MANAGEMENT_MAX_FEE = 5e5;


55          uint256 public constant PERFORMANCE_MAX_FEE = 1e5;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L55:55

```solidity
File: contracts/accountingManager/Registry.sol


15          bytes32 public constant MAINTAINER_ROLE = keccak256("MAINTAINER_ROLE");


17          bytes32 public constant GOVERNER_ROLE = keccak256("GOVERNER_ROLE");


19          bytes32 public constant EMERGENCY_ROLE = keccak256("EMERGENCY_ROLE");


21          uint256 public constant MAX_NUM_HOLDING_POSITIONS = 40;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L21:21

```solidity
File: contracts/connectors/AaveConnector.sol


24          uint256 public constant AAVE_POSITION_ID = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L24:24

```solidity
File: contracts/connectors/AerodromeConnector.sol


31          uint256 public constant AERODROME_POSITION_TYPE = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L31:31

```solidity
File: contracts/connectors/CamelotConnector.sol


34          uint256 public constant CAMELOT_POSITION_ID = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L34:34

```solidity
File: contracts/connectors/CurveConnector.sol


31          uint256 public constant CURVE_LP_POSITION = 4;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L31:31

```solidity
File: contracts/connectors/Dolomite.sol


16          uint256 public constant DOL_POSITION_ID = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L16:16

```solidity
File: contracts/connectors/GearBoxV3.sol


9           uint256 public constant GEARBOX_POSITION_ID = 3;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L9:9

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


15          uint256 public constant MORPHO_POSITION_ID = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L15:15

```solidity
File: contracts/connectors/PendleConnector.sol


26          uint256 public constant PENDLE_POSITION_ID = 11;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L26:26

```solidity
File: contracts/connectors/PrismaConnector.sol


14          uint256 public constant PRISMA_POSITION_ID = 10;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L14:14

```solidity
File: contracts/connectors/SNXConnector.sol


16          uint256 public constant SNX_POSITION_ID = 1;


17          uint256 public constant SNX_POOL_POSITION_ID = 2;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L17:17

```solidity
File: contracts/connectors/SiloConnector.sol


10          uint256 public constant SILO_LP_ID = 11;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L10:10

```solidity
File: contracts/connectors/StargateConnector.sol


26          uint256 public constant STARGATE_LP_POSITION_TYPE = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L26:26

```solidity
File: contracts/connectors/UNIv3Connector.sol


19          uint256 public constant UNI_LP_POSITION_TYPE = 5;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L19:19

```solidity
File: contracts/governance/Keepers.sol


11          bytes32 public constant TXTYPE_HASH = keccak256(
12              "Execute(uint256 nonce,address destination,bytes data,uint256 gasLimit,address executor, uint256 deadline)"
13          );


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L11:13

```solidity
File: contracts/helpers/ConnectorMock2.sol


20          uint256 public constant positionType = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L20:20

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


19          uint256 public constant BRIDGE_TXN_WAITING_TIME = 30 minutes;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L19:19

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


11          uint256 public constant OMNICHAIN_POSITION_ID = 13;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L11:11

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


18          bytes4 public constant LI_FI_GENERIC_SWAP_SELECTOR = 0x4630a0d8;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L18:18

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


25          address public constant ETH = address(0);


26          address public constant USD = address(840);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L26:26

</details>

## NC073 - Add inline comments for unnamed variables:

`function foo(address x, address)` -> `function foo(address x, address /* y */)`


<details>
<summary>Click to show 13 findings</summary>

```solidity
File: contracts/connectors/AaveConnector.sol


120         function _getUnderlyingTokens(uint256, bytes memory) public pure override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


134         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


149         function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


141         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


311         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


164         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


128         function _getUnderlyingTokens(uint256, bytes memory) public pure override returns (address[] memory) {
64          function onERC721Received(address, address, uint256, bytes memory) external pure override returns (bytes4) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


143         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


123         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


152         function _getUnderlyingTokens(uint256, bytes memory data) public pure override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


263         function _getUnderlyingTokens(uint256, bytes memory) public view virtual returns (address[] memory) {
271         function _getPositionTVL(HoldingPI memory, address) public view virtual returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


65          function _lzReceive(Origin calldata _origin, bytes32, bytes calldata _message, address, bytes calldata)
66              internal
67              override
68          {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


51          function _getPositionTVL(HoldingPI memory position, address) public view override returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L0:0

</details>

## NC074 - Consider adding emergency-stop functionality:

Adding a way to quickly halt protocol functionality in an emergency, rather than having to pause individual contracts one-by-one, will make in-progress hack mitigation faster and much less stressful.


<details>
<summary>Click to show 6 findings</summary>

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


7       contract NoyaFeeReceiver is Ownable {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


12      contract PositionRegistry is AccessControl, IPositionRegistry, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


9       contract Keepers is EIP712, Ownable2Step {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


18      contract LZHelperReceiver is OAppReceiver {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


19      contract LZHelperSender is OAppSender {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


10      contract LifiImplementation is ISwapAndBridgeImplementation, Ownable2Step, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

</details>

## NC075 - Named imports of parent contracts are missing:

  


<details>
<summary>Click to show 37 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


16      contract AccountingManager is IAccountingManager, ERC4626, ReentrancyGuard, Pausable, NoyaGovernanceBase {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


7       contract NoyaFeeReceiver is Ownable {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


12      contract PositionRegistry is AccessControl, IPositionRegistry, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


11      contract AaveConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


27      contract AerodromeConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


26      contract BalancerConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


12      contract BalancerFlashLoan is IFlashLoanRecipient, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


30      contract CamelotConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


7       contract CompoundConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


24      contract CurveConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


9       contract DolomiteConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


18      contract FraxConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


8       contract Gearboxv3 is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


7       contract LidoConnector is BaseConnector, ERC721Holder {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


29      contract MaverickConnector is BaseConnector, IERC721Receiver {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


8       contract MorphoBlueConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


8       contract PancakeswapConnector is UNIv3Connector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


12      contract PendleConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


11      contract PrismaConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


7       contract SNXV3Connector is BaseConnector, IERC721Receiver {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


8       contract SiloConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


19      contract StargateConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


12      contract UNIv3Connector is BaseConnector, ERC721Holder {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


9       contract Keepers is EIP712, Ownable2Step {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/governance/TimeLock.sol


6       contract NoyaTimeLock is TimelockController {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/TimeLock.sol#L0:0

```solidity
File: contracts/governance/Watchers.sol


6       contract Watchers is Keepers {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Watchers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


22      contract BaseConnector is NoyaGovernanceBase, IConnector, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


18      contract LZHelperReceiver is OAppReceiver {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


19      contract LZHelperSender is OAppSender {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


14      abstract contract OmnichainLogic is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


8       contract OmnichainManagerBaseChain is OmnichainLogic {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol


10      contract OmnichainManagerNormalChain is OmnichainLogic {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


10      contract SwapAndBridgeHandler is NoyaGovernanceBase, ISwapAndBridgeHandler, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


10      contract LifiImplementation is ISwapAndBridgeImplementation, Ownable2Step, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


10      contract NoyaValueOracle is INoyaValueOracle {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


10      contract ChainlinkOracleConnector is INoyaValueOracle {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


12      contract UniswapValueOracle is INoyaValueOracle {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## NC076 - Contract doesn't handle all NFT types:

There are two primary standards for NFTs - [ERC-721](https://eips.ethereum.org/EIPS/eip-721) and [ERC-1155](https://eips.ethereum.org/EIPS/eip-1155). Supporting one but not the other excludes half of the available market.


```solidity
File: contracts/connectors/MaverickConnector.sol


29      contract MaverickConnector is BaseConnector, IERC721Receiver {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


7       contract SNXV3Connector is BaseConnector, IERC721Receiver {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

## NC077 - Use `bytes.concat()` on bytes instead of `abi.encodePacked()` for clearer semantic meaning:

Starting with version 0.8.4, Solidity has the `bytes.concat()` function, which allows one to concatenate a list of bytes/strings, without extra padding. Using this function rather than `abi.encodePacked()` makes the intended operation more clear, leading to less reviewer confusion.


```solidity
File: contracts/governance/Keepers.sol


102                 bytes32 totalHash = keccak256(abi.encodePacked("\x19\x01", _domainSeparatorV4(), txInputHash));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

## NC078 - Consider using `SafeTransferLib.safeTransferETH()` or `Address.sendValue()` for clearer semantic meaning:

These Functions indicate their purpose with their name more clearly than using low-level calls.


```solidity
File: contracts/accountingManager/AccountingManager.sol


685                 (bool success,) = payable(msg.sender).call{ value: amount }("");


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


195                 (bool success,) = payable(userAddress).call{ value: amount }("");


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

## NC079 - Style guide: State and local variables should be named using lowerCamelCase:

The Solidity style guide says to use mixedCase for local and state variable names. Note that while OpenZeppelin may not follow this advice, it still is the recommended way of naming variables.


<details>
<summary>Click to show 40 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


549             uint256 amountAskedForWithdraw_temp = 0;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


298             bytes calldata AD,
298             bytes calldata AD,
298             bytes calldata AD,
298             bytes calldata AD,
298             bytes calldata AD,
298             bytes calldata AD,
298             bytes calldata AD,
298             bytes calldata AD,
298             bytes calldata AD,
298             bytes calldata AD,
298             bytes calldata AD,
298             bytes calldata AD,
298             bytes calldata AD,
298             bytes calldata AD,
298             bytes calldata AD,


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol




```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol




```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


29          address public BAL;
30          address public AURA;
32          uint256 public BALANCER_LP_POSITION = 1;
163             PositionBP memory PTI = registry.getPositionBP(vaultId, p.positionId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol




```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol




```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


8           uint256 public COMPOUND_LP = 2;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


27          address public CVX;
28          address public CRV;
29          address public PRISMA;
298             public
298             public
298             public
298             public
298             public
298             public
298             public
298             public
298             public
298             public
298             public
298             public
298             public
298             public
266             PositionBP memory PTI = registry.getPositionBP(vaultId, p.positionId);
298             public
298             public
298             public
298             public
298             public
298             public
298             public
298             public


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol




```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


22          uint256 public COLLATERAL_AND_DEBT_POSITION_TYPE = 1;
127             (uint256 LTV_PRECISION,,,, uint256 EXCHANGE_PRECISION,,,) = _fraxlendPair.getConstants();
127             (uint256 LTV_PRECISION,,,, uint256 EXCHANGE_PRECISION,,,) = _fraxlendPair.getConstants();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol




```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


13          uint256 public LIDO_WITHDRAWAL_REQUEST_ID = 10;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


35          uint256 public MAVERICK_LP = 10;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


23          constructor(address MB, BaseConnectorCP memory baseCP) BaseConnector(baseCP) {
23          constructor(address MB, BaseConnectorCP memory baseCP) BaseConnector(baseCP) {
23          constructor(address MB, BaseConnectorCP memory baseCP) BaseConnector(baseCP) {
23          constructor(address MB, BaseConnectorCP memory baseCP) BaseConnector(baseCP) {
23          constructor(address MB, BaseConnectorCP memory baseCP) BaseConnector(baseCP) {
23          constructor(address MB, BaseConnectorCP memory baseCP) BaseConnector(baseCP) {
23          constructor(address MB, BaseConnectorCP memory baseCP) BaseConnector(baseCP) {
23          constructor(address MB, BaseConnectorCP memory baseCP) BaseConnector(baseCP) {
23          constructor(address MB, BaseConnectorCP memory baseCP) BaseConnector(baseCP) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


23              masterchef = IMasterchefV3(MC);
19          constructor(address MC, address _positionManager, address _factory, BaseConnectorCP memory baseConnectorParams)
23              masterchef = IMasterchefV3(MC);
19          constructor(address MC, address _positionManager, address _factory, BaseConnectorCP memory baseConnectorParams)
23              masterchef = IMasterchefV3(MC);
19          constructor(address MC, address _positionManager, address _factory, BaseConnectorCP memory baseConnectorParams)
23              masterchef = IMasterchefV3(MC);
19          constructor(address MC, address _positionManager, address _factory, BaseConnectorCP memory baseConnectorParams)


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


298          * @notice Checks whether all positions (SY, PT, YT, and LP (in the pool and in penpie)) in a given market are empty for this contract
23          IPAllActionV3 public pendleRouter;
19          using PYIndexLib for IPYieldToken;
57          constructor(address _pendleMarketDepositHelper, address _pendleRouter, address SR, BaseConnectorCP memory baseCP)
79              (IPStandardizedYield _SY, IPPrincipalToken _PT,) = IPMarket(market).readTokens();
79              (IPStandardizedYield _SY, IPPrincipalToken _PT,) = IPMarket(market).readTokens();
298          * @notice Checks whether all positions (SY, PT, YT, and LP (in the pool and in penpie)) in a given market are empty for this contract
23          IPAllActionV3 public pendleRouter;
19          using PYIndexLib for IPYieldToken;
57          constructor(address _pendleMarketDepositHelper, address _pendleRouter, address SR, BaseConnectorCP memory baseCP)
98              (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
98              (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
98              (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
298          * @notice Checks whether all positions (SY, PT, YT, and LP (in the pool and in penpie)) in a given market are empty for this contract
23          IPAllActionV3 public pendleRouter;
19          using PYIndexLib for IPYieldToken;
57          constructor(address _pendleMarketDepositHelper, address _pendleRouter, address SR, BaseConnectorCP memory baseCP)
113             (IPStandardizedYield _SY, IPPrincipalToken _PT,) = IPMarket(market).readTokens();
113             (IPStandardizedYield _SY, IPPrincipalToken _PT,) = IPMarket(market).readTokens();
298          * @notice Checks whether all positions (SY, PT, YT, and LP (in the pool and in penpie)) in a given market are empty for this contract
23          IPAllActionV3 public pendleRouter;
19          using PYIndexLib for IPYieldToken;
57          constructor(address _pendleMarketDepositHelper, address _pendleRouter, address SR, BaseConnectorCP memory baseCP)
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
298          * @notice Checks whether all positions (SY, PT, YT, and LP (in the pool and in penpie)) in a given market are empty for this contract
23          IPAllActionV3 public pendleRouter;
19          using PYIndexLib for IPYieldToken;
57          constructor(address _pendleMarketDepositHelper, address _pendleRouter, address SR, BaseConnectorCP memory baseCP)
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
298          * @notice Checks whether all positions (SY, PT, YT, and LP (in the pool and in penpie)) in a given market are empty for this contract
23          IPAllActionV3 public pendleRouter;
19          using PYIndexLib for IPYieldToken;
57          constructor(address _pendleMarketDepositHelper, address _pendleRouter, address SR, BaseConnectorCP memory baseCP)
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
153             (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
153             (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
153             (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
298          * @notice Checks whether all positions (SY, PT, YT, and LP (in the pool and in penpie)) in a given market are empty for this contract
23          IPAllActionV3 public pendleRouter;
19          using PYIndexLib for IPYieldToken;
57          constructor(address _pendleMarketDepositHelper, address _pendleRouter, address SR, BaseConnectorCP memory baseCP)
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
170             (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
170             (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
170             (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
298          * @notice Checks whether all positions (SY, PT, YT, and LP (in the pool and in penpie)) in a given market are empty for this contract
23          IPAllActionV3 public pendleRouter;
19          using PYIndexLib for IPYieldToken;
57          constructor(address _pendleMarketDepositHelper, address _pendleRouter, address SR, BaseConnectorCP memory baseCP)
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
188             (IPStandardizedYield _SY, IPPrincipalToken _PT,) = IPMarket(market).readTokens();
188             (IPStandardizedYield _SY, IPPrincipalToken _PT,) = IPMarket(market).readTokens();
298          * @notice Checks whether all positions (SY, PT, YT, and LP (in the pool and in penpie)) in a given market are empty for this contract
23          IPAllActionV3 public pendleRouter;
19          using PYIndexLib for IPYieldToken;
57          constructor(address _pendleMarketDepositHelper, address _pendleRouter, address SR, BaseConnectorCP memory baseCP)
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
298          * @notice Checks whether all positions (SY, PT, YT, and LP (in the pool and in penpie)) in a given market are empty for this contract
23          IPAllActionV3 public pendleRouter;
19          using PYIndexLib for IPYieldToken;
57          constructor(address _pendleMarketDepositHelper, address _pendleRouter, address SR, BaseConnectorCP memory baseCP)
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
217             (IPStandardizedYield SY,,) = market.readTokens();
298          * @notice Checks whether all positions (SY, PT, YT, and LP (in the pool and in penpie)) in a given market are empty for this contract
23          IPAllActionV3 public pendleRouter;
19          using PYIndexLib for IPYieldToken;
57          constructor(address _pendleMarketDepositHelper, address _pendleRouter, address SR, BaseConnectorCP memory baseCP)
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
298          * @notice Checks whether all positions (SY, PT, YT, and LP (in the pool and in penpie)) in a given market are empty for this contract
23          IPAllActionV3 public pendleRouter;
19          using PYIndexLib for IPYieldToken;
57          constructor(address _pendleMarketDepositHelper, address _pendleRouter, address SR, BaseConnectorCP memory baseCP)
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
262                 (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
262                 (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
262                 (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
265                 uint256 SYAmount = _SY.balanceOf(address(this));
274                 uint256 PTAmount = _PT.balanceOf(address(this));
277                 uint256 YTBalance = _YT.balanceOf(address(this));
298          * @notice Checks whether all positions (SY, PT, YT, and LP (in the pool and in penpie)) in a given market are empty for this contract
23          IPAllActionV3 public pendleRouter;
19          using PYIndexLib for IPYieldToken;
57          constructor(address _pendleMarketDepositHelper, address _pendleRouter, address SR, BaseConnectorCP memory baseCP)
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
298          * @notice Checks whether all positions (SY, PT, YT, and LP (in the pool and in penpie)) in a given market are empty for this contract
23          IPAllActionV3 public pendleRouter;
19          using PYIndexLib for IPYieldToken;
57          constructor(address _pendleMarketDepositHelper, address _pendleRouter, address SR, BaseConnectorCP memory baseCP)
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
304             (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
304             (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
304             (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
298          * @notice Checks whether all positions (SY, PT, YT, and LP (in the pool and in penpie)) in a given market are empty for this contract
23          IPAllActionV3 public pendleRouter;
19          using PYIndexLib for IPYieldToken;
57          constructor(address _pendleMarketDepositHelper, address _pendleRouter, address SR, BaseConnectorCP memory baseCP)
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
313             (IPStandardizedYield SY,,) = IPMarket(market).readTokens();
298          * @notice Checks whether all positions (SY, PT, YT, and LP (in the pool and in penpie)) in a given market are empty for this contract
23          IPAllActionV3 public pendleRouter;
19          using PYIndexLib for IPYieldToken;
57          constructor(address _pendleMarketDepositHelper, address _pendleRouter, address SR, BaseConnectorCP memory baseCP)
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


23           * @param baseConnectorParams Struct containing essential parameters for the base connector
19          event CloseTrove(address zap, address troveManager);
57              bytes32 positionId = registry.calculatePositionId(address(this), PRISMA_POSITION_ID, abi.encode(zap, tm));
112                 _approveOperations(ITroveManager(tm).debtToken(), address(borrowerOps), bAmount);
112                 _approveOperations(ITroveManager(tm).debtToken(), address(borrowerOps), bAmount);
23           * @param baseConnectorParams Struct containing essential parameters for the base connector
19          event CloseTrove(address zap, address troveManager);
57              bytes32 positionId = registry.calculatePositionId(address(this), PRISMA_POSITION_ID, abi.encode(zap, tm));
112                 _approveOperations(ITroveManager(tm).debtToken(), address(borrowerOps), bAmount);
112                 _approveOperations(ITroveManager(tm).debtToken(), address(borrowerOps), bAmount);
23           * @param baseConnectorParams Struct containing essential parameters for the base connector
19          event CloseTrove(address zap, address troveManager);
57              bytes32 positionId = registry.calculatePositionId(address(this), PRISMA_POSITION_ID, abi.encode(zap, tm));
112                 _approveOperations(ITroveManager(tm).debtToken(), address(borrowerOps), bAmount);
112                 _approveOperations(ITroveManager(tm).debtToken(), address(borrowerOps), bAmount);
23           * @param baseConnectorParams Struct containing essential parameters for the base connector
19          event CloseTrove(address zap, address troveManager);
57              bytes32 positionId = registry.calculatePositionId(address(this), PRISMA_POSITION_ID, abi.encode(zap, tm));
112                 _approveOperations(ITroveManager(tm).debtToken(), address(borrowerOps), bAmount);
112                 _approveOperations(ITroveManager(tm).debtToken(), address(borrowerOps), bAmount);
23           * @param baseConnectorParams Struct containing essential parameters for the base connector
19          event CloseTrove(address zap, address troveManager);
57              bytes32 positionId = registry.calculatePositionId(address(this), PRISMA_POSITION_ID, abi.encode(zap, tm));
112                 _approveOperations(ITroveManager(tm).debtToken(), address(borrowerOps), bAmount);
112                 _approveOperations(ITroveManager(tm).debtToken(), address(borrowerOps), bAmount);
23           * @param baseConnectorParams Struct containing essential parameters for the base connector
19          event CloseTrove(address zap, address troveManager);
57              bytes32 positionId = registry.calculatePositionId(address(this), PRISMA_POSITION_ID, abi.encode(zap, tm));
112                 _approveOperations(ITroveManager(tm).debtToken(), address(borrowerOps), bAmount);
112                 _approveOperations(ITroveManager(tm).debtToken(), address(borrowerOps), bAmount);
23           * @param baseConnectorParams Struct containing essential parameters for the base connector
19          event CloseTrove(address zap, address troveManager);
57              bytes32 positionId = registry.calculatePositionId(address(this), PRISMA_POSITION_ID, abi.encode(zap, tm));
112                 _approveOperations(ITroveManager(tm).debtToken(), address(borrowerOps), bAmount);
112                 _approveOperations(ITroveManager(tm).debtToken(), address(borrowerOps), bAmount);
23           * @param baseConnectorParams Struct containing essential parameters for the base connector
19          event CloseTrove(address zap, address troveManager);
57              bytes32 positionId = registry.calculatePositionId(address(this), PRISMA_POSITION_ID, abi.encode(zap, tm));
112                 _approveOperations(ITroveManager(tm).debtToken(), address(borrowerOps), bAmount);
112                 _approveOperations(ITroveManager(tm).debtToken(), address(borrowerOps), bAmount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


14          IV3CoreProxy public SNXCoreProxy;
23          }
19          // ------------ Constructor -------------- //
57                      true
112                 SNXCoreProxy.mintUsd(_accountId, poolId, collateralType, _amount);
112                 SNXCoreProxy.mintUsd(_accountId, poolId, collateralType, _amount);
20          constructor(address _SNXCoreProxy, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {
23          }
19          // ------------ Constructor -------------- //
57                      true
112                 SNXCoreProxy.mintUsd(_accountId, poolId, collateralType, _amount);
112                 SNXCoreProxy.mintUsd(_accountId, poolId, collateralType, _amount);
20          constructor(address _SNXCoreProxy, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {
23          }
19          // ------------ Constructor -------------- //
57                      true
112                 SNXCoreProxy.mintUsd(_accountId, poolId, collateralType, _amount);
112                 SNXCoreProxy.mintUsd(_accountId, poolId, collateralType, _amount);
20          constructor(address _SNXCoreProxy, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {
23          }
19          // ------------ Constructor -------------- //
57                      true
112                 SNXCoreProxy.mintUsd(_accountId, poolId, collateralType, _amount);
112                 SNXCoreProxy.mintUsd(_accountId, poolId, collateralType, _amount);
20          constructor(address _SNXCoreProxy, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {
23          }
19          // ------------ Constructor -------------- //
57                      true
112                 SNXCoreProxy.mintUsd(_accountId, poolId, collateralType, _amount);
112                 SNXCoreProxy.mintUsd(_accountId, poolId, collateralType, _amount);
20          constructor(address _SNXCoreProxy, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {
23          }
19          // ------------ Constructor -------------- //
57                      true
112                 SNXCoreProxy.mintUsd(_accountId, poolId, collateralType, _amount);
112                 SNXCoreProxy.mintUsd(_accountId, poolId, collateralType, _amount);
20          constructor(address _SNXCoreProxy, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {
23          }
19          // ------------ Constructor -------------- //
57                      true
112                 SNXCoreProxy.mintUsd(_accountId, poolId, collateralType, _amount);
112                 SNXCoreProxy.mintUsd(_accountId, poolId, collateralType, _amount);
20          constructor(address _SNXCoreProxy, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {
23          }
19          // ------------ Constructor -------------- //
57                      true
112                 SNXCoreProxy.mintUsd(_accountId, poolId, collateralType, _amount);
112                 SNXCoreProxy.mintUsd(_accountId, poolId, collateralType, _amount);
20          constructor(address _SNXCoreProxy, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {
23          }
19          // ------------ Constructor -------------- //
57                      true
112                 SNXCoreProxy.mintUsd(_accountId, poolId, collateralType, _amount);
112                 SNXCoreProxy.mintUsd(_accountId, poolId, collateralType, _amount);
20          constructor(address _SNXCoreProxy, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {
23          }
19          // ------------ Constructor -------------- //
57                      true
112                 SNXCoreProxy.mintUsd(_accountId, poolId, collateralType, _amount);
112                 SNXCoreProxy.mintUsd(_accountId, poolId, collateralType, _amount);
20          constructor(address _SNXCoreProxy, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {
23          }
19          // ------------ Constructor -------------- //
57                      true
112                 SNXCoreProxy.mintUsd(_accountId, poolId, collateralType, _amount);
112                 SNXCoreProxy.mintUsd(_accountId, poolId, collateralType, _amount);
20          constructor(address _SNXCoreProxy, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


23              minimumHealthFactor = MINIMUM_HEALTH_FACTOR;
19      
17          constructor(address SR, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {
112             ISilo silo = ISilo(siloRepository.getSilo(siloToken));
112             ISilo silo = ISilo(siloRepository.getSilo(siloToken));
20              siloRepository = ISiloRepository(SR);
23              minimumHealthFactor = MINIMUM_HEALTH_FACTOR;
19      
17          constructor(address SR, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {
112             ISilo silo = ISilo(siloRepository.getSilo(siloToken));
112             ISilo silo = ISilo(siloRepository.getSilo(siloToken));
20              siloRepository = ISiloRepository(SR);
23              minimumHealthFactor = MINIMUM_HEALTH_FACTOR;
19      
17          constructor(address SR, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {
112             ISilo silo = ISilo(siloRepository.getSilo(siloToken));
112             ISilo silo = ISilo(siloRepository.getSilo(siloToken));
20              siloRepository = ISiloRepository(SR);
23              minimumHealthFactor = MINIMUM_HEALTH_FACTOR;
19      
17          constructor(address SR, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {
112             ISilo silo = ISilo(siloRepository.getSilo(siloToken));
112             ISilo silo = ISilo(siloRepository.getSilo(siloToken));
20              siloRepository = ISiloRepository(SR);
23              minimumHealthFactor = MINIMUM_HEALTH_FACTOR;
19      
17          constructor(address SR, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {
112             ISilo silo = ISilo(siloRepository.getSilo(siloToken));
112             ISilo silo = ISilo(siloRepository.getSilo(siloToken));
20              siloRepository = ISiloRepository(SR);
23              minimumHealthFactor = MINIMUM_HEALTH_FACTOR;
19      
17          constructor(address SR, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {
112             ISilo silo = ISilo(siloRepository.getSilo(siloToken));
112             ISilo silo = ISilo(siloRepository.getSilo(siloToken));
20              siloRepository = ISiloRepository(SR);
23              minimumHealthFactor = MINIMUM_HEALTH_FACTOR;
19      
17          constructor(address SR, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {
112             ISilo silo = ISilo(siloRepository.getSilo(siloToken));
112             ISilo silo = ISilo(siloRepository.getSilo(siloToken));
20              siloRepository = ISiloRepository(SR);
23              minimumHealthFactor = MINIMUM_HEALTH_FACTOR;
19      
17          constructor(address SR, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {
112             ISilo silo = ISilo(siloRepository.getSilo(siloToken));
112             ISilo silo = ISilo(siloRepository.getSilo(siloToken));
20              siloRepository = ISiloRepository(SR);
23              minimumHealthFactor = MINIMUM_HEALTH_FACTOR;
19      
17          constructor(address SR, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {
112             ISilo silo = ISilo(siloRepository.getSilo(siloToken));
112             ISilo silo = ISilo(siloRepository.getSilo(siloToken));
20              siloRepository = ISiloRepository(SR);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


22          IStargateLPStaking LPStaking;
23          IStargateRouter stargateRouter;
19      contract StargateConnector is BaseConnector {
17      }
112             uint256 poolId = abi.decode(pBP.data, (uint256));
112             uint256 poolId = abi.decode(pBP.data, (uint256));
20          // ------------ state variables -------------- //
23          IStargateRouter stargateRouter;
19      contract StargateConnector is BaseConnector {
17      }
112             uint256 poolId = abi.decode(pBP.data, (uint256));
112             uint256 poolId = abi.decode(pBP.data, (uint256));
20          // ------------ state variables -------------- //
88              uint256 LPAmount = LPStaking.userInfo(withdrawRequest.poolId, address(this)).amount;
23          IStargateRouter stargateRouter;
19      contract StargateConnector is BaseConnector {
17      }
112             uint256 poolId = abi.decode(pBP.data, (uint256));
112             uint256 poolId = abi.decode(pBP.data, (uint256));
20          // ------------ state variables -------------- //
23          IStargateRouter stargateRouter;
19      contract StargateConnector is BaseConnector {
17      }
112             uint256 poolId = abi.decode(pBP.data, (uint256));
112             uint256 poolId = abi.decode(pBP.data, (uint256));
20          // ------------ state variables -------------- //
23          IStargateRouter stargateRouter;
19      contract StargateConnector is BaseConnector {
17      }
112             uint256 poolId = abi.decode(pBP.data, (uint256));
112             uint256 poolId = abi.decode(pBP.data, (uint256));
20          // ------------ state variables -------------- //
23          IStargateRouter stargateRouter;
19      contract StargateConnector is BaseConnector {
17      }
112             uint256 poolId = abi.decode(pBP.data, (uint256));
112             uint256 poolId = abi.decode(pBP.data, (uint256));
20          // ------------ state variables -------------- //


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


23          event IncreasePosition(IncreaseLiquidityParams p);
19          uint256 public constant UNI_LP_POSITION_TYPE = 5;
17          IUniswapV3Factory public immutable factory;
112         /**
112         /**
20      
23          event IncreasePosition(IncreaseLiquidityParams p);
19          uint256 public constant UNI_LP_POSITION_TYPE = 5;
17          IUniswapV3Factory public immutable factory;
112         /**
112         /**
20      
23          event IncreasePosition(IncreaseLiquidityParams p);
19          uint256 public constant UNI_LP_POSITION_TYPE = 5;
17          IUniswapV3Factory public immutable factory;
112         /**
112         /**
20      
23          event IncreasePosition(IncreaseLiquidityParams p);
19          uint256 public constant UNI_LP_POSITION_TYPE = 5;
17          IUniswapV3Factory public immutable factory;
112         /**
112         /**
20      
23          event IncreasePosition(IncreaseLiquidityParams p);
19          uint256 public constant UNI_LP_POSITION_TYPE = 5;
17          IUniswapV3Factory public immutable factory;
112         /**
112         /**
20      
23          event IncreasePosition(IncreaseLiquidityParams p);
19          uint256 public constant UNI_LP_POSITION_TYPE = 5;
17          IUniswapV3Factory public immutable factory;
112         /**
112         /**
20      
23          event IncreasePosition(IncreaseLiquidityParams p);
19          uint256 public constant UNI_LP_POSITION_TYPE = 5;
17          IUniswapV3Factory public immutable factory;
112         /**
112         /**
20      
23          event IncreasePosition(IncreaseLiquidityParams p);
19          uint256 public constant UNI_LP_POSITION_TYPE = 5;
17          IUniswapV3Factory public immutable factory;
112         /**
112         /**
20      
23          event IncreasePosition(IncreaseLiquidityParams p);
19          uint256 public constant UNI_LP_POSITION_TYPE = 5;
17          IUniswapV3Factory public immutable factory;
112         /**
112         /**
20      


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


23           * @notice Constructs the Keepers multisignature wallet with a set of owners and a threshold for transaction execution
19          event UpdateOwners(address[] owners, bool[] addOrRemove);
17      
112     
112     
20          event UpdateThreshold(uint8 threshold);
23           * @notice Constructs the Keepers multisignature wallet with a set of owners and a threshold for transaction execution
19          event UpdateOwners(address[] owners, bool[] addOrRemove);
17      
112     
112     
20          event UpdateThreshold(uint8 threshold);
23           * @notice Constructs the Keepers multisignature wallet with a set of owners and a threshold for transaction execution
19          event UpdateOwners(address[] owners, bool[] addOrRemove);
17      
112     
112     
20          event UpdateThreshold(uint8 threshold);
23           * @notice Constructs the Keepers multisignature wallet with a set of owners and a threshold for transaction execution
19          event UpdateOwners(address[] owners, bool[] addOrRemove);
17      
112     
112     
20          event UpdateThreshold(uint8 threshold);
23           * @notice Constructs the Keepers multisignature wallet with a set of owners and a threshold for transaction execution
19          event UpdateOwners(address[] owners, bool[] addOrRemove);
17      
112     
112     
20          event UpdateThreshold(uint8 threshold);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/governance/NoyaGovernanceBase.sol


23              registry = _registry;
19           */
17           * @param _registry The PositionRegistry contract that stores governance addresses and other configurations for vaults
20      


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L0:0

```solidity
File: contracts/governance/TimeLock.sol




```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/TimeLock.sol#L0:0

```solidity
File: contracts/governance/Watchers.sol




```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Watchers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


28          uint256 public MINIMUM_HEALTH_FACTOR = 15e17;
31          uint256 public DUST_LEVEL = 1;
23          using SafeERC20 for IERC20;
19          INoyaValueOracle valueOracle;
17          uint256 vaultId;
112          * @param amounts The amounts for each token
112          * @param amounts The amounts for each token
20      }
23          using SafeERC20 for IERC20;
19          INoyaValueOracle valueOracle;
17          uint256 vaultId;
112          * @param amounts The amounts for each token
112          * @param amounts The amounts for each token
20      }
23          using SafeERC20 for IERC20;
19          INoyaValueOracle valueOracle;
17          uint256 vaultId;
112          * @param amounts The amounts for each token
112          * @param amounts The amounts for each token
20      }
23          using SafeERC20 for IERC20;
19          INoyaValueOracle valueOracle;
17          uint256 vaultId;
112          * @param amounts The amounts for each token
112          * @param amounts The amounts for each token
20      }
23          using SafeERC20 for IERC20;
19          INoyaValueOracle valueOracle;
17          uint256 vaultId;
112          * @param amounts The amounts for each token
112          * @param amounts The amounts for each token
20      }
23          using SafeERC20 for IERC20;
19          INoyaValueOracle valueOracle;
17          uint256 vaultId;
112          * @param amounts The amounts for each token
112          * @param amounts The amounts for each token
20      }
23          using SafeERC20 for IERC20;
19          INoyaValueOracle valueOracle;
17          uint256 vaultId;
112          * @param amounts The amounts for each token
112          * @param amounts The amounts for each token
20      }
23          using SafeERC20 for IERC20;
19          INoyaValueOracle valueOracle;
17          uint256 vaultId;
112          * @param amounts The amounts for each token
112          * @param amounts The amounts for each token
20      }
23          using SafeERC20 for IERC20;
19          INoyaValueOracle valueOracle;
17          uint256 vaultId;
112          * @param amounts The amounts for each token
112          * @param amounts The amounts for each token
20      }
23          using SafeERC20 for IERC20;
19          INoyaValueOracle valueOracle;
17          uint256 vaultId;
112          * @param amounts The amounts for each token
112          * @param amounts The amounts for each token
20      }
23          using SafeERC20 for IERC20;
19          INoyaValueOracle valueOracle;
17          uint256 vaultId;
112          * @param amounts The amounts for each token
112          * @param amounts The amounts for each token
20      }
23          using SafeERC20 for IERC20;
19          INoyaValueOracle valueOracle;
17          uint256 vaultId;
112          * @param amounts The amounts for each token
112          * @param amounts The amounts for each token
20      }
23          using SafeERC20 for IERC20;
19          INoyaValueOracle valueOracle;
17          uint256 vaultId;
112          * @param amounts The amounts for each token
112          * @param amounts The amounts for each token
20      }
23          using SafeERC20 for IERC20;
19          INoyaValueOracle valueOracle;
17          uint256 vaultId;
112          * @param amounts The amounts for each token
112          * @param amounts The amounts for each token
20      }
23          using SafeERC20 for IERC20;
19          INoyaValueOracle valueOracle;
17          uint256 vaultId;
112          * @param amounts The amounts for each token
112          * @param amounts The amounts for each token
20      }
23          using SafeERC20 for IERC20;
19          INoyaValueOracle valueOracle;
17          uint256 vaultId;
112          * @param amounts The amounts for each token
112          * @param amounts The amounts for each token
20      }
23          using SafeERC20 for IERC20;
19          INoyaValueOracle valueOracle;
17          uint256 vaultId;
112          * @param amounts The amounts for each token
112          * @param amounts The amounts for each token
20      }
23          using SafeERC20 for IERC20;
19          INoyaValueOracle valueOracle;
17          uint256 vaultId;
112          * @param amounts The amounts for each token
112          * @param amounts The amounts for each token
20      }
23          using SafeERC20 for IERC20;
19          INoyaValueOracle valueOracle;
17          uint256 vaultId;
112          * @param amounts The amounts for each token
112          * @param amounts The amounts for each token
20      }
23          using SafeERC20 for IERC20;
19          INoyaValueOracle valueOracle;
17          uint256 vaultId;
112          * @param amounts The amounts for each token
112          * @param amounts The amounts for each token
20      }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


23              registry = PositionRegistry(_registry);
19      
17          uint256 public vaultId = 0;
20          uint256 public constant positionType = 1;
23              registry = PositionRegistry(_registry);
19      
17          uint256 public vaultId = 0;
20          uint256 public constant positionType = 1;
23              registry = PositionRegistry(_registry);
19      
17          uint256 public vaultId = 0;
20          uint256 public constant positionType = 1;
23              registry = PositionRegistry(_registry);
19      
17          uint256 public vaultId = 0;
20          uint256 public constant positionType = 1;
23              registry = PositionRegistry(_registry);
19      
17          uint256 public vaultId = 0;
20          uint256 public constant positionType = 1;
23              registry = PositionRegistry(_registry);
19      
17          uint256 public vaultId = 0;
20          uint256 public constant positionType = 1;
23              registry = PositionRegistry(_registry);
19      
17          uint256 public vaultId = 0;
20          uint256 public constant positionType = 1;
23              registry = PositionRegistry(_registry);
19      
17          uint256 public vaultId = 0;
20          uint256 public constant positionType = 1;
23              registry = PositionRegistry(_registry);
19      
17          uint256 public vaultId = 0;
20          uint256 public constant positionType = 1;
23              registry = PositionRegistry(_registry);
19      
17          uint256 public vaultId = 0;
20          uint256 public constant positionType = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


23      
19          mapping(uint32 => ChainInfo) public chainInfo; // chainId => ChainInfo
17      
20          mapping(uint256 => VaultInfo) public vaultIdToVaultInfo; // vaultId => VaultInfo
23      
19          mapping(uint32 => ChainInfo) public chainInfo; // chainId => ChainInfo
17      
20          mapping(uint256 => VaultInfo) public vaultIdToVaultInfo; // vaultId => VaultInfo
23      
19          mapping(uint32 => ChainInfo) public chainInfo; // chainId => ChainInfo
17      
20          mapping(uint256 => VaultInfo) public vaultIdToVaultInfo; // vaultId => VaultInfo
23      
19          mapping(uint32 => ChainInfo) public chainInfo; // chainId => ChainInfo
17      
20          mapping(uint256 => VaultInfo) public vaultIdToVaultInfo; // vaultId => VaultInfo


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


23          bytes messageSetting;
19      contract LZHelperSender is OAppSender {
17      }
20          mapping(uint256 => ChainInfo) public chainInfo; // chainId => ChainInfo
23          bytes messageSetting;
19      contract LZHelperSender is OAppSender {
17      }
20          mapping(uint256 => ChainInfo) public chainInfo; // chainId => ChainInfo
23          bytes messageSetting;
19      contract LZHelperSender is OAppSender {
17      }
20          mapping(uint256 => ChainInfo) public chainInfo; // chainId => ChainInfo
23          bytes messageSetting;
19      contract LZHelperSender is OAppSender {
17      }
20          mapping(uint256 => ChainInfo) public chainInfo; // chainId => ChainInfo
23          bytes messageSetting;
19      contract LZHelperSender is OAppSender {
17      }
20          mapping(uint256 => ChainInfo) public chainInfo; // chainId => ChainInfo
23          bytes messageSetting;
19      contract LZHelperSender is OAppSender {
17      }
20          mapping(uint256 => ChainInfo) public chainInfo; // chainId => ChainInfo
23          bytes messageSetting;
19      contract LZHelperSender is OAppSender {
17      }
20          mapping(uint256 => ChainInfo) public chainInfo; // chainId => ChainInfo


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


23      
19          uint256 public constant BRIDGE_TXN_WAITING_TIME = 30 minutes;
17          address payable public lzHelper;
20      
23      
19          uint256 public constant BRIDGE_TXN_WAITING_TIME = 30 minutes;
17          address payable public lzHelper;
20      
23      
19          uint256 public constant BRIDGE_TXN_WAITING_TIME = 30 minutes;
17          address payable public lzHelper;
20      
23      
19          uint256 public constant BRIDGE_TXN_WAITING_TIME = 30 minutes;
17          address payable public lzHelper;
20      


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


23          }
19          constructor(uint256 dl, address payable _lzHelper, BaseConnectorCP memory baseConnectorParams)
17           */
20              OmnichainLogic(_lzHelper, baseConnectorParams)
23          }
19          constructor(uint256 dl, address payable _lzHelper, BaseConnectorCP memory baseConnectorParams)
17           */
20              OmnichainLogic(_lzHelper, baseConnectorParams)
23          }
19          constructor(uint256 dl, address payable _lzHelper, BaseConnectorCP memory baseConnectorParams)
17           */
20              OmnichainLogic(_lzHelper, baseConnectorParams)


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol


23          /**
19          function getTVL() public view returns (uint256) {
17           */
20              (, address baseToken) = registry.getVaultAddresses(vaultId);
23          /**
19          function getTVL() public view returns (uint256) {
17           */
20              (, address baseToken) = registry.getVaultAddresses(vaultId);
23          /**
19          function getTVL() public view returns (uint256) {
17           */
20              (, address baseToken) = registry.getVaultAddresses(vaultId);
23          /**
19          function getTVL() public view returns (uint256) {
17           */
20              (, address baseToken) = registry.getVaultAddresses(vaultId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


23      
19          event SetValueOracle(address _valueOracle);
17          RouteData[] public routes;
112                 _swapRequest.minAmount = (((1e6 - _slippageTolerance) * _outputTokenValue) / 1e6);
112                 _swapRequest.minAmount = (((1e6 - _slippageTolerance) * _outputTokenValue) / 1e6);
20          event SetSlippageTolerance(address _inputToken, address _outputToken, uint256 _slippageTolerance);
23      
19          event SetValueOracle(address _valueOracle);
17          RouteData[] public routes;
112                 _swapRequest.minAmount = (((1e6 - _slippageTolerance) * _outputTokenValue) / 1e6);
112                 _swapRequest.minAmount = (((1e6 - _slippageTolerance) * _outputTokenValue) / 1e6);
20          event SetSlippageTolerance(address _inputToken, address _outputToken, uint256 _slippageTolerance);
23      
19          event SetValueOracle(address _valueOracle);
17          RouteData[] public routes;
112                 _swapRequest.minAmount = (((1e6 - _slippageTolerance) * _outputTokenValue) / 1e6);
112                 _swapRequest.minAmount = (((1e6 - _slippageTolerance) * _outputTokenValue) / 1e6);
20          event SetSlippageTolerance(address _inputToken, address _outputToken, uint256 _slippageTolerance);
23      
19          event SetValueOracle(address _valueOracle);
17          RouteData[] public routes;
112                 _swapRequest.minAmount = (((1e6 - _slippageTolerance) * _outputTokenValue) / 1e6);
112                 _swapRequest.minAmount = (((1e6 - _slippageTolerance) * _outputTokenValue) / 1e6);
20          event SetSlippageTolerance(address _inputToken, address _outputToken, uint256 _slippageTolerance);
23      
19          event SetValueOracle(address _valueOracle);
17          RouteData[] public routes;
112                 _swapRequest.minAmount = (((1e6 - _slippageTolerance) * _outputTokenValue) / 1e6);
112                 _swapRequest.minAmount = (((1e6 - _slippageTolerance) * _outputTokenValue) / 1e6);
20          event SetSlippageTolerance(address _inputToken, address _outputToken, uint256 _slippageTolerance);
23      
19          event SetValueOracle(address _valueOracle);
17          RouteData[] public routes;
112                 _swapRequest.minAmount = (((1e6 - _slippageTolerance) * _outputTokenValue) / 1e6);
112                 _swapRequest.minAmount = (((1e6 - _slippageTolerance) * _outputTokenValue) / 1e6);
20          event SetSlippageTolerance(address _inputToken, address _outputToken, uint256 _slippageTolerance);
23      
19          event SetValueOracle(address _valueOracle);
17          RouteData[] public routes;
112                 _swapRequest.minAmount = (((1e6 - _slippageTolerance) * _outputTokenValue) / 1e6);
112                 _swapRequest.minAmount = (((1e6 - _slippageTolerance) * _outputTokenValue) / 1e6);
20          event SetSlippageTolerance(address _inputToken, address _outputToken, uint256 _slippageTolerance);
23      
19          event SetValueOracle(address _valueOracle);
17          RouteData[] public routes;
112                 _swapRequest.minAmount = (((1e6 - _slippageTolerance) * _outputTokenValue) / 1e6);
112                 _swapRequest.minAmount = (((1e6 - _slippageTolerance) * _outputTokenValue) / 1e6);
20          event SetSlippageTolerance(address _inputToken, address _outputToken, uint256 _slippageTolerance);
23      
19          event SetValueOracle(address _valueOracle);
17          RouteData[] public routes;
112                 _swapRequest.minAmount = (((1e6 - _slippageTolerance) * _outputTokenValue) / 1e6);
112                 _swapRequest.minAmount = (((1e6 - _slippageTolerance) * _outputTokenValue) / 1e6);
20          event SetSlippageTolerance(address _inputToken, address _outputToken, uint256 _slippageTolerance);
23      
19          event SetValueOracle(address _valueOracle);
17          RouteData[] public routes;
112                 _swapRequest.minAmount = (((1e6 - _slippageTolerance) * _outputTokenValue) / 1e6);
112                 _swapRequest.minAmount = (((1e6 - _slippageTolerance) * _outputTokenValue) / 1e6);
20          event SetSlippageTolerance(address _inputToken, address _outputToken, uint256 _slippageTolerance);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


23          event Bridged(address bridge, address token, uint256 amount, bytes data);
19      
17      
112             if (selector != LI_FI_GENERIC_SWAP_SELECTOR) {
112             if (selector != LI_FI_GENERIC_SWAP_SELECTOR) {
20          event AddedHandler(address _handler, bool state);
23          event Bridged(address bridge, address token, uint256 amount, bytes data);
19      
17      
112             if (selector != LI_FI_GENERIC_SWAP_SELECTOR) {
112             if (selector != LI_FI_GENERIC_SWAP_SELECTOR) {
20          event AddedHandler(address _handler, bool state);
23          event Bridged(address bridge, address token, uint256 amount, bytes data);
19      
17      
112             if (selector != LI_FI_GENERIC_SWAP_SELECTOR) {
112             if (selector != LI_FI_GENERIC_SWAP_SELECTOR) {
20          event AddedHandler(address _handler, bool state);
23          event Bridged(address bridge, address token, uint256 amount, bytes data);
19      
17      
112             if (selector != LI_FI_GENERIC_SWAP_SELECTOR) {
112             if (selector != LI_FI_GENERIC_SWAP_SELECTOR) {
20          event AddedHandler(address _handler, bool state);
23          event Bridged(address bridge, address token, uint256 amount, bytes data);
19      
17      
112             if (selector != LI_FI_GENERIC_SWAP_SELECTOR) {
112             if (selector != LI_FI_GENERIC_SWAP_SELECTOR) {
20          event AddedHandler(address _handler, bool state);
23          event Bridged(address bridge, address token, uint256 amount, bytes data);
19      
17      
112             if (selector != LI_FI_GENERIC_SWAP_SELECTOR) {
112             if (selector != LI_FI_GENERIC_SWAP_SELECTOR) {
20          event AddedHandler(address _handler, bool state);
23          event Bridged(address bridge, address token, uint256 amount, bytes data);
19      
17      
112             if (selector != LI_FI_GENERIC_SWAP_SELECTOR) {
112             if (selector != LI_FI_GENERIC_SWAP_SELECTOR) {
20          event AddedHandler(address _handler, bool state);
23          event Bridged(address bridge, address token, uint256 amount, bytes data);
19      
17      
112             if (selector != LI_FI_GENERIC_SWAP_SELECTOR) {
112             if (selector != LI_FI_GENERIC_SWAP_SELECTOR) {
20          event AddedHandler(address _handler, bool state);
23          event Bridged(address bridge, address token, uint256 amount, bytes data);
19      
17      
112             if (selector != LI_FI_GENERIC_SWAP_SELECTOR) {
112             if (selector != LI_FI_GENERIC_SWAP_SELECTOR) {
20          event AddedHandler(address _handler, bool state);
23          event Bridged(address bridge, address token, uint256 amount, bytes data);
19      
17      
112             if (selector != LI_FI_GENERIC_SWAP_SELECTOR) {
112             if (selector != LI_FI_GENERIC_SWAP_SELECTOR) {
20          event AddedHandler(address _handler, bool state);
23          event Bridged(address bridge, address token, uint256 amount, bytes data);
19      
17      
112             if (selector != LI_FI_GENERIC_SWAP_SELECTOR) {
112             if (selector != LI_FI_GENERIC_SWAP_SELECTOR) {
20          event AddedHandler(address _handler, bool state);
23          event Bridged(address bridge, address token, uint256 amount, bytes data);
19      
17      
112             if (selector != LI_FI_GENERIC_SWAP_SELECTOR) {
112             if (selector != LI_FI_GENERIC_SWAP_SELECTOR) {
20          event AddedHandler(address _handler, bool state);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/TVLHelper.sol


23                  bool isPositionDebt = registry.isPositionDebt(vaultId, positions[i].positionId);
19                  if (positions[i].calculatorConnector == address(0)) {
17              HoldingPI[] memory positions = registry.getHoldingPositions(vaultId);
20                      continue;
23                  bool isPositionDebt = registry.isPositionDebt(vaultId, positions[i].positionId);
19                  if (positions[i].calculatorConnector == address(0)) {
17              HoldingPI[] memory positions = registry.getHoldingPositions(vaultId);
20                      continue;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/TVLHelper.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


23      
19      
17      
112     
112     
20          event UpdatedDefaultPriceSource(address[] baseCurrencies, INoyaValueOracle[] oracles);
23      
19      
17      
112     
112     
20          event UpdatedDefaultPriceSource(address[] baseCurrencies, INoyaValueOracle[] oracles);
23      
19      
17      
112     
112     
20          event UpdatedDefaultPriceSource(address[] baseCurrencies, INoyaValueOracle[] oracles);
23      
19      
17      
112     
112     
20          event UpdatedDefaultPriceSource(address[] baseCurrencies, INoyaValueOracle[] oracles);
23      
19      
17      
112     
112     
20          event UpdatedDefaultPriceSource(address[] baseCurrencies, INoyaValueOracle[] oracles);
23      
19      
17      
112     
112     
20          event UpdatedDefaultPriceSource(address[] baseCurrencies, INoyaValueOracle[] oracles);
23      
19      
17      
112     
112     
20          event UpdatedDefaultPriceSource(address[] baseCurrencies, INoyaValueOracle[] oracles);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


23          * @notice The addresses that represents ETH and USD
19          */
17          * @notice The address of the source of each pair of assets
112         * @dev The chainlink price feed data should be up to date
112         * @dev The chainlink price feed data should be up to date
20          mapping(address => mapping(address => address)) private assetsSources;
23          * @notice The addresses that represents ETH and USD
19          */
17          * @notice The address of the source of each pair of assets
112         * @dev The chainlink price feed data should be up to date
112         * @dev The chainlink price feed data should be up to date
20          mapping(address => mapping(address => address)) private assetsSources;
23          * @notice The addresses that represents ETH and USD
19          */
17          * @notice The address of the source of each pair of assets
112         * @dev The chainlink price feed data should be up to date
112         * @dev The chainlink price feed data should be up to date
20          mapping(address => mapping(address => address)) private assetsSources;
23          * @notice The addresses that represents ETH and USD
19          */
17          * @notice The address of the source of each pair of assets
112         * @dev The chainlink price feed data should be up to date
112         * @dev The chainlink price feed data should be up to date
20          mapping(address => mapping(address => address)) private assetsSources;
23          * @notice The addresses that represents ETH and USD
19          */
17          * @notice The address of the source of each pair of assets
112         * @dev The chainlink price feed data should be up to date
112         * @dev The chainlink price feed data should be up to date
20          mapping(address => mapping(address => address)) private assetsSources;
23          * @notice The addresses that represents ETH and USD
19          */
17          * @notice The address of the source of each pair of assets
112         * @dev The chainlink price feed data should be up to date
112         * @dev The chainlink price feed data should be up to date
20          mapping(address => mapping(address => address)) private assetsSources;
23          * @notice The addresses that represents ETH and USD
19          */
17          * @notice The address of the source of each pair of assets
112         * @dev The chainlink price feed data should be up to date
112         * @dev The chainlink price feed data should be up to date
20          mapping(address => mapping(address => address)) private assetsSources;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


23      
19          uint32 public period = 1800;
17          PositionRegistry public registry;
20      
23      
19          uint32 public period = 1800;
17          PositionRegistry public registry;
20      
23      
19          uint32 public period = 1800;
17          PositionRegistry public registry;
20      
23      
19          uint32 public period = 1800;
17          PositionRegistry public registry;
20      


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/WETH_Oracle.sol




```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/WETH_Oracle.sol#L0:0

</details>

## NC080 - Unnecessary cast:

The variable is being cast to its own type


<details>
<summary>Click to show 4 findings</summary>

```solidity
File: contracts/connectors/AerodromeConnector.sol


102             IERC20(pool).forceApprove(address(gauge), liquidity);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


58              _updateTokenInRegistry(address(AURA));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


65              IRewards(rewardContract).claim(address(market), address(this), true);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


96                  IERC20(token).safeTransfer(address(accountingManager), newAmount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

</details>

## NC081 - Visibility should be set explicitly rather than defaulting to internal:

Visibility of state variables should be set explicitly rather than defaulting to internal.


<details>
<summary>Click to show 8 findings</summary>

```solidity
File: contracts/connectors/AaveConnector.sol


18          address immutable pool;
22          address immutable poolBaseToken;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


33          IRouter aerodromeRouter;
34          IVoter voter;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


17          address caller;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


30          address mav;
31          address veMav;
32          address maverickRouter;
33          IPositionInspector positionInspector;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


14          uint256 constant ORACLE_PRICE_SCALE = 1e36;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


22          IStargateLPStaking LPStaking;
23          IStargateRouter stargateRouter;
24          address rewardToken;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


24          uint32 constant TVL_UPDATE = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


23          bytes messageSetting;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

</details>

## NC082 - Event declarations should have NatSpec @param annotations:

Documents a parameter just like in Doxygen (must be followed by parameter name)


<details>
<summary>Click to show 25 findings</summary>

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


12          event ManagementFeeReceived(address indexed token, uint256 amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


26          event Supply(address supplyToken, uint256 amount);
27          event Borrow(address borrowToken, uint256 amount);
28          event Repay(address repayToken, uint256 amount, uint256 i);
29          event RepayWithCollateral(address repayToken, uint256 amount, uint256 i);
30          event WithdrawCollateral(address collateral, uint256 amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


36          event Supply(address pool, uint256 amount0, uint256 amount1);
37          event Withdraw(address pool, uint256 amountLiquidity);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


34          event OpenPosition(
37          event DecreasePosition(DecreasePositionParams p);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


21          event MakeFlashLoan(IERC20[] tokens, uint256[] amounts);
22          event ReceiveFlashLoan(IERC20[] tokens, uint256[] amounts, uint256[] feeAmounts, bytes userData);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


10          event Supply(address market, address asset, uint256 amount);
11          event WithdrawOrBorrow(address market, address asset, uint256 amount);
12          event ClaimRewards(address rewardContract, address market);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


33          event OpenCurvePosition(address pool, uint256 depositIndex, uint256 amount, uint256 minAmount);
34          event DecreaseCurvePosition(address pool, uint256 withdrawIndex, uint256 amount, uint256 minAmount);
35          event WithdrawFromConvexBooster(uint256 pid, uint256 amount);
36          event WithdrawFromConvexRewardPool(address pool, uint256 amount);
37          event WithdrawFromGauge(address pool, uint256 amount);
38          event WithdrawFromPrisma(address depostiToken, uint256 amount);
39          event HarvestRewards(address[] gauges);
40          event HarvestPrismaRewards(address[] pools);
41          event HarvestConvexRewards(address[] rewardsPools);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


24          event BorrowAndSupply(address pool, uint256 borrowAmount, uint256 collateralAmount);
25          event Withdraw(address pool, uint256 withdrawAmount);
26          event Repay(address pool, uint256 sharesToRepay);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


11          event OpenAccount(address facade, uint256 ref);
12          event CloseAccount(address facade, address creditAccount);
13          event ExecuteCommands(


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


15          event Deposit(uint256 amountIn);
16          event RequestWithdrawals(uint256 amount);
17          event ClaimWithdrawal(uint256 requestId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


37          event Stake(uint256 amount, uint256 duration, bool doDelegation);
38          event Unstake(uint256 lockupId);
39          event AddLiquidityInMaverickPool(MavericAddLiquidityParams p);
40          event RemoveLiquidityFromMaverickPool(MavericRemoveLiquidityParams p);
41          event ClaimBoostedPositionRewards(IMaverickReward rewardContract);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


17          event Supply(uint256 amount, Id id, bool sOrC);
18          event Withdraw(uint256 amount, Id id, bool sOrC);
19          event Borrow(uint256 amount, Id id);
20          event Repay(uint256 amount, Id id);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


14          event SendPositionToMasterChef(uint256 tokenId);
15          event UpdatePosition(uint256 tokenId);
16          event Withdraw(uint256 tokenId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


35          event Supply(address market, uint256 amount);
36          event MintPTAndYT(address market, uint256 syAmount);
37          event DepositIntoMarket(address market, uint256 SYamount, uint256 PTamount);
38          event DepositIntoPenpie(address market, uint256 amount);
39          event WithdrawFromPenpie(address market, uint256 amount);
40          event SwapYTForPT(address market, uint256 exactYTIn, uint256 min, ApproxParams guess);
41          event SwapYTForSY(address market, uint256 exactYTIn, uint256 min, LimitOrderData orderData);
42          event SwapExactPTForSY(address market, uint256 exactPTIn, bytes swapData, uint256 minSY);
43          event BurnLP(address market, uint256 amount);
44          event DecreasePosition(address market, uint256 amount, bool closePosition);
45          event ClaimRewards(address market);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


16          event OpenTrove(address zap, address tm, uint256 maxFee, uint256 dAmount, uint256 bAmount);
17          event AddColl(address zap, address tm, uint256 amountIn);
18          event AdjustTrove(address zap, address tm, uint256 mFee, uint256 wAmount, uint256 bAmount, bool isBorrowing);
19          event CloseTrove(address zap, address troveManager);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


12          event Deposit(address siloToken, address dToken, uint256 amount, bool oC);
13          event Withdraw(address siloToken, address wToken, uint256 amount, bool oC, bool closePosition);
14          event Borrow(address siloToken, address bToken, uint256 amount);
15          event Repay(address siloToken, address rToken, uint256 amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


28          event DepositIntoStargatePool(StargateRequest depositRequest);
29          event WithdrawFromStargatePool(StargateRequest withdrawRequest);
30          event ClaimStargateRewards(uint256 poolId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


21          event OpenPosition(MintParams p, uint256 tokenId);
22          event DecreasePosition(DecreaseLiquidityParams p);
23          event IncreasePosition(IncreaseLiquidityParams p);
24          event CollectFees(uint256 tokenId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


18          event Execute(address indexed destination, bytes data, uint256 gasLimit, address executor, uint256 deadline);
19          event UpdateOwners(address[] owners, bool[] addOrRemove);
20          event UpdateThreshold(uint8 threshold);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


24          event UpdateChainInfo(uint256 chainId, address destinationAddress);
25          event UpdateBridgeTransactionApproval(bytes32 transactionHash, uint256 timestamp);
26          event StartBridgeTransaction(BridgeRequest bridgeRequest, bytes32 transactionHash);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


19          event SetValueOracle(address _valueOracle);
20          event SetSlippageTolerance(address _inputToken, address _outputToken, uint256 _slippageTolerance);
21          event AddEligibleUser(address _user);
22          event BridgeExecutionCompleted(BridgeRequest _bridgeRequest);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


20          event AddedHandler(address _handler, bool state);
21          event AddedChain(uint256 _chainId, bool state);
22          event AddedBridgeBlacklist(string bridgeName, bool state);
23          event Bridged(address bridge, address token, uint256 amount, bytes data);
24          event Rescued(address token, address userAddress, uint256 amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


20          event UpdatedDefaultPriceSource(address[] baseCurrencies, INoyaValueOracle[] oracles);
21          event UpdatedAssetPriceSource(address[] asset, address[] baseToken, address[] oracle);
22          event UpdatedPriceRoute(address asset, address baseToken, address[] s);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


31          event AssetSourceUpdated(address indexed asset, address indexed baseToken, address indexed source);
32          event ChainlinkPriceAgeThresholdUpdated(uint256 newThreshold);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


21          event NewPeriod(uint32 period);
22          event PoolsForAsset(address indexed asset, address indexed base, address indexed pool);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## NC083 - Event declarations should have NatSpec @dev annotations:

Explain to a developer any extra details


<details>
<summary>Click to show 25 findings</summary>

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


12          event ManagementFeeReceived(address indexed token, uint256 amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


26          event Supply(address supplyToken, uint256 amount);
27          event Borrow(address borrowToken, uint256 amount);
28          event Repay(address repayToken, uint256 amount, uint256 i);
29          event RepayWithCollateral(address repayToken, uint256 amount, uint256 i);
30          event WithdrawCollateral(address collateral, uint256 amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


36          event Supply(address pool, uint256 amount0, uint256 amount1);
37          event Withdraw(address pool, uint256 amountLiquidity);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


34          event OpenPosition(
37          event DecreasePosition(DecreasePositionParams p);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


21          event MakeFlashLoan(IERC20[] tokens, uint256[] amounts);
22          event ReceiveFlashLoan(IERC20[] tokens, uint256[] amounts, uint256[] feeAmounts, bytes userData);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


10          event Supply(address market, address asset, uint256 amount);
11          event WithdrawOrBorrow(address market, address asset, uint256 amount);
12          event ClaimRewards(address rewardContract, address market);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


33          event OpenCurvePosition(address pool, uint256 depositIndex, uint256 amount, uint256 minAmount);
34          event DecreaseCurvePosition(address pool, uint256 withdrawIndex, uint256 amount, uint256 minAmount);
35          event WithdrawFromConvexBooster(uint256 pid, uint256 amount);
36          event WithdrawFromConvexRewardPool(address pool, uint256 amount);
37          event WithdrawFromGauge(address pool, uint256 amount);
38          event WithdrawFromPrisma(address depostiToken, uint256 amount);
39          event HarvestRewards(address[] gauges);
40          event HarvestPrismaRewards(address[] pools);
41          event HarvestConvexRewards(address[] rewardsPools);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


24          event BorrowAndSupply(address pool, uint256 borrowAmount, uint256 collateralAmount);
25          event Withdraw(address pool, uint256 withdrawAmount);
26          event Repay(address pool, uint256 sharesToRepay);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


11          event OpenAccount(address facade, uint256 ref);
12          event CloseAccount(address facade, address creditAccount);
13          event ExecuteCommands(


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


15          event Deposit(uint256 amountIn);
16          event RequestWithdrawals(uint256 amount);
17          event ClaimWithdrawal(uint256 requestId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


37          event Stake(uint256 amount, uint256 duration, bool doDelegation);
38          event Unstake(uint256 lockupId);
39          event AddLiquidityInMaverickPool(MavericAddLiquidityParams p);
40          event RemoveLiquidityFromMaverickPool(MavericRemoveLiquidityParams p);
41          event ClaimBoostedPositionRewards(IMaverickReward rewardContract);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


17          event Supply(uint256 amount, Id id, bool sOrC);
18          event Withdraw(uint256 amount, Id id, bool sOrC);
19          event Borrow(uint256 amount, Id id);
20          event Repay(uint256 amount, Id id);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


14          event SendPositionToMasterChef(uint256 tokenId);
15          event UpdatePosition(uint256 tokenId);
16          event Withdraw(uint256 tokenId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


35          event Supply(address market, uint256 amount);
36          event MintPTAndYT(address market, uint256 syAmount);
37          event DepositIntoMarket(address market, uint256 SYamount, uint256 PTamount);
38          event DepositIntoPenpie(address market, uint256 amount);
39          event WithdrawFromPenpie(address market, uint256 amount);
40          event SwapYTForPT(address market, uint256 exactYTIn, uint256 min, ApproxParams guess);
41          event SwapYTForSY(address market, uint256 exactYTIn, uint256 min, LimitOrderData orderData);
42          event SwapExactPTForSY(address market, uint256 exactPTIn, bytes swapData, uint256 minSY);
43          event BurnLP(address market, uint256 amount);
44          event DecreasePosition(address market, uint256 amount, bool closePosition);
45          event ClaimRewards(address market);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


16          event OpenTrove(address zap, address tm, uint256 maxFee, uint256 dAmount, uint256 bAmount);
17          event AddColl(address zap, address tm, uint256 amountIn);
18          event AdjustTrove(address zap, address tm, uint256 mFee, uint256 wAmount, uint256 bAmount, bool isBorrowing);
19          event CloseTrove(address zap, address troveManager);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


12          event Deposit(address siloToken, address dToken, uint256 amount, bool oC);
13          event Withdraw(address siloToken, address wToken, uint256 amount, bool oC, bool closePosition);
14          event Borrow(address siloToken, address bToken, uint256 amount);
15          event Repay(address siloToken, address rToken, uint256 amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


28          event DepositIntoStargatePool(StargateRequest depositRequest);
29          event WithdrawFromStargatePool(StargateRequest withdrawRequest);
30          event ClaimStargateRewards(uint256 poolId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


21          event OpenPosition(MintParams p, uint256 tokenId);
22          event DecreasePosition(DecreaseLiquidityParams p);
23          event IncreasePosition(IncreaseLiquidityParams p);
24          event CollectFees(uint256 tokenId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


18          event Execute(address indexed destination, bytes data, uint256 gasLimit, address executor, uint256 deadline);
19          event UpdateOwners(address[] owners, bool[] addOrRemove);
20          event UpdateThreshold(uint8 threshold);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


24          event UpdateChainInfo(uint256 chainId, address destinationAddress);
25          event UpdateBridgeTransactionApproval(bytes32 transactionHash, uint256 timestamp);
26          event StartBridgeTransaction(BridgeRequest bridgeRequest, bytes32 transactionHash);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


19          event SetValueOracle(address _valueOracle);
20          event SetSlippageTolerance(address _inputToken, address _outputToken, uint256 _slippageTolerance);
21          event AddEligibleUser(address _user);
22          event BridgeExecutionCompleted(BridgeRequest _bridgeRequest);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


20          event AddedHandler(address _handler, bool state);
21          event AddedChain(uint256 _chainId, bool state);
22          event AddedBridgeBlacklist(string bridgeName, bool state);
23          event Bridged(address bridge, address token, uint256 amount, bytes data);
24          event Rescued(address token, address userAddress, uint256 amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


20          event UpdatedDefaultPriceSource(address[] baseCurrencies, INoyaValueOracle[] oracles);
21          event UpdatedAssetPriceSource(address[] asset, address[] baseToken, address[] oracle);
22          event UpdatedPriceRoute(address asset, address baseToken, address[] s);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


31          event AssetSourceUpdated(address indexed asset, address indexed baseToken, address indexed source);
32          event ChainlinkPriceAgeThresholdUpdated(uint256 newThreshold);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


21          event NewPeriod(uint32 period);
22          event PoolsForAsset(address indexed asset, address indexed base, address indexed pool);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## NC084 - Function definitions should have NatSpec @dev annotations:

Explain to a developer any extra details


<details>
<summary>Click to show 41 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


94          constructor(AccountingManagerConstructorParams memory p)
124         function updateValueOracle(INoyaValueOracle _valueOracle) public onlyMaintainer {
150         function sendTokensToTrustedAddress(address token, uint256 amount, address _caller, bytes calldata _data)
185         function _update(address from, address to, uint256 amount) internal override {
200         function deposit(address receiver, uint256 amount, address referrer) public nonReentrant whenNotPaused {
304         function withdraw(uint256 share, address receiver) public nonReentrant whenNotPaused {
328         function calculateWithdrawShares(uint256 maxIterations) public onlyManager nonReentrant whenNotPaused {
526         function collectPerformanceFees() public onlyManager nonReentrant {
543         function burnShares(uint256 amount) public {
548         function retrieveTokensForWithdraw(RetrieveData[] calldata retrieveData) public onlyManager nonReentrant {
582         function getProfit() public view returns (uint256) {
591         function totalAssets() public view override returns (uint256) {
596         function getQueueItems(bool depositOrWithdraw, uint256[] memory items)
616         function neededAssetsForWithdraw() public view returns (uint256) {
627         function TVL() public view returns (uint256) {
632         function getPositionTVL(HoldingPI memory position, address base) public view returns (uint256) {
642         function _getValue(address token, address base, uint256 amount) internal view returns (uint256) {
649         function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {
659         function emergencyStop() public whenNotPaused onlyEmergency {
663         function unpause() public whenPaused onlyEmergency {
667         function setDepositLimits(uint256 _depositLimitPerTransaction, uint256 _depositTotalAmount) public onlyMaintainer {
673         function changeDepositWaitingTime(uint256 _depositWaitingTime) public onlyMaintainer {
678         function changeWithdrawWaitingTime(uint256 _withdrawWaitingTime) public onlyMaintainer {
683         function rescue(address token, uint256 amount) public onlyEmergency nonReentrant {
693         function mint(uint256 shares, address receiver) public override returns (uint256) {
697         function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256) {
701         function redeem(uint256 shares, address receiver, address shareOwner) public override returns (uint256) {
705         function deposit(uint256 assets, address receiver) public override returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


14          constructor(address _accountingManager, address _baseToken, address _receiver) Ownable(msg.sender) {
23          function withdrawShares(uint256 amount) external onlyOwner {
27          function burnShares(uint256 amount) external onlyOwner {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


79          function setMaxNumHoldingPositions(uint256 _maxNumHoldingPositions) external onlyRole(MAINTAINER_ROLE) {
84          function setFlashLoanAddress(address _flashLoan) external onlyRole(MAINTAINER_ROLE) {
394         function getHoldingPositionIndex(uint256 vaultId, bytes32 _positionId, address _connector, bytes memory data)
408         function getHoldingPosition(uint256 vaultId, uint256 i) public view returns (HoldingPI memory) {
416         function getHoldingPositions(uint256 vaultId) public view returns (HoldingPI[] memory) {
426         function isPositionTrusted(uint256 vaultId, bytes32 _positionId) public view returns (bool) {
436         function isPositionTrustedForConnector(uint256 vaultId, bytes32 _positionId, address connector)
449         function getGovernanceAddresses(uint256 vaultId)
470         function isTokenTrusted(uint256 vaultId, address token, address connector) public view returns (bool) {
486         function calculatePositionId(address calculatorConnector, uint256 positionTypeId, bytes memory data)
499         function isAnActiveConnector(uint256 vaultId, address connectorAddress) public view returns (bool) {
508         function isPositionDebt(uint256 vaultId, bytes32 _positionId) public view returns (bool) {
516         function getVaultAddresses(uint256 vaultId) public view returns (address, address) {
525         function isAddressTrusted(uint256 vaultId, address addr) public view returns (bool) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


33          constructor(address _pool, address _poolBaseToken, BaseConnectorCP memory baseConnectorParams)
46          function supply(address supplyToken, uint256 amount) external onlyManager nonReentrant {
62          function borrow(uint256 _amount, uint256 _interestRateMode, address _borrowAsset)
81          function repay(address asset, uint256 amount, uint256 i) external onlyManager nonReentrant {
88          function repayWithCollateral(uint256 _amount, uint256 i, address _borrowAsset) external onlyManager {
100         function withdrawCollateral(uint256 _collateralAmount, address _collateral) external onlyManager nonReentrant {
114         function _getPositionTVL(HoldingPI memory, address base) public view override returns (uint256 tvl) {
120         function _getUnderlyingTokens(uint256, bytes memory) public pure override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


40          constructor(address _router, address _voter, BaseConnectorCP memory baseConnectorParams)
53          function supply(DepositData memory data) public onlyManager nonReentrant {
79          function withdraw(WithdrawData memory data) public onlyManager nonReentrant {
100         function stake(address pool, uint256 liquidity) public onlyManager nonReentrant {
106         function unstake(address pool, uint256 liquidity) public onlyManager nonReentrant {
111         function claim(address pool) public onlyManager nonReentrant {
117         function _getUnderlyingTokens(uint256 p, bytes memory data) public view override returns (address[] memory) {
125         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


42          constructor(address _balancerVault, address bal, address aura, BaseConnectorCP memory baseConnectorParams)
53          function harvestAuraRewards(address[] calldata rewardsPools) public onlyManager nonReentrant {
64          function openPosition(
109         function depositIntoAuraBooster(bytes32 poolId, uint256 _amount) public onlyManager nonReentrant {
115         function decreasePosition(DecreasePositionParams memory p) public onlyManager nonReentrant {
162         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {
175         function totalLpBalanceOf(PoolInfo memory pool) public view returns (uint256) {
184         function totalLpBalanceOf(bytes32 poolId) public view returns (uint256) {
189         function _getPoolInfo(bytes32 pooId) internal view returns (PoolInfo memory, bytes32) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


24          constructor(address _balancerVault, PositionRegistry _registry) {
37          function makeFlashLoan(IERC20[] memory tokens, uint256[] memory amounts, bytes memory userData)
54          function receiveFlashLoan(


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


36          constructor(address _router, address _factory, BaseConnectorCP memory baseCP) BaseConnector(baseCP) {
43          function addLiquidityInCamelotPool(CamelotAddLiquidityParams calldata p) external onlyManager nonReentrant {
65          function removeLiquidityFromCamelotPool(CamelotRemoveLiquidityParams calldata p)
88          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
99          function _getUnderlyingTokens(uint256 id, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


17          constructor(BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) { }
29          function supply(address market, address asset, uint256 amount) external onlyManager nonReentrant {
63          function claimRewards(address rewardContract, address market) external onlyManager nonReentrant {
84          function getBorrowBalanceInBase(IComet comet) public view returns (uint256 borrowBalanceInVirtualBase) {
95          function getCollBlanace(IComet comet, bool riskAdjusted) public view returns (uint256 CollValue) {
125         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {
134         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


45          constructor(
68          function depositIntoGauge(address pool, uint256 amount) public onlyManager nonReentrant {
81          function depositIntoPrisma(address pool, uint256 amount, bool curveOrConvex) public onlyManager nonReentrant {
103         function depositIntoConvexBooster(address pool, uint256 pid, uint256 amount, bool stake) public onlyManager {
117         function openCurvePosition(address pool, uint256 depositIndex, uint256 amount, uint256 minAmount)
160         function decreaseCurvePosition(address pool, uint256 withdrawIndex, uint256 amount, uint256 minAmount)
182         function withdrawFromConvexBooster(uint256 pid, uint256 amount) public onlyManager {
192         function withdrawFromConvexRewardPool(address pool, uint256 amount) public onlyManager {
202         function withdrawFromGauge(address pool, uint256 amount) public onlyManager {
212         function withdrawFromPrisma(address depostiToken, uint256 amount) public onlyManager {
221         function harvestRewards(address[] calldata gauges) public onlyManager nonReentrant {
233         function harvestPrismaRewards(address[] calldata pools) public onlyManager nonReentrant {
247         function harvestConvexRewards(address[] calldata rewardsPools) public onlyManager nonReentrant {
258         function _getPoolInfo(address pool) internal view returns (PoolInfo memory) {
265         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
279         function LPToUnder(PoolInfo memory info, uint256 balance) public view returns (uint256, address) {
297         function estimateWithdrawAmount(ICurveSwap curvePool, uint256 amount, uint256 index)
311         function totalLpBalanceOf(PoolInfo memory info) public view returns (uint256) {
325         function balanceOfConvexRewardPool(PoolInfo memory info) public view returns (uint256) {
335         function balanceOfLPToken(PoolInfo memory info) public view returns (uint256) {
344         function balanceOfRewardPool(PoolInfo memory info) public view returns (uint256) {
354         function balanceOfPrisma(address prismaPool) public view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


18          constructor(
30          function deposit(uint256 marketId, uint256 _amount) public onlyManager nonReentrant {
43          function withdraw(uint256 marketId, uint256 _amount) public onlyManager nonReentrant {
58          function openBorrowPosition(uint256 marketId, uint256 _amountWei, uint256 accountId)
77          function transferBetweenAccounts(uint256 accountId, uint256 marketId, uint256 _amountWei, bool borrowOrRepay)
98          function closeBorrowPosition(uint256[] memory marketIds, uint256 accountId) public onlyManager nonReentrant {
106         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


29          constructor(BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) { }
38          function borrowAndSupply(IFraxPair pool, uint256 borrowAmount, uint256 collateralAmount)
68          function withdraw(IFraxPair pool, uint256 withdrawAmount) public onlyManager nonReentrant {
87          function repay(IFraxPair pool, uint256 sharesToRepay) public onlyManager nonReentrant {
104         function verifyHealthFactor(IFraxPair pool) public view {
120         function _getHealthFactor(IFraxPair _fraxlendPair, uint256 _exchangeRate) internal view virtual returns (uint256) {
142         function _getUnderlyingTokens(uint256 p, bytes memory data) public view override returns (address[] memory) {
150         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


17          constructor(BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) { }
24          function openAccount(address facade, uint256 ref) public onlyManager {
41          function closeAccount(address facade, address creditAccount) public onlyManager nonReentrant {
62          function executeCommands(
93          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


20          constructor(address _lido, address _lidoW, address _steth, address w, BaseConnectorCP memory baseConnectorParams)
37          function deposit(uint256 amountIn) external onlyManager nonReentrant {
51          function requestWithdrawals(uint256 amount) public onlyManager nonReentrant {
69          function claimWithdrawal(uint256 requestId) public onlyManager nonReentrant {
89          receive() external payable { }
91          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


43          constructor(address _mav, address _veMav, address mr, address pi, BaseConnectorCP memory baseCP)
56          receive() external payable { }
64          function stake(uint256 amount, uint256 duration, bool doDelegation) external onlyManager nonReentrant {
78          function unstake(uint256 lockupId) external onlyManager nonReentrant {
115         function removeLiquidityFromMaverickPool(MavericRemoveLiquidityParams calldata p)
137         function claimBoostedPositionRewards(IMaverickReward rewardContract) external onlyManager nonReentrant {
149         function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {
153         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
161         function _getUnderlyingTokens(uint256 id, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


23          constructor(address MB, BaseConnectorCP memory baseCP) BaseConnector(baseCP) {
35          function supply(uint256 amount, Id id, bool sOrC) external onlyManager nonReentrant {
58          function withdraw(uint256 amount, Id id, bool sOrC) external onlyManager nonReentrant {
80          function borrow(uint256 amount, Id id) external onlyManager nonReentrant {
95          function repay(uint256 amount, Id id) public onlyManager nonReentrant {
108         function getHealthFactor(Id _id, Market memory _market) public view returns (uint256) {
118         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
137         function convertCToL(uint256 amount, address marketOracle, address collateral) public view returns (uint256) {
141         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


19          constructor(address MC, address _positionManager, address _factory, BaseConnectorCP memory baseConnectorParams)
31          function sendPositionToMasterChef(uint256 tokenId) external onlyManager nonReentrant {
40          function updatePosition(uint256 tokenId) public onlyManager nonReentrant {
50          function withdraw(uint256 tokenId) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


57          constructor(address _pendleMarketDepositHelper, address _pendleRouter, address SR, BaseConnectorCP memory baseCP)
97          function mintPTAndYT(address market, uint256 syAmount) external onlyManager nonReentrant {
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
126         function depositIntoPenpie(address _market, uint256 _amount) public onlyManager nonReentrant {
137         function withdrawFromPenpie(address _market, uint256 _amount) public onlyManager nonReentrant {
149         function swapYTForPT(address market, uint256 exactYTIn, uint256 min, ApproxParams memory guess)
166         function swapYTForSY(address market, uint256 exactYTIn, uint256 min, LimitOrderData memory orderData)
183         function swapExactPTForSY(IPMarket market, uint256 exactPTIn, bytes calldata swapData, uint256 minSY)
203         function burnLP(IPMarket market, uint256 amount) external onlyManager nonReentrant {
216         function decreasePosition(IPMarket market, uint256 _amount, bool closePosition) external onlyManager nonReentrant {
241         function claimRewards(IPMarket market) external onlyManager nonReentrant {
257         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
293         function getYTValue(address market, uint256 balance) public view returns (uint256) {
303         function isMarketEmpty(IPMarket market) public view returns (bool) {
311         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


25          constructor(BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) { }
33          function approveZap(IStakeNTroveZap zap, address tm, bool approve) public onlyManager nonReentrant {
52          function openTrove(IStakeNTroveZap zap, address tm, uint256 maxFee, uint256 dAmount, uint256 bAmount)
75          function addColl(IStakeNTroveZap zapContract, address tm, uint256 amountIn) public onlyManager nonReentrant {
97          function adjustTrove(
129         function closeTrove(IStakeNTroveZap zapContract, address troveManager) public onlyManager nonReentrant {
145         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
164         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


20          constructor(address _SNXCoreProxy, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {
25          function createAccount() public onlyManager {
30          function deposit(address _token, uint256 _amount, uint128 _accountId) public onlyManager {
46          function withdraw(address _token, uint256 _amount, uint128 _accountId) public onlyManager {
64          function onERC721Received(address, address, uint256, bytes memory) external pure override returns (bytes4) {
68          function delegateIntoPreferredPool(
81          function delegateIntoApprovedPool(
94          function claimRewards(uint128 accountId, uint128 poolId, address collateralType, address distributor)
102         function mintOrBurnSUSD(
121         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
128         function _getUnderlyingTokens(uint256, bytes memory) public pure override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


17          constructor(address SR, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {
33          function deposit(address siloToken, address dToken, uint256 amount, bool oC) external onlyManager nonReentrant {
52          function withdraw(address siloToken, address wToken, uint256 amount, bool oC, bool closePosition)
71          function getData(address siloToken)
85          function borrow(address siloToken, address bToken, uint256 amount) external onlyManager nonReentrant {
98          function repay(address siloToken, address rToken, uint256 amount) external onlyManager nonReentrant {
109         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
130         function isSiloEmpty(ISilo silo) public view returns (bool) {
143         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


33          constructor(address lpStacking, address _stargateRouter, BaseConnectorCP memory baseConnectorParams)
49          function depositIntoStargatePool(StargateRequest calldata depositRequest) external onlyManager nonReentrant {
76          function withdrawFromStargatePool(StargateRequest calldata withdrawRequest) external onlyManager nonReentrant {
103         function claimStargateRewards(uint256 poolId) external onlyManager nonReentrant {
110         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
123         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


27          constructor(address _positionManager, address _factory, BaseConnectorCP memory baseConnectorParams)
40          function openPosition(MintParams memory p) external onlyManager nonReentrant returns (uint256 tokenId) {
63          function decreasePosition(DecreaseLiquidityParams memory p) external onlyManager nonReentrant {
87          function increasePosition(IncreaseLiquidityParams memory p) external onlyManager nonReentrant {
116         function getCurrentLiquidity(uint256 tokenId) public view returns (uint128, address, address) {
122         function _collectFees(uint256 tokenId) internal returns (uint256 amount0, uint256 amount1) {
127         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
152         function _getUnderlyingTokens(uint256, bytes memory data) public pure override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


27          constructor(address[] memory _owners, uint8 _threshold) EIP712("Keepers", "1") Ownable2Step() Ownable(msg.sender) {
42          function updateOwners(address[] memory _owners, bool[] memory addOrRemove) public onlyOwner {
63          function setThreshold(uint8 _threshold) public onlyOwner {
84          function execute(
124         function domainSeparatorV4() public view returns (bytes32) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/governance/NoyaGovernanceBase.sol


21          constructor(PositionRegistry _registry, uint256 _vaultId) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L0:0

```solidity
File: contracts/governance/TimeLock.sol


7           constructor(uint256 minDelay, address[] memory proposers, address[] memory executors, address owner)


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/TimeLock.sol#L0:0

```solidity
File: contracts/governance/Watchers.sol


7           constructor(address[] memory _owners, uint8 _threshold) Keepers(_owners, _threshold) { }
8           function verifyRemoveLiquidity(uint256 withdrawAmount, uint256 sentAmount, bytes memory data) external view { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Watchers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


33          constructor(BaseConnectorCP memory params) NoyaGovernanceBase(params.registry, params.vaultId) {
67          function updateValueOracle(address _valueOracle) external onlyMaintainer {
84          function sendTokensToTrustedAddress(address token, uint256 amount, address caller, bytes memory data)
122         function transferPositionToAnotherConnector(
153         function updateTokenInRegistry(address token) public onlyManager {
158         function _updateTokenInRegistry(address token) internal {
169         function addLiquidity(address[] memory tokens, uint256[] memory amounts, bytes memory data)
221         function _executeSwap(SwapRequest memory swapRequest) internal returns (uint256 amountOut) {
232         function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {
249         function getPositionTVL(HoldingPI memory p, address baseToken) public view returns (uint256) {
253         function _getValue(address token, address baseToken, uint256 amount) internal view returns (uint256) {
263         function _getUnderlyingTokens(uint256, bytes memory) public view virtual returns (address[] memory) {
267         function _addLiquidity(address[] memory, uint256[] memory, bytes memory) internal virtual returns (bool) {
271         function _getPositionTVL(HoldingPI memory, address) public view virtual returns (uint256 tvl) {
277         function _approveOperations(address _token, address _spender, uint256 _amount) internal virtual {
285         function _revokeApproval(address _token, address _spender) internal virtual {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


22          constructor(address _registry, uint256 _vaultId) {
27          function sendTokensToTrustedAddress(address token, uint256 amount, address caller, bytes memory data)
40          function addLiquidity(address[] memory tokens, uint256[] memory amounts, bytes memory data) external {
51          function updatePositionToRegistryUsingType(bytes32 _positionId, bytes memory data, bool remove) external {
59          function addPositionToRegistryUsingType(uint256 _positionType, bytes memory data) external {
65          function addPositionToRegistry(bytes memory data) external {
71          function getPositionTVL(HoldingPI memory p, address baseToken) public view returns (uint256) {
75          function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {
79          function _updateTokenInRegistry(address token, bool remove) internal {
91          function _updateTokenInRegistry(address token) internal {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


31          constructor(address _endpoint, address _owner) OAppReceiver() OAppCore(_endpoint, _owner) { }
65          function _lzReceive(Origin calldata _origin, bytes32, bytes calldata _message, address, bytes calldata)


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


27          receive() external payable { }
29          constructor(address _endpoint, address _owner) OAppSender() OAppCore(_endpoint, _owner) { }
36          function updateMessageSetting(bytes memory _messageSetting) public onlyOwner {
40          function _payNative(uint256 amount) internal override returns (uint256) {
51          function setChainInfo(uint256 chainId, uint32 lzChainId, address lzHelperAddress) public onlyOwner {
63          function addVaultInfo(uint256 vaultId, uint256 baseChainId, address omniChainManager) public onlyOwner {
75          function updateTVL(uint256 vaultId, uint256 tvl, uint256 updateTime) public {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


33          constructor(address payable _lzHelper, BaseConnectorCP memory baseConnectorParams)
46          function updateChainInfo(uint256 chainId, address destinationAddress) external onlyMaintainer {
57          function updateBridgeTransactionApproval(bytes32 transactionHash) public onlyManager {
68          function startBridgeTransaction(BridgeRequest memory bridgeRequest) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


19          constructor(uint256 dl, address payable _lzHelper, BaseConnectorCP memory baseConnectorParams)
51          function _getPositionTVL(HoldingPI memory position, address) public view override returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol


11          constructor(address payable _lzHelper, BaseConnectorCP memory baseConnectorParams)
19          function getTVL() public view returns (uint256) {
28          function updateTVLInfo() external onlyManager {
33          function _getPositionTVL(HoldingPI memory position, address base) public view override returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


34          constructor(address[] memory usersAddresses, address _valueOracle, PositionRegistry _registry, uint256 _vaultId)
48          function setValueOracle(address _valueOracle) external onlyMaintainerOrEmergency {
57          function setGeneralSlippageTolerance(uint256 _slippageTolerance) external onlyMaintainerOrEmergency {
68          function setSlippageTolerance(address _inputToken, address _outputToken, uint256 _slippageTolerance)
80          function addEligibleUser(address _user) external onlyMaintainerOrEmergency {
90          function executeSwap(SwapRequest memory _swapRequest)
126         function executeBridge(BridgeRequest calldata _bridgeRequest)
158         function setEnableRoute(uint256 _routeId, bool enable) external onlyMaintainerOrEmergency {
164         function verifyRoute(uint256 _routeId, address addr) external view onlyExistingRoute(_routeId) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


27          constructor(address swapHandler, address _lifi) Ownable2Step() Ownable(msg.sender) {
45          function addHandler(address _handler, bool state) external onlyOwner {
55          function addChain(uint256 _chainId, bool state) external onlyOwner {
65          function addBridgeBlacklist(string memory bridgeName, bool state) external onlyOwner {
77          function performSwapAction(address caller, SwapRequest calldata _request)
133         function performBridgeAction(address caller, BridgeRequest calldata _request)
150         function verifyBridgeData(BridgeRequest calldata _request) public view override returns (bool) {
165         function _forward(IERC20 token, address from, uint256 amount, address caller, bytes calldata data, uint256 routeId)
185         function _setAllowance(IERC20 token, address spender, uint256 amount) internal {
189         function _isNative(IERC20 token) internal pure returns (bool isNative) {
193         function rescueFunds(address token, address userAddress, uint256 amount) external onlyOwner {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/TVLHelper.sol


41          function getLatestUpdateTime(uint256 vaultId, PositionRegistry registry) public view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/TVLHelper.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


29          constructor(PositionRegistry _registry) {
37          function updateDefaultPriceSource(address[] calldata baseCurrencies, INoyaValueOracle[] calldata oracles)
51          function updateAssetPriceSource(address[] calldata asset, address[] calldata baseToken, address[] calldata oracle)
61          function updatePriceRoute(address asset, address base, address[] calldata s) external onlyMaintainer {
71          function getValue(address asset, address baseToken, uint256 amount) public view returns (uint256) {
81          function _getValue(address asset, address baseToken, uint256 amount, address[] memory sources)
95          function _getValue(address quotingToken, address baseToken, uint256 amount) internal view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


46          constructor(address _reg) {
70          function setAssetSources(address[] calldata assets, address[] calldata baseTokens, address[] calldata sources)
138         function getTokenDecimals(address token) public view returns (uint256) {
143         function getSourceOfAsset(address asset, address baseToken) public view returns (address source, bool isInverse) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


31          constructor(address _factory, PositionRegistry _registry) {
38          function setPeriod(uint32 _period) external onlyMaintainer {
48          function addPool(address tokenIn, address baseToken, uint24 fee) external onlyMaintainer {
60          function getValue(address tokenIn, address baseToken, uint256 amount) public view returns (uint256 _amountOut) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/WETH_Oracle.sol


5           function latestRoundData()


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/WETH_Oracle.sol#L0:0

</details>

## NC085 - Function definitions should have NatSpec @notice annotations:

Explain to an end user what this does


<details>
<summary>Click to show 40 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


94          constructor(AccountingManagerConstructorParams memory p)
170         function setFees(uint256 _withdrawFee, uint256 _performanceFee, uint256 _managementFee) public onlyMaintainer {
200         function deposit(address receiver, uint256 amount, address referrer) public nonReentrant whenNotPaused {
328         function calculateWithdrawShares(uint256 maxIterations) public onlyManager nonReentrant whenNotPaused {
543         function burnShares(uint256 amount) public {
596         function getQueueItems(bool depositOrWithdraw, uint256[] memory items)
616         function neededAssetsForWithdraw() public view returns (uint256) {
627         function TVL() public view returns (uint256) {
632         function getPositionTVL(HoldingPI memory position, address base) public view returns (uint256) {
642         function _getValue(address token, address base, uint256 amount) internal view returns (uint256) {
649         function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {
659         function emergencyStop() public whenNotPaused onlyEmergency {
663         function unpause() public whenPaused onlyEmergency {
667         function setDepositLimits(uint256 _depositLimitPerTransaction, uint256 _depositTotalAmount) public onlyMaintainer {
673         function changeDepositWaitingTime(uint256 _depositWaitingTime) public onlyMaintainer {
678         function changeWithdrawWaitingTime(uint256 _withdrawWaitingTime) public onlyMaintainer {
683         function rescue(address token, uint256 amount) public onlyEmergency nonReentrant {
693         function mint(uint256 shares, address receiver) public override returns (uint256) {
697         function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256) {
701         function redeem(uint256 shares, address receiver, address shareOwner) public override returns (uint256) {
705         function deposit(uint256 assets, address receiver) public override returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


14          constructor(address _accountingManager, address _baseToken, address _receiver) Ownable(msg.sender) {
23          function withdrawShares(uint256 amount) external onlyOwner {
27          function burnShares(uint256 amount) external onlyOwner {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


66          constructor(address _governer, address _maintainer, address _emergency, address _flashLoan) {
79          function setMaxNumHoldingPositions(uint256 _maxNumHoldingPositions) external onlyRole(MAINTAINER_ROLE) {
84          function setFlashLoanAddress(address _flashLoan) external onlyRole(MAINTAINER_ROLE) {
106         function addVault(
158         function changeVaultAddresses(
188         function addConnector(uint256 vaultId, address[] calldata _connectorAddresses, bool[] calldata _enableds)
207         function updateConnectorTrustedTokens(
224         function getPositionBP(uint256 vaultId, bytes32 _positionId) public view returns (PositionBP memory) {
238         function addTrustedPosition(
266         function removeTrustedPosition(uint256 vaultId, bytes32 _positionId)
293         function updateHoldingPosition(
335         function updateHoldingPosition(
370         function updateHoldingPostionWithTime(
394         function getHoldingPositionIndex(uint256 vaultId, bytes32 _positionId, address _connector, bytes memory data)
408         function getHoldingPosition(uint256 vaultId, uint256 i) public view returns (HoldingPI memory) {
416         function getHoldingPositions(uint256 vaultId) public view returns (HoldingPI[] memory) {
426         function isPositionTrusted(uint256 vaultId, bytes32 _positionId) public view returns (bool) {
436         function isPositionTrustedForConnector(uint256 vaultId, bytes32 _positionId, address connector)
449         function getGovernanceAddresses(uint256 vaultId)
470         function isTokenTrusted(uint256 vaultId, address token, address connector) public view returns (bool) {
486         function calculatePositionId(address calculatorConnector, uint256 positionTypeId, bytes memory data)
499         function isAnActiveConnector(uint256 vaultId, address connectorAddress) public view returns (bool) {
508         function isPositionDebt(uint256 vaultId, bytes32 _positionId) public view returns (bool) {
516         function getVaultAddresses(uint256 vaultId) public view returns (address, address) {
525         function isAddressTrusted(uint256 vaultId, address addr) public view returns (bool) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


33          constructor(address _pool, address _poolBaseToken, BaseConnectorCP memory baseConnectorParams)
88          function repayWithCollateral(uint256 _amount, uint256 i, address _borrowAsset) external onlyManager {
114         function _getPositionTVL(HoldingPI memory, address base) public view override returns (uint256 tvl) {
120         function _getUnderlyingTokens(uint256, bytes memory) public pure override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


40          constructor(address _router, address _voter, BaseConnectorCP memory baseConnectorParams)
100         function stake(address pool, uint256 liquidity) public onlyManager nonReentrant {
106         function unstake(address pool, uint256 liquidity) public onlyManager nonReentrant {
111         function claim(address pool) public onlyManager nonReentrant {
117         function _getUnderlyingTokens(uint256 p, bytes memory data) public view override returns (address[] memory) {
125         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


42          constructor(address _balancerVault, address bal, address aura, BaseConnectorCP memory baseConnectorParams)
53          function harvestAuraRewards(address[] calldata rewardsPools) public onlyManager nonReentrant {
64          function openPosition(
109         function depositIntoAuraBooster(bytes32 poolId, uint256 _amount) public onlyManager nonReentrant {
115         function decreasePosition(DecreasePositionParams memory p) public onlyManager nonReentrant {
162         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {
175         function totalLpBalanceOf(PoolInfo memory pool) public view returns (uint256) {
184         function totalLpBalanceOf(bytes32 poolId) public view returns (uint256) {
189         function _getPoolInfo(bytes32 pooId) internal view returns (PoolInfo memory, bytes32) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


24          constructor(address _balancerVault, PositionRegistry _registry) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


36          constructor(address _router, address _factory, BaseConnectorCP memory baseCP) BaseConnector(baseCP) {
43          function addLiquidityInCamelotPool(CamelotAddLiquidityParams calldata p) external onlyManager nonReentrant {
65          function removeLiquidityFromCamelotPool(CamelotRemoveLiquidityParams calldata p)
88          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
99          function _getUnderlyingTokens(uint256 id, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


17          constructor(BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) { }
84          function getBorrowBalanceInBase(IComet comet) public view returns (uint256 borrowBalanceInVirtualBase) {
95          function getCollBlanace(IComet comet, bool riskAdjusted) public view returns (uint256 CollValue) {
125         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {
134         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {
141         function isInAsset(uint16 assetsIn, uint8 assetOffset) public pure returns (bool) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


45          constructor(
81          function depositIntoPrisma(address pool, uint256 amount, bool curveOrConvex) public onlyManager nonReentrant {
103         function depositIntoConvexBooster(address pool, uint256 pid, uint256 amount, bool stake) public onlyManager {
117         function openCurvePosition(address pool, uint256 depositIndex, uint256 amount, uint256 minAmount)
160         function decreaseCurvePosition(address pool, uint256 withdrawIndex, uint256 amount, uint256 minAmount)
182         function withdrawFromConvexBooster(uint256 pid, uint256 amount) public onlyManager {
202         function withdrawFromGauge(address pool, uint256 amount) public onlyManager {
212         function withdrawFromPrisma(address depostiToken, uint256 amount) public onlyManager {
221         function harvestRewards(address[] calldata gauges) public onlyManager nonReentrant {
233         function harvestPrismaRewards(address[] calldata pools) public onlyManager nonReentrant {
247         function harvestConvexRewards(address[] calldata rewardsPools) public onlyManager nonReentrant {
258         function _getPoolInfo(address pool) internal view returns (PoolInfo memory) {
265         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
279         function LPToUnder(PoolInfo memory info, uint256 balance) public view returns (uint256, address) {
311         function totalLpBalanceOf(PoolInfo memory info) public view returns (uint256) {
325         function balanceOfConvexRewardPool(PoolInfo memory info) public view returns (uint256) {
335         function balanceOfLPToken(PoolInfo memory info) public view returns (uint256) {
344         function balanceOfRewardPool(PoolInfo memory info) public view returns (uint256) {
354         function balanceOfPrisma(address prismaPool) public view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


18          constructor(
30          function deposit(uint256 marketId, uint256 _amount) public onlyManager nonReentrant {
43          function withdraw(uint256 marketId, uint256 _amount) public onlyManager nonReentrant {
58          function openBorrowPosition(uint256 marketId, uint256 _amountWei, uint256 accountId)
77          function transferBetweenAccounts(uint256 accountId, uint256 marketId, uint256 _amountWei, bool borrowOrRepay)
98          function closeBorrowPosition(uint256[] memory marketIds, uint256 accountId) public onlyManager nonReentrant {
106         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


29          constructor(BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) { }
68          function withdraw(IFraxPair pool, uint256 withdrawAmount) public onlyManager nonReentrant {
104         function verifyHealthFactor(IFraxPair pool) public view {
142         function _getUnderlyingTokens(uint256 p, bytes memory data) public view override returns (address[] memory) {
150         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


17          constructor(BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) { }
24          function openAccount(address facade, uint256 ref) public onlyManager {
41          function closeAccount(address facade, address creditAccount) public onlyManager nonReentrant {
62          function executeCommands(
93          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


20          constructor(address _lido, address _lidoW, address _steth, address w, BaseConnectorCP memory baseConnectorParams)
37          function deposit(uint256 amountIn) external onlyManager nonReentrant {
51          function requestWithdrawals(uint256 amount) public onlyManager nonReentrant {
69          function claimWithdrawal(uint256 requestId) public onlyManager nonReentrant {
89          receive() external payable { }
91          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


43          constructor(address _mav, address _veMav, address mr, address pi, BaseConnectorCP memory baseCP)
56          receive() external payable { }
64          function stake(uint256 amount, uint256 duration, bool doDelegation) external onlyManager nonReentrant {
78          function unstake(uint256 lockupId) external onlyManager nonReentrant {
115         function removeLiquidityFromMaverickPool(MavericRemoveLiquidityParams calldata p)
137         function claimBoostedPositionRewards(IMaverickReward rewardContract) external onlyManager nonReentrant {
149         function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {
153         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
161         function _getUnderlyingTokens(uint256 id, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


23          constructor(address MB, BaseConnectorCP memory baseCP) BaseConnector(baseCP) {
58          function withdraw(uint256 amount, Id id, bool sOrC) external onlyManager nonReentrant {
80          function borrow(uint256 amount, Id id) external onlyManager nonReentrant {
95          function repay(uint256 amount, Id id) public onlyManager nonReentrant {
108         function getHealthFactor(Id _id, Market memory _market) public view returns (uint256) {
118         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
137         function convertCToL(uint256 amount, address marketOracle, address collateral) public view returns (uint256) {
141         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


19          constructor(address MC, address _positionManager, address _factory, BaseConnectorCP memory baseConnectorParams)
31          function sendPositionToMasterChef(uint256 tokenId) external onlyManager nonReentrant {
40          function updatePosition(uint256 tokenId) public onlyManager nonReentrant {
50          function withdraw(uint256 tokenId) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


97          function mintPTAndYT(address market, uint256 syAmount) external onlyManager nonReentrant {
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
149         function swapYTForPT(address market, uint256 exactYTIn, uint256 min, ApproxParams memory guess)
183         function swapExactPTForSY(IPMarket market, uint256 exactPTIn, bytes calldata swapData, uint256 minSY)
203         function burnLP(IPMarket market, uint256 amount) external onlyManager nonReentrant {
216         function decreasePosition(IPMarket market, uint256 _amount, bool closePosition) external onlyManager nonReentrant {
241         function claimRewards(IPMarket market) external onlyManager nonReentrant {
257         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
293         function getYTValue(address market, uint256 balance) public view returns (uint256) {
303         function isMarketEmpty(IPMarket market) public view returns (bool) {
311         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


33          function approveZap(IStakeNTroveZap zap, address tm, bool approve) public onlyManager nonReentrant {
52          function openTrove(IStakeNTroveZap zap, address tm, uint256 maxFee, uint256 dAmount, uint256 bAmount)
145         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
164         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


20          constructor(address _SNXCoreProxy, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {
25          function createAccount() public onlyManager {
30          function deposit(address _token, uint256 _amount, uint128 _accountId) public onlyManager {
46          function withdraw(address _token, uint256 _amount, uint128 _accountId) public onlyManager {
64          function onERC721Received(address, address, uint256, bytes memory) external pure override returns (bytes4) {
68          function delegateIntoPreferredPool(
81          function delegateIntoApprovedPool(
94          function claimRewards(uint128 accountId, uint128 poolId, address collateralType, address distributor)
102         function mintOrBurnSUSD(
121         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
128         function _getUnderlyingTokens(uint256, bytes memory) public pure override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


17          constructor(address SR, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {
33          function deposit(address siloToken, address dToken, uint256 amount, bool oC) external onlyManager nonReentrant {
71          function getData(address siloToken)
85          function borrow(address siloToken, address bToken, uint256 amount) external onlyManager nonReentrant {
98          function repay(address siloToken, address rToken, uint256 amount) external onlyManager nonReentrant {
109         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
130         function isSiloEmpty(ISilo silo) public view returns (bool) {
143         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


33          constructor(address lpStacking, address _stargateRouter, BaseConnectorCP memory baseConnectorParams)
76          function withdrawFromStargatePool(StargateRequest calldata withdrawRequest) external onlyManager nonReentrant {
103         function claimStargateRewards(uint256 poolId) external onlyManager nonReentrant {
110         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
123         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


27          constructor(address _positionManager, address _factory, BaseConnectorCP memory baseConnectorParams)
63          function decreasePosition(DecreaseLiquidityParams memory p) external onlyManager nonReentrant {
87          function increasePosition(IncreaseLiquidityParams memory p) external onlyManager nonReentrant {
122         function _collectFees(uint256 tokenId) internal returns (uint256 amount0, uint256 amount1) {
127         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
152         function _getUnderlyingTokens(uint256, bytes memory data) public pure override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


42          function updateOwners(address[] memory _owners, bool[] memory addOrRemove) public onlyOwner {
63          function setThreshold(uint8 _threshold) public onlyOwner {
84          function execute(
124         function domainSeparatorV4() public view returns (bytes32) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/governance/NoyaGovernanceBase.sol


21          constructor(PositionRegistry _registry, uint256 _vaultId) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L0:0

```solidity
File: contracts/governance/TimeLock.sol


7           constructor(uint256 minDelay, address[] memory proposers, address[] memory executors, address owner)


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/TimeLock.sol#L0:0

```solidity
File: contracts/governance/Watchers.sol


7           constructor(address[] memory _owners, uint8 _threshold) Keepers(_owners, _threshold) { }
8           function verifyRemoveLiquidity(uint256 withdrawAmount, uint256 sentAmount, bytes memory data) external view { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Watchers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


33          constructor(BaseConnectorCP memory params) NoyaGovernanceBase(params.registry, params.vaultId) {
67          function updateValueOracle(address _valueOracle) external onlyMaintainer {
84          function sendTokensToTrustedAddress(address token, uint256 amount, address caller, bytes memory data)
122         function transferPositionToAnotherConnector(
135         function _updateTokenInRegistry(address token, bool remove) internal {
153         function updateTokenInRegistry(address token) public onlyManager {
158         function _updateTokenInRegistry(address token) internal {
169         function addLiquidity(address[] memory tokens, uint256[] memory amounts, bytes memory data)
221         function _executeSwap(SwapRequest memory swapRequest) internal returns (uint256 amountOut) {
232         function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {
249         function getPositionTVL(HoldingPI memory p, address baseToken) public view returns (uint256) {
253         function _getValue(address token, address baseToken, uint256 amount) internal view returns (uint256) {
263         function _getUnderlyingTokens(uint256, bytes memory) public view virtual returns (address[] memory) {
267         function _addLiquidity(address[] memory, uint256[] memory, bytes memory) internal virtual returns (bool) {
271         function _getPositionTVL(HoldingPI memory, address) public view virtual returns (uint256 tvl) {
277         function _approveOperations(address _token, address _spender, uint256 _amount) internal virtual {
285         function _revokeApproval(address _token, address _spender) internal virtual {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


22          constructor(address _registry, uint256 _vaultId) {
27          function sendTokensToTrustedAddress(address token, uint256 amount, address caller, bytes memory data)
40          function addLiquidity(address[] memory tokens, uint256[] memory amounts, bytes memory data) external {
51          function updatePositionToRegistryUsingType(bytes32 _positionId, bytes memory data, bool remove) external {
59          function addPositionToRegistryUsingType(uint256 _positionType, bytes memory data) external {
65          function addPositionToRegistry(bytes memory data) external {
71          function getPositionTVL(HoldingPI memory p, address baseToken) public view returns (uint256) {
75          function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {
79          function _updateTokenInRegistry(address token, bool remove) internal {
91          function _updateTokenInRegistry(address token) internal {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


31          constructor(address _endpoint, address _owner) OAppReceiver() OAppCore(_endpoint, _owner) { }
65          function _lzReceive(Origin calldata _origin, bytes32, bytes calldata _message, address, bytes calldata)


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


27          receive() external payable { }
29          constructor(address _endpoint, address _owner) OAppSender() OAppCore(_endpoint, _owner) { }
36          function updateMessageSetting(bytes memory _messageSetting) public onlyOwner {
40          function _payNative(uint256 amount) internal override returns (uint256) {
51          function setChainInfo(uint256 chainId, uint32 lzChainId, address lzHelperAddress) public onlyOwner {
63          function addVaultInfo(uint256 vaultId, uint256 baseChainId, address omniChainManager) public onlyOwner {
75          function updateTVL(uint256 vaultId, uint256 tvl, uint256 updateTime) public {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


46          function updateChainInfo(uint256 chainId, address destinationAddress) external onlyMaintainer {
57          function updateBridgeTransactionApproval(bytes32 transactionHash) public onlyManager {
68          function startBridgeTransaction(BridgeRequest memory bridgeRequest) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


19          constructor(uint256 dl, address payable _lzHelper, BaseConnectorCP memory baseConnectorParams)
51          function _getPositionTVL(HoldingPI memory position, address) public view override returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol


11          constructor(address payable _lzHelper, BaseConnectorCP memory baseConnectorParams)
19          function getTVL() public view returns (uint256) {
28          function updateTVLInfo() external onlyManager {
33          function _getPositionTVL(HoldingPI memory position, address base) public view override returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


34          constructor(address[] memory usersAddresses, address _valueOracle, PositionRegistry _registry, uint256 _vaultId)


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


27          constructor(address swapHandler, address _lifi) Ownable2Step() Ownable(msg.sender) {
150         function verifyBridgeData(BridgeRequest calldata _request) public view override returns (bool) {
165         function _forward(IERC20 token, address from, uint256 amount, address caller, bytes calldata data, uint256 routeId)
185         function _setAllowance(IERC20 token, address spender, uint256 amount) internal {
189         function _isNative(IERC20 token) internal pure returns (bool isNative) {
193         function rescueFunds(address token, address userAddress, uint256 amount) external onlyOwner {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/TVLHelper.sol


41          function getLatestUpdateTime(uint256 vaultId, PositionRegistry registry) public view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/TVLHelper.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


29          constructor(PositionRegistry _registry) {
61          function updatePriceRoute(address asset, address base, address[] calldata s) external onlyMaintainer {
71          function getValue(address asset, address baseToken, uint256 amount) public view returns (uint256) {
81          function _getValue(address asset, address baseToken, uint256 amount, address[] memory sources)
95          function _getValue(address quotingToken, address baseToken, uint256 amount) internal view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


46          constructor(address _reg) {
143         function getSourceOfAsset(address asset, address baseToken) public view returns (address source, bool isInverse) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/WETH_Oracle.sol


5           function latestRoundData()


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/WETH_Oracle.sol#L0:0

</details>

## NC086 - Abstract contract declarations should have NatSpec @title annotations:

A title that should describe the contract/interface


```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


14      abstract contract OmnichainLogic is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

## NC087 - Abstract contract declarations should have NatSpec @author annotations:

The name of the author


```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


14      abstract contract OmnichainLogic is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

## NC088 - Abstract contract declarations should have Natspec @dev annotations:

Explain to a developer any extra details


```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


14      abstract contract OmnichainLogic is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

## NC089 - Library declarations should have Natspec @title annotations:

A title that should describe the contract/interface


```solidity
File: contracts/helpers/TVLHelper.sol


7       library TVLHelper {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/TVLHelper.sol#L0:0

## NC090 - Library declarations should have Natspec @author annotations:

The name of the author


```solidity
File: contracts/helpers/TVLHelper.sol


7       library TVLHelper {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/TVLHelper.sol#L0:0

## NC091 - Library declarations should have Natspec @notice annotations:

Explain to an end user what this does


```solidity
File: contracts/helpers/TVLHelper.sol


7       library TVLHelper {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/TVLHelper.sol#L0:0

## NC092 - Library declarations should have Natspec @dev annotations:

Explain to a developer any extra details


```solidity
File: contracts/helpers/TVLHelper.sol


7       library TVLHelper {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/TVLHelper.sol#L0:0

## NC093 - Modifier definitions should have Natspec @notice annotations:

Explain to an end user what this does


<details>
<summary>Click to show 7 findings</summary>

```solidity
File: contracts/accountingManager/Registry.sol


32          modifier onlyVaultMaintainer(uint256 _vaultId) {
39          modifier onlyVaultMaintainerWithoutTimeLock(uint256 _vaultId) {
46          modifier onlyVaultGoverner(uint256 _vaultId) {
53          modifier vaultExists(uint256 _vaultId) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/governance/NoyaGovernanceBase.sol


31          modifier onlyManager() {
43          modifier onlyEmergency() {
53          modifier onlyEmergencyOrWatcher() {
65          modifier onlyMaintainerOrEmergency() {
75          modifier onlyMaintainer() {
85          modifier onlyGovernance() {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


24          modifier onlyEligibleUser() {
29          modifier onlyExistingRoute(uint256 _routeId) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


34          modifier onlyHandler() {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


24          modifier onlyMaintainer() {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


41          modifier onlyMaintainer() {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


24          modifier onlyMaintainer() {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## NC094 - Modifier definitions should have Natspec @dev annotations:

Explain to a developer any extra details


<details>
<summary>Click to show 7 findings</summary>

```solidity
File: contracts/accountingManager/Registry.sol


32          modifier onlyVaultMaintainer(uint256 _vaultId) {
39          modifier onlyVaultMaintainerWithoutTimeLock(uint256 _vaultId) {
46          modifier onlyVaultGoverner(uint256 _vaultId) {
53          modifier vaultExists(uint256 _vaultId) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/governance/NoyaGovernanceBase.sol


31          modifier onlyManager() {
43          modifier onlyEmergency() {
53          modifier onlyEmergencyOrWatcher() {
65          modifier onlyMaintainerOrEmergency() {
75          modifier onlyMaintainer() {
85          modifier onlyGovernance() {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


24          modifier onlyEligibleUser() {
29          modifier onlyExistingRoute(uint256 _routeId) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


34          modifier onlyHandler() {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


24          modifier onlyMaintainer() {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


41          modifier onlyMaintainer() {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


24          modifier onlyMaintainer() {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## NC095 - Contract definitions should have Natspec @title annotations:

 title that should describe the contract


<details>
<summary>Click to show 35 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


16      contract AccountingManager is IAccountingManager, ERC4626, ReentrancyGuard, Pausable, NoyaGovernanceBase {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


7       contract NoyaFeeReceiver is Ownable {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


12      contract PositionRegistry is AccessControl, IPositionRegistry, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


27      contract AerodromeConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


26      contract BalancerConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


12      contract BalancerFlashLoan is IFlashLoanRecipient, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


30      contract CamelotConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


7       contract CompoundConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


24      contract CurveConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


9       contract DolomiteConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


18      contract FraxConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


8       contract Gearboxv3 is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


7       contract LidoConnector is BaseConnector, ERC721Holder {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


29      contract MaverickConnector is BaseConnector, IERC721Receiver {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


8       contract MorphoBlueConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


8       contract PancakeswapConnector is UNIv3Connector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


12      contract PendleConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


11      contract PrismaConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


7       contract SNXV3Connector is BaseConnector, IERC721Receiver {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


8       contract SiloConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


19      contract StargateConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


9       contract Keepers is EIP712, Ownable2Step {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/governance/NoyaGovernanceBase.sol


6       contract NoyaGovernanceBase {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L0:0

```solidity
File: contracts/governance/TimeLock.sol


6       contract NoyaTimeLock is TimelockController {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/TimeLock.sol#L0:0

```solidity
File: contracts/governance/Watchers.sol


6       contract Watchers is Keepers {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Watchers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


22      contract BaseConnector is NoyaGovernanceBase, IConnector, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


14      contract ConnectorMock2 {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


18      contract LZHelperReceiver is OAppReceiver {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


19      contract LZHelperSender is OAppSender {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


8       contract OmnichainManagerBaseChain is OmnichainLogic {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol


10      contract OmnichainManagerNormalChain is OmnichainLogic {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


10      contract SwapAndBridgeHandler is NoyaGovernanceBase, ISwapAndBridgeHandler, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


10      contract LifiImplementation is ISwapAndBridgeImplementation, Ownable2Step, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


10      contract ChainlinkOracleConnector is INoyaValueOracle {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/WETH_Oracle.sol


4       contract WETH_Oracle {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/WETH_Oracle.sol#L0:0

</details>

## NC096 - Contract definitions should have Natspec @author annotations:

The name of the author


<details>
<summary>Click to show 39 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


16      contract AccountingManager is IAccountingManager, ERC4626, ReentrancyGuard, Pausable, NoyaGovernanceBase {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


7       contract NoyaFeeReceiver is Ownable {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


12      contract PositionRegistry is AccessControl, IPositionRegistry, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


11      contract AaveConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


27      contract AerodromeConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


26      contract BalancerConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


12      contract BalancerFlashLoan is IFlashLoanRecipient, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


30      contract CamelotConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


7       contract CompoundConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


24      contract CurveConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


9       contract DolomiteConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


18      contract FraxConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


8       contract Gearboxv3 is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


7       contract LidoConnector is BaseConnector, ERC721Holder {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


29      contract MaverickConnector is BaseConnector, IERC721Receiver {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


8       contract MorphoBlueConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


8       contract PancakeswapConnector is UNIv3Connector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


12      contract PendleConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


11      contract PrismaConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


7       contract SNXV3Connector is BaseConnector, IERC721Receiver {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


8       contract SiloConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


19      contract StargateConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


12      contract UNIv3Connector is BaseConnector, ERC721Holder {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


9       contract Keepers is EIP712, Ownable2Step {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/governance/NoyaGovernanceBase.sol


6       contract NoyaGovernanceBase {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L0:0

```solidity
File: contracts/governance/TimeLock.sol


6       contract NoyaTimeLock is TimelockController {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/TimeLock.sol#L0:0

```solidity
File: contracts/governance/Watchers.sol


6       contract Watchers is Keepers {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Watchers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


22      contract BaseConnector is NoyaGovernanceBase, IConnector, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


14      contract ConnectorMock2 {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


18      contract LZHelperReceiver is OAppReceiver {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


19      contract LZHelperSender is OAppSender {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


8       contract OmnichainManagerBaseChain is OmnichainLogic {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol


10      contract OmnichainManagerNormalChain is OmnichainLogic {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


10      contract SwapAndBridgeHandler is NoyaGovernanceBase, ISwapAndBridgeHandler, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


10      contract LifiImplementation is ISwapAndBridgeImplementation, Ownable2Step, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


10      contract NoyaValueOracle is INoyaValueOracle {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


10      contract ChainlinkOracleConnector is INoyaValueOracle {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


12      contract UniswapValueOracle is INoyaValueOracle {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/WETH_Oracle.sol


4       contract WETH_Oracle {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/WETH_Oracle.sol#L0:0

</details>

## NC097 - Contract definitions should have Natspec @notice annotations:

Explain to an end user what this does


<details>
<summary>Click to show 35 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


16      contract AccountingManager is IAccountingManager, ERC4626, ReentrancyGuard, Pausable, NoyaGovernanceBase {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


7       contract NoyaFeeReceiver is Ownable {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


12      contract PositionRegistry is AccessControl, IPositionRegistry, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


27      contract AerodromeConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


26      contract BalancerConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


12      contract BalancerFlashLoan is IFlashLoanRecipient, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


30      contract CamelotConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


7       contract CompoundConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


24      contract CurveConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


9       contract DolomiteConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


18      contract FraxConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


8       contract Gearboxv3 is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


7       contract LidoConnector is BaseConnector, ERC721Holder {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


29      contract MaverickConnector is BaseConnector, IERC721Receiver {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


8       contract MorphoBlueConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


8       contract PancakeswapConnector is UNIv3Connector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


12      contract PendleConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


11      contract PrismaConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


7       contract SNXV3Connector is BaseConnector, IERC721Receiver {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


8       contract SiloConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


19      contract StargateConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


9       contract Keepers is EIP712, Ownable2Step {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/governance/NoyaGovernanceBase.sol


6       contract NoyaGovernanceBase {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L0:0

```solidity
File: contracts/governance/TimeLock.sol


6       contract NoyaTimeLock is TimelockController {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/TimeLock.sol#L0:0

```solidity
File: contracts/governance/Watchers.sol


6       contract Watchers is Keepers {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Watchers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


22      contract BaseConnector is NoyaGovernanceBase, IConnector, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


14      contract ConnectorMock2 {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


18      contract LZHelperReceiver is OAppReceiver {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


19      contract LZHelperSender is OAppSender {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


8       contract OmnichainManagerBaseChain is OmnichainLogic {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol


10      contract OmnichainManagerNormalChain is OmnichainLogic {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


10      contract SwapAndBridgeHandler is NoyaGovernanceBase, ISwapAndBridgeHandler, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


10      contract LifiImplementation is ISwapAndBridgeImplementation, Ownable2Step, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


10      contract ChainlinkOracleConnector is INoyaValueOracle {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/WETH_Oracle.sol


4       contract WETH_Oracle {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/WETH_Oracle.sol#L0:0

</details>

## NC098 - Contract definitions should have Natspec @dev annotations:

Explain to a developer any extra details


<details>
<summary>Click to show 38 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


16      contract AccountingManager is IAccountingManager, ERC4626, ReentrancyGuard, Pausable, NoyaGovernanceBase {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


7       contract NoyaFeeReceiver is Ownable {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


11      contract AaveConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


27      contract AerodromeConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


26      contract BalancerConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


12      contract BalancerFlashLoan is IFlashLoanRecipient, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


30      contract CamelotConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


7       contract CompoundConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


24      contract CurveConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


9       contract DolomiteConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


18      contract FraxConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


8       contract Gearboxv3 is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


7       contract LidoConnector is BaseConnector, ERC721Holder {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


29      contract MaverickConnector is BaseConnector, IERC721Receiver {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


8       contract MorphoBlueConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


8       contract PancakeswapConnector is UNIv3Connector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


12      contract PendleConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


11      contract PrismaConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


7       contract SNXV3Connector is BaseConnector, IERC721Receiver {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


8       contract SiloConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


19      contract StargateConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


12      contract UNIv3Connector is BaseConnector, ERC721Holder {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


9       contract Keepers is EIP712, Ownable2Step {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/governance/NoyaGovernanceBase.sol


6       contract NoyaGovernanceBase {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L0:0

```solidity
File: contracts/governance/TimeLock.sol


6       contract NoyaTimeLock is TimelockController {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/TimeLock.sol#L0:0

```solidity
File: contracts/governance/Watchers.sol


6       contract Watchers is Keepers {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Watchers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


22      contract BaseConnector is NoyaGovernanceBase, IConnector, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


14      contract ConnectorMock2 {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


18      contract LZHelperReceiver is OAppReceiver {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


19      contract LZHelperSender is OAppSender {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


8       contract OmnichainManagerBaseChain is OmnichainLogic {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol


10      contract OmnichainManagerNormalChain is OmnichainLogic {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


10      contract SwapAndBridgeHandler is NoyaGovernanceBase, ISwapAndBridgeHandler, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


10      contract LifiImplementation is ISwapAndBridgeImplementation, Ownable2Step, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


10      contract NoyaValueOracle is INoyaValueOracle {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


10      contract ChainlinkOracleConnector is INoyaValueOracle {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


12      contract UniswapValueOracle is INoyaValueOracle {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/WETH_Oracle.sol


4       contract WETH_Oracle {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/WETH_Oracle.sol#L0:0

</details>

## NC099 - Event definitions should have Natspec @notice annotations:

Explain to an end user what this does


<details>
<summary>Click to show 25 findings</summary>

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


12          event ManagementFeeReceived(address indexed token, uint256 amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


26          event Supply(address supplyToken, uint256 amount);
27          event Borrow(address borrowToken, uint256 amount);
28          event Repay(address repayToken, uint256 amount, uint256 i);
29          event RepayWithCollateral(address repayToken, uint256 amount, uint256 i);
30          event WithdrawCollateral(address collateral, uint256 amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


36          event Supply(address pool, uint256 amount0, uint256 amount1);
37          event Withdraw(address pool, uint256 amountLiquidity);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


34          event OpenPosition(
37          event DecreasePosition(DecreasePositionParams p);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


21          event MakeFlashLoan(IERC20[] tokens, uint256[] amounts);
22          event ReceiveFlashLoan(IERC20[] tokens, uint256[] amounts, uint256[] feeAmounts, bytes userData);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


10          event Supply(address market, address asset, uint256 amount);
11          event WithdrawOrBorrow(address market, address asset, uint256 amount);
12          event ClaimRewards(address rewardContract, address market);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


33          event OpenCurvePosition(address pool, uint256 depositIndex, uint256 amount, uint256 minAmount);
34          event DecreaseCurvePosition(address pool, uint256 withdrawIndex, uint256 amount, uint256 minAmount);
35          event WithdrawFromConvexBooster(uint256 pid, uint256 amount);
36          event WithdrawFromConvexRewardPool(address pool, uint256 amount);
37          event WithdrawFromGauge(address pool, uint256 amount);
38          event WithdrawFromPrisma(address depostiToken, uint256 amount);
39          event HarvestRewards(address[] gauges);
40          event HarvestPrismaRewards(address[] pools);
41          event HarvestConvexRewards(address[] rewardsPools);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


24          event BorrowAndSupply(address pool, uint256 borrowAmount, uint256 collateralAmount);
25          event Withdraw(address pool, uint256 withdrawAmount);
26          event Repay(address pool, uint256 sharesToRepay);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


11          event OpenAccount(address facade, uint256 ref);
12          event CloseAccount(address facade, address creditAccount);
13          event ExecuteCommands(


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


15          event Deposit(uint256 amountIn);
16          event RequestWithdrawals(uint256 amount);
17          event ClaimWithdrawal(uint256 requestId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


37          event Stake(uint256 amount, uint256 duration, bool doDelegation);
38          event Unstake(uint256 lockupId);
39          event AddLiquidityInMaverickPool(MavericAddLiquidityParams p);
40          event RemoveLiquidityFromMaverickPool(MavericRemoveLiquidityParams p);
41          event ClaimBoostedPositionRewards(IMaverickReward rewardContract);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


17          event Supply(uint256 amount, Id id, bool sOrC);
18          event Withdraw(uint256 amount, Id id, bool sOrC);
19          event Borrow(uint256 amount, Id id);
20          event Repay(uint256 amount, Id id);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


14          event SendPositionToMasterChef(uint256 tokenId);
15          event UpdatePosition(uint256 tokenId);
16          event Withdraw(uint256 tokenId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


35          event Supply(address market, uint256 amount);
36          event MintPTAndYT(address market, uint256 syAmount);
37          event DepositIntoMarket(address market, uint256 SYamount, uint256 PTamount);
38          event DepositIntoPenpie(address market, uint256 amount);
39          event WithdrawFromPenpie(address market, uint256 amount);
40          event SwapYTForPT(address market, uint256 exactYTIn, uint256 min, ApproxParams guess);
41          event SwapYTForSY(address market, uint256 exactYTIn, uint256 min, LimitOrderData orderData);
42          event SwapExactPTForSY(address market, uint256 exactPTIn, bytes swapData, uint256 minSY);
43          event BurnLP(address market, uint256 amount);
44          event DecreasePosition(address market, uint256 amount, bool closePosition);
45          event ClaimRewards(address market);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


16          event OpenTrove(address zap, address tm, uint256 maxFee, uint256 dAmount, uint256 bAmount);
17          event AddColl(address zap, address tm, uint256 amountIn);
18          event AdjustTrove(address zap, address tm, uint256 mFee, uint256 wAmount, uint256 bAmount, bool isBorrowing);
19          event CloseTrove(address zap, address troveManager);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


12          event Deposit(address siloToken, address dToken, uint256 amount, bool oC);
13          event Withdraw(address siloToken, address wToken, uint256 amount, bool oC, bool closePosition);
14          event Borrow(address siloToken, address bToken, uint256 amount);
15          event Repay(address siloToken, address rToken, uint256 amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


28          event DepositIntoStargatePool(StargateRequest depositRequest);
29          event WithdrawFromStargatePool(StargateRequest withdrawRequest);
30          event ClaimStargateRewards(uint256 poolId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


21          event OpenPosition(MintParams p, uint256 tokenId);
22          event DecreasePosition(DecreaseLiquidityParams p);
23          event IncreasePosition(IncreaseLiquidityParams p);
24          event CollectFees(uint256 tokenId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


18          event Execute(address indexed destination, bytes data, uint256 gasLimit, address executor, uint256 deadline);
19          event UpdateOwners(address[] owners, bool[] addOrRemove);
20          event UpdateThreshold(uint8 threshold);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


24          event UpdateChainInfo(uint256 chainId, address destinationAddress);
25          event UpdateBridgeTransactionApproval(bytes32 transactionHash, uint256 timestamp);
26          event StartBridgeTransaction(BridgeRequest bridgeRequest, bytes32 transactionHash);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


19          event SetValueOracle(address _valueOracle);
20          event SetSlippageTolerance(address _inputToken, address _outputToken, uint256 _slippageTolerance);
21          event AddEligibleUser(address _user);
22          event BridgeExecutionCompleted(BridgeRequest _bridgeRequest);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


20          event AddedHandler(address _handler, bool state);
21          event AddedChain(uint256 _chainId, bool state);
22          event AddedBridgeBlacklist(string bridgeName, bool state);
23          event Bridged(address bridge, address token, uint256 amount, bytes data);
24          event Rescued(address token, address userAddress, uint256 amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


20          event UpdatedDefaultPriceSource(address[] baseCurrencies, INoyaValueOracle[] oracles);
21          event UpdatedAssetPriceSource(address[] asset, address[] baseToken, address[] oracle);
22          event UpdatedPriceRoute(address asset, address baseToken, address[] s);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


31          event AssetSourceUpdated(address indexed asset, address indexed baseToken, address indexed source);
32          event ChainlinkPriceAgeThresholdUpdated(uint256 newThreshold);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


21          event NewPeriod(uint32 period);
22          event PoolsForAsset(address indexed asset, address indexed base, address indexed pool);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## NC100 - State variable declarations should have Natspec @notice annotations:

Explain to an end user what this does


<details>
<summary>Click to show 36 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


52          uint256 public constant FEE_PRECISION = 1e6;
53          uint256 public constant WITHDRAWAL_MAX_FEE = 5e4;
54          uint256 public constant MANAGEMENT_MAX_FEE = 5e5;
55          uint256 public constant PERFORMANCE_MAX_FEE = 1e5;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


8           address public receiver;
9           address public accountingManager;
10          address public baseToken;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


15          bytes32 public constant MAINTAINER_ROLE = keccak256("MAINTAINER_ROLE");
17          bytes32 public constant GOVERNER_ROLE = keccak256("GOVERNER_ROLE");
19          bytes32 public constant EMERGENCY_ROLE = keccak256("EMERGENCY_ROLE");
21          uint256 public constant MAX_NUM_HOLDING_POSITIONS = 40;
23          uint256 public maxNumHoldingPositions = 20;
26          mapping(uint256 => Vault) public vaults;
28          address public flashLoan;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


18          address immutable pool;
24          uint256 public constant AAVE_POSITION_ID = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


31          uint256 public constant AERODROME_POSITION_TYPE = 1;
33          IRouter aerodromeRouter;
34          IVoter voter;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


27          address internal balancerVault;
29          address public BAL;
30          address public AURA;
32          uint256 public BALANCER_LP_POSITION = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


15          IBalancerVault internal vault;
16          PositionRegistry public registry;
17          address caller;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


31          ICamelotRouter public router;
32          ICamelotFactory public factory;
34          uint256 public constant CAMELOT_POSITION_ID = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


8           uint256 public COMPOUND_LP = 2;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


26          IBooster public convexBooster;
27          address public CVX;
28          address public CRV;
29          address public PRISMA;
31          uint256 public constant CURVE_LP_POSITION = 4;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


12          IDepositWithdrawalProxy public depositWithdrawalProxy;
13          IDolomiteMargin public dolomiteMargin;
14          IBorrowPositionProxyV1 public borrowPositionProxy;
16          uint256 public constant DOL_POSITION_ID = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


22          uint256 public COLLATERAL_AND_DEBT_POSITION_TYPE = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


9           uint256 public constant GEARBOX_POSITION_ID = 3;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


8           address public lido;
9           address public lidoWithdrawal;
10          address public steth;
11          address public weth;
13          uint256 public LIDO_WITHDRAWAL_REQUEST_ID = 10;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


30          address mav;
31          address veMav;
32          address maverickRouter;
33          IPositionInspector positionInspector;
35          uint256 public MAVERICK_LP = 10;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


13          IMorpho public immutable morphoBlue;
14          uint256 constant ORACLE_PRICE_SCALE = 1e36;
15          uint256 public constant MORPHO_POSITION_ID = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


12          IMasterchefV3 public masterchef;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


22          IPendleMarketDepositHelper public pendleMarketDepositHelper;
23          IPAllActionV3 public pendleRouter;
24          IPendleStaticRouter public staticRouter;
26          uint256 public constant PENDLE_POSITION_ID = 11;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


14          uint256 public constant PRISMA_POSITION_ID = 10;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


14          IV3CoreProxy public SNXCoreProxy;
16          uint256 public constant SNX_POSITION_ID = 1;
17          uint256 public constant SNX_POOL_POSITION_ID = 2;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


9           ISiloRepository public siloRepository;
10          uint256 public constant SILO_LP_ID = 11;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


22          IStargateLPStaking LPStaking;
23          IStargateRouter stargateRouter;
24          address rewardToken;
26          uint256 public constant STARGATE_LP_POSITION_TYPE = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


16          INonfungiblePositionManager public immutable positionManager;
17          IUniswapV3Factory public immutable factory;
19          uint256 public constant UNI_LP_POSITION_TYPE = 5;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


10          mapping(address => bool) public isOwner;
11          bytes32 public constant TXTYPE_HASH = keccak256(
14          uint256 public nonce;
15          uint8 public threshold;
16          uint256 public numOwners;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/governance/NoyaGovernanceBase.sol


7           PositionRegistry public registry;
8           uint256 public vaultId;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


25          SwapAndBridgeHandler public swapHandler;
26          INoyaValueOracle public valueOracle;
28          uint256 public MINIMUM_HEALTH_FACTOR = 15e17;
29          uint256 public minimumHealthFactor;
31          uint256 public DUST_LEVEL = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


17          uint256 public vaultId = 0;
18          PositionRegistry public registry;
20          uint256 public constant positionType = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


19          mapping(uint32 => ChainInfo) public chainInfo; // chainId => ChainInfo
20          mapping(uint256 => VaultInfo) public vaultIdToVaultInfo; // vaultId => VaultInfo
24          uint32 constant TVL_UPDATE = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


20          mapping(uint256 => ChainInfo) public chainInfo; // chainId => ChainInfo
21          mapping(uint256 => VaultInfo) public vaultIdToVaultInfo; // vaultId => VaultInfo
23          bytes messageSetting;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


17          address payable public lzHelper;
19          uint256 public constant BRIDGE_TXN_WAITING_TIME = 30 minutes;
21          mapping(uint256 => address) public destChainAddress;
22          mapping(bytes32 => uint256) public approvedBridgeTXN;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


11          uint256 public constant OMNICHAIN_POSITION_ID = 13;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


13          mapping(address => bool) public isEligibleToUse;
14          INoyaValueOracle public valueOracle;
15          mapping(address => mapping(address => uint256)) public slippageTolerance;
16          uint256 public genericSlippageTolerance = 50_000; // 5% slippage tolerance
17          RouteData[] public routes;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


13          mapping(address => bool) public isHandler;
14          mapping(string => bool) public isBridgeWhiteListed;
15          mapping(uint256 => bool) public isChainSupported;
16          address public lifi;
18          bytes4 public constant LI_FI_GENERIC_SWAP_SELECTOR = 0x4630a0d8;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


11          PositionRegistry public registry;
14          mapping(address => mapping(address => address[])) public priceRoutes;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


11          PositionRegistry public registry;
26          address public constant USD = address(840);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


14          mapping(address => mapping(address => address)) public assetToBaseToPool;
16          address public factory;
17          PositionRegistry public registry;
19          uint32 public period = 1800;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## NC101 - State variable declarations should have Natspec @dev annotations:

Explain to a developer any extra details


<details>
<summary>Click to show 36 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


21          DepositQueue public depositQueue;
23          WithdrawQueue public withdrawQueue;
43          uint256 public profitStoredTime;
45          uint256 public lastFeeDistributionTime;
47          uint256 public totalProfitCalculated;
52          uint256 public constant FEE_PRECISION = 1e6;
53          uint256 public constant WITHDRAWAL_MAX_FEE = 5e4;
54          uint256 public constant MANAGEMENT_MAX_FEE = 5e5;
55          uint256 public constant PERFORMANCE_MAX_FEE = 1e5;
63          uint256 public withdrawFee; // 0.0001% = 1
65          uint256 public performanceFee;
67          uint256 public managementFee;
69          address public withdrawFeeReceiver;
71          address public performanceFeeReceiver;
73          address public managementFeeReceiver;
82          uint256 public depositWaitingTime = 30 minutes;
84          uint256 public withdrawWaitingTime = 6 hours;
87          uint256 public depositLimitTotalAmount = 1e6 * 200_000;
89          uint256 public depositLimitPerTransaction = 1e6 * 2000;
92          INoyaValueOracle public valueOracle;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


8           address public receiver;
9           address public accountingManager;
10          address public baseToken;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


15          bytes32 public constant MAINTAINER_ROLE = keccak256("MAINTAINER_ROLE");
17          bytes32 public constant GOVERNER_ROLE = keccak256("GOVERNER_ROLE");
19          bytes32 public constant EMERGENCY_ROLE = keccak256("EMERGENCY_ROLE");
21          uint256 public constant MAX_NUM_HOLDING_POSITIONS = 40;
23          uint256 public maxNumHoldingPositions = 20;
26          mapping(uint256 => Vault) public vaults;
28          address public flashLoan;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


18          address immutable pool;
22          address immutable poolBaseToken;
24          uint256 public constant AAVE_POSITION_ID = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


31          uint256 public constant AERODROME_POSITION_TYPE = 1;
33          IRouter aerodromeRouter;
34          IVoter voter;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


27          address internal balancerVault;
29          address public BAL;
30          address public AURA;
32          uint256 public BALANCER_LP_POSITION = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


15          IBalancerVault internal vault;
16          PositionRegistry public registry;
17          address caller;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


31          ICamelotRouter public router;
32          ICamelotFactory public factory;
34          uint256 public constant CAMELOT_POSITION_ID = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


8           uint256 public COMPOUND_LP = 2;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


26          IBooster public convexBooster;
27          address public CVX;
28          address public CRV;
29          address public PRISMA;
31          uint256 public constant CURVE_LP_POSITION = 4;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


12          IDepositWithdrawalProxy public depositWithdrawalProxy;
13          IDolomiteMargin public dolomiteMargin;
14          IBorrowPositionProxyV1 public borrowPositionProxy;
16          uint256 public constant DOL_POSITION_ID = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


22          uint256 public COLLATERAL_AND_DEBT_POSITION_TYPE = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


9           uint256 public constant GEARBOX_POSITION_ID = 3;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


8           address public lido;
9           address public lidoWithdrawal;
10          address public steth;
11          address public weth;
13          uint256 public LIDO_WITHDRAWAL_REQUEST_ID = 10;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


30          address mav;
31          address veMav;
32          address maverickRouter;
33          IPositionInspector positionInspector;
35          uint256 public MAVERICK_LP = 10;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


13          IMorpho public immutable morphoBlue;
14          uint256 constant ORACLE_PRICE_SCALE = 1e36;
15          uint256 public constant MORPHO_POSITION_ID = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


12          IMasterchefV3 public masterchef;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


22          IPendleMarketDepositHelper public pendleMarketDepositHelper;
23          IPAllActionV3 public pendleRouter;
24          IPendleStaticRouter public staticRouter;
26          uint256 public constant PENDLE_POSITION_ID = 11;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


14          uint256 public constant PRISMA_POSITION_ID = 10;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


14          IV3CoreProxy public SNXCoreProxy;
16          uint256 public constant SNX_POSITION_ID = 1;
17          uint256 public constant SNX_POOL_POSITION_ID = 2;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


9           ISiloRepository public siloRepository;
10          uint256 public constant SILO_LP_ID = 11;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


22          IStargateLPStaking LPStaking;
23          IStargateRouter stargateRouter;
24          address rewardToken;
26          uint256 public constant STARGATE_LP_POSITION_TYPE = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


16          INonfungiblePositionManager public immutable positionManager;
17          IUniswapV3Factory public immutable factory;
19          uint256 public constant UNI_LP_POSITION_TYPE = 5;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


10          mapping(address => bool) public isOwner;
11          bytes32 public constant TXTYPE_HASH = keccak256(
14          uint256 public nonce;
15          uint8 public threshold;
16          uint256 public numOwners;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/governance/NoyaGovernanceBase.sol


7           PositionRegistry public registry;
8           uint256 public vaultId;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


25          SwapAndBridgeHandler public swapHandler;
26          INoyaValueOracle public valueOracle;
28          uint256 public MINIMUM_HEALTH_FACTOR = 15e17;
29          uint256 public minimumHealthFactor;
31          uint256 public DUST_LEVEL = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


17          uint256 public vaultId = 0;
18          PositionRegistry public registry;
20          uint256 public constant positionType = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


19          mapping(uint32 => ChainInfo) public chainInfo; // chainId => ChainInfo
20          mapping(uint256 => VaultInfo) public vaultIdToVaultInfo; // vaultId => VaultInfo
24          uint32 constant TVL_UPDATE = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


20          mapping(uint256 => ChainInfo) public chainInfo; // chainId => ChainInfo
21          mapping(uint256 => VaultInfo) public vaultIdToVaultInfo; // vaultId => VaultInfo
23          bytes messageSetting;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


17          address payable public lzHelper;
19          uint256 public constant BRIDGE_TXN_WAITING_TIME = 30 minutes;
21          mapping(uint256 => address) public destChainAddress;
22          mapping(bytes32 => uint256) public approvedBridgeTXN;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


11          uint256 public constant OMNICHAIN_POSITION_ID = 13;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


13          mapping(address => bool) public isEligibleToUse;
14          INoyaValueOracle public valueOracle;
15          mapping(address => mapping(address => uint256)) public slippageTolerance;
16          uint256 public genericSlippageTolerance = 50_000; // 5% slippage tolerance
17          RouteData[] public routes;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


13          mapping(address => bool) public isHandler;
14          mapping(string => bool) public isBridgeWhiteListed;
15          mapping(uint256 => bool) public isChainSupported;
16          address public lifi;
18          bytes4 public constant LI_FI_GENERIC_SWAP_SELECTOR = 0x4630a0d8;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


11          PositionRegistry public registry;
13          mapping(address => INoyaValueOracle) public defaultPriceSource;
14          mapping(address => mapping(address => address[])) public priceRoutes;
16          mapping(address => mapping(address => INoyaValueOracle)) public priceSource;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


11          PositionRegistry public registry;
14          uint256 public chainlinkPriceAgeThreshold = 2 hours;
25          address public constant ETH = address(0);
26          address public constant USD = address(840);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


14          mapping(address => mapping(address => address)) public assetToBaseToPool;
16          address public factory;
17          PositionRegistry public registry;
19          uint32 public period = 1800;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## NC102 - Functions should have Natspec @return annotations:

Documents the return variables of a contract’s function


<details>
<summary>Click to show 31 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


150         function sendTokensToTrustedAddress(address token, uint256 amount, address _caller, bytes calldata _data)
505         function collectManagementFees() public onlyManager nonReentrant returns (uint256, uint256) {
582         function getProfit() public view returns (uint256) {
591         function totalAssets() public view override returns (uint256) {
596         function getQueueItems(bool depositOrWithdraw, uint256[] memory items)
616         function neededAssetsForWithdraw() public view returns (uint256) {
627         function TVL() public view returns (uint256) {
632         function getPositionTVL(HoldingPI memory position, address base) public view returns (uint256) {
642         function _getValue(address token, address base, uint256 amount) internal view returns (uint256) {
649         function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {
693         function mint(uint256 shares, address receiver) public override returns (uint256) {
697         function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256) {
701         function redeem(uint256 shares, address receiver, address shareOwner) public override returns (uint256) {
705         function deposit(uint256 assets, address receiver) public override returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


224         function getPositionBP(uint256 vaultId, bytes32 _positionId) public view returns (PositionBP memory) {
293         function updateHoldingPosition(
335         function updateHoldingPosition(
394         function getHoldingPositionIndex(uint256 vaultId, bytes32 _positionId, address _connector, bytes memory data)
408         function getHoldingPosition(uint256 vaultId, uint256 i) public view returns (HoldingPI memory) {
416         function getHoldingPositions(uint256 vaultId) public view returns (HoldingPI[] memory) {
426         function isPositionTrusted(uint256 vaultId, bytes32 _positionId) public view returns (bool) {
436         function isPositionTrustedForConnector(uint256 vaultId, bytes32 _positionId, address connector)
449         function getGovernanceAddresses(uint256 vaultId)
470         function isTokenTrusted(uint256 vaultId, address token, address connector) public view returns (bool) {
486         function calculatePositionId(address calculatorConnector, uint256 positionTypeId, bytes memory data)
499         function isAnActiveConnector(uint256 vaultId, address connectorAddress) public view returns (bool) {
508         function isPositionDebt(uint256 vaultId, bytes32 _positionId) public view returns (bool) {
516         function getVaultAddresses(uint256 vaultId) public view returns (address, address) {
525         function isAddressTrusted(uint256 vaultId, address addr) public view returns (bool) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


114         function _getPositionTVL(HoldingPI memory, address base) public view override returns (uint256 tvl) {
120         function _getUnderlyingTokens(uint256, bytes memory) public pure override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


117         function _getUnderlyingTokens(uint256 p, bytes memory data) public view override returns (address[] memory) {
125         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


162         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {
175         function totalLpBalanceOf(PoolInfo memory pool) public view returns (uint256) {
184         function totalLpBalanceOf(bytes32 poolId) public view returns (uint256) {
189         function _getPoolInfo(bytes32 pooId) internal view returns (PoolInfo memory, bytes32) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


88          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
99          function _getUnderlyingTokens(uint256 id, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


74          function getAccountHealthFactor(IComet comet) public view returns (uint256) {
84          function getBorrowBalanceInBase(IComet comet) public view returns (uint256 borrowBalanceInVirtualBase) {
95          function getCollBlanace(IComet comet, bool riskAdjusted) public view returns (uint256 CollValue) {
125         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {
134         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {
141         function isInAsset(uint16 assetsIn, uint8 assetOffset) public pure returns (bool) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


258         function _getPoolInfo(address pool) internal view returns (PoolInfo memory) {
265         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
279         function LPToUnder(PoolInfo memory info, uint256 balance) public view returns (uint256, address) {
311         function totalLpBalanceOf(PoolInfo memory info) public view returns (uint256) {
325         function balanceOfConvexRewardPool(PoolInfo memory info) public view returns (uint256) {
335         function balanceOfLPToken(PoolInfo memory info) public view returns (uint256) {
344         function balanceOfRewardPool(PoolInfo memory info) public view returns (uint256) {
354         function balanceOfPrisma(address prismaPool) public view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


106         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


142         function _getUnderlyingTokens(uint256 p, bytes memory data) public view override returns (address[] memory) {
150         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


93          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


91          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


149         function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {
153         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
161         function _getUnderlyingTokens(uint256 id, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


108         function getHealthFactor(Id _id, Market memory _market) public view returns (uint256) {
118         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
137         function convertCToL(uint256 amount, address marketOracle, address collateral) public view returns (uint256) {
141         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


257         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
293         function getYTValue(address market, uint256 balance) public view returns (uint256) {
303         function isMarketEmpty(IPMarket market) public view returns (bool) {
311         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


145         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
164         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


64          function onERC721Received(address, address, uint256, bytes memory) external pure override returns (bytes4) {
121         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
128         function _getUnderlyingTokens(uint256, bytes memory) public pure override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


71          function getData(address siloToken)
109         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
130         function isSiloEmpty(ISilo silo) public view returns (bool) {
143         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


110         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
123         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


116         function getCurrentLiquidity(uint256 tokenId) public view returns (uint128, address, address) {
122         function _collectFees(uint256 tokenId) internal returns (uint256 amount0, uint256 amount1) {
127         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
152         function _getUnderlyingTokens(uint256, bytes memory data) public pure override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


124         function domainSeparatorV4() public view returns (bytes32) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


84          function sendTokensToTrustedAddress(address token, uint256 amount, address caller, bytes memory data)
221         function _executeSwap(SwapRequest memory swapRequest) internal returns (uint256 amountOut) {
232         function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {
249         function getPositionTVL(HoldingPI memory p, address baseToken) public view returns (uint256) {
253         function _getValue(address token, address baseToken, uint256 amount) internal view returns (uint256) {
263         function _getUnderlyingTokens(uint256, bytes memory) public view virtual returns (address[] memory) {
267         function _addLiquidity(address[] memory, uint256[] memory, bytes memory) internal virtual returns (bool) {
271         function _getPositionTVL(HoldingPI memory, address) public view virtual returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


27          function sendTokensToTrustedAddress(address token, uint256 amount, address caller, bytes memory data)
71          function getPositionTVL(HoldingPI memory p, address baseToken) public view returns (uint256) {
75          function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


40          function _payNative(uint256 amount) internal override returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


51          function _getPositionTVL(HoldingPI memory position, address) public view override returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol


19          function getTVL() public view returns (uint256) {
33          function _getPositionTVL(HoldingPI memory position, address base) public view override returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


150         function verifyBridgeData(BridgeRequest calldata _request) public view override returns (bool) {
189         function _isNative(IERC20 token) internal pure returns (bool isNative) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/TVLHelper.sol


41          function getLatestUpdateTime(uint256 vaultId, PositionRegistry registry) public view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/TVLHelper.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


71          function getValue(address asset, address baseToken, uint256 amount) public view returns (uint256) {
81          function _getValue(address asset, address baseToken, uint256 amount, address[] memory sources)
95          function _getValue(address quotingToken, address baseToken, uint256 amount) internal view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


138         function getTokenDecimals(address token) public view returns (uint256) {
143         function getSourceOfAsset(address asset, address baseToken) public view returns (address source, bool isInverse) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/WETH_Oracle.sol


5           function latestRoundData()


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/WETH_Oracle.sol#L0:0

</details>

## NC103 - Functions should have Natspec @param annotations:

Documents a parameter just like in Doxygen (must be followed by parameter name)


<details>
<summary>Click to show 40 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


94          constructor(AccountingManagerConstructorParams memory p)
124         function updateValueOracle(INoyaValueOracle _valueOracle) public onlyMaintainer {
150         function sendTokensToTrustedAddress(address token, uint256 amount, address _caller, bytes calldata _data)
185         function _update(address from, address to, uint256 amount) internal override {
200         function deposit(address receiver, uint256 amount, address referrer) public nonReentrant whenNotPaused {
328         function calculateWithdrawShares(uint256 maxIterations) public onlyManager nonReentrant whenNotPaused {
360         function startCurrentWithdrawGroup() public onlyManager nonReentrant whenNotPaused {
370         function fulfillCurrentWithdrawGroup() public onlyManager nonReentrant whenNotPaused {
475         function recordProfitForFee() public onlyManager nonReentrant {
493         function checkIfTVLHasDroped() public nonReentrant {
505         function collectManagementFees() public onlyManager nonReentrant returns (uint256, uint256) {
526         function collectPerformanceFees() public onlyManager nonReentrant {
543         function burnShares(uint256 amount) public {
548         function retrieveTokensForWithdraw(RetrieveData[] calldata retrieveData) public onlyManager nonReentrant {
582         function getProfit() public view returns (uint256) {
591         function totalAssets() public view override returns (uint256) {
596         function getQueueItems(bool depositOrWithdraw, uint256[] memory items)
616         function neededAssetsForWithdraw() public view returns (uint256) {
627         function TVL() public view returns (uint256) {
632         function getPositionTVL(HoldingPI memory position, address base) public view returns (uint256) {
642         function _getValue(address token, address base, uint256 amount) internal view returns (uint256) {
649         function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {
659         function emergencyStop() public whenNotPaused onlyEmergency {
663         function unpause() public whenPaused onlyEmergency {
667         function setDepositLimits(uint256 _depositLimitPerTransaction, uint256 _depositTotalAmount) public onlyMaintainer {
673         function changeDepositWaitingTime(uint256 _depositWaitingTime) public onlyMaintainer {
678         function changeWithdrawWaitingTime(uint256 _withdrawWaitingTime) public onlyMaintainer {
683         function rescue(address token, uint256 amount) public onlyEmergency nonReentrant {
693         function mint(uint256 shares, address receiver) public override returns (uint256) {
697         function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256) {
701         function redeem(uint256 shares, address receiver, address shareOwner) public override returns (uint256) {
705         function deposit(uint256 assets, address receiver) public override returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


14          constructor(address _accountingManager, address _baseToken, address _receiver) Ownable(msg.sender) {
23          function withdrawShares(uint256 amount) external onlyOwner {
27          function burnShares(uint256 amount) external onlyOwner {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


79          function setMaxNumHoldingPositions(uint256 _maxNumHoldingPositions) external onlyRole(MAINTAINER_ROLE) {
84          function setFlashLoanAddress(address _flashLoan) external onlyRole(MAINTAINER_ROLE) {
266         function removeTrustedPosition(uint256 vaultId, bytes32 _positionId)
370         function updateHoldingPostionWithTime(
394         function getHoldingPositionIndex(uint256 vaultId, bytes32 _positionId, address _connector, bytes memory data)
408         function getHoldingPosition(uint256 vaultId, uint256 i) public view returns (HoldingPI memory) {
416         function getHoldingPositions(uint256 vaultId) public view returns (HoldingPI[] memory) {
426         function isPositionTrusted(uint256 vaultId, bytes32 _positionId) public view returns (bool) {
436         function isPositionTrustedForConnector(uint256 vaultId, bytes32 _positionId, address connector)
449         function getGovernanceAddresses(uint256 vaultId)
470         function isTokenTrusted(uint256 vaultId, address token, address connector) public view returns (bool) {
486         function calculatePositionId(address calculatorConnector, uint256 positionTypeId, bytes memory data)
499         function isAnActiveConnector(uint256 vaultId, address connectorAddress) public view returns (bool) {
508         function isPositionDebt(uint256 vaultId, bytes32 _positionId) public view returns (bool) {
516         function getVaultAddresses(uint256 vaultId) public view returns (address, address) {
525         function isAddressTrusted(uint256 vaultId, address addr) public view returns (bool) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


33          constructor(address _pool, address _poolBaseToken, BaseConnectorCP memory baseConnectorParams)
46          function supply(address supplyToken, uint256 amount) external onlyManager nonReentrant {
81          function repay(address asset, uint256 amount, uint256 i) external onlyManager nonReentrant {
88          function repayWithCollateral(uint256 _amount, uint256 i, address _borrowAsset) external onlyManager {
114         function _getPositionTVL(HoldingPI memory, address base) public view override returns (uint256 tvl) {
120         function _getUnderlyingTokens(uint256, bytes memory) public pure override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


40          constructor(address _router, address _voter, BaseConnectorCP memory baseConnectorParams)
100         function stake(address pool, uint256 liquidity) public onlyManager nonReentrant {
106         function unstake(address pool, uint256 liquidity) public onlyManager nonReentrant {
111         function claim(address pool) public onlyManager nonReentrant {
117         function _getUnderlyingTokens(uint256 p, bytes memory data) public view override returns (address[] memory) {
125         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


42          constructor(address _balancerVault, address bal, address aura, BaseConnectorCP memory baseConnectorParams)
53          function harvestAuraRewards(address[] calldata rewardsPools) public onlyManager nonReentrant {
64          function openPosition(
109         function depositIntoAuraBooster(bytes32 poolId, uint256 _amount) public onlyManager nonReentrant {
115         function decreasePosition(DecreasePositionParams memory p) public onlyManager nonReentrant {
162         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {
175         function totalLpBalanceOf(PoolInfo memory pool) public view returns (uint256) {
184         function totalLpBalanceOf(bytes32 poolId) public view returns (uint256) {
189         function _getPoolInfo(bytes32 pooId) internal view returns (PoolInfo memory, bytes32) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


24          constructor(address _balancerVault, PositionRegistry _registry) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


36          constructor(address _router, address _factory, BaseConnectorCP memory baseCP) BaseConnector(baseCP) {
43          function addLiquidityInCamelotPool(CamelotAddLiquidityParams calldata p) external onlyManager nonReentrant {
65          function removeLiquidityFromCamelotPool(CamelotRemoveLiquidityParams calldata p)
88          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
99          function _getUnderlyingTokens(uint256 id, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


17          constructor(BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) { }
63          function claimRewards(address rewardContract, address market) external onlyManager nonReentrant {
74          function getAccountHealthFactor(IComet comet) public view returns (uint256) {
84          function getBorrowBalanceInBase(IComet comet) public view returns (uint256 borrowBalanceInVirtualBase) {
95          function getCollBlanace(IComet comet, bool riskAdjusted) public view returns (uint256 CollValue) {
125         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {
134         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {
141         function isInAsset(uint16 assetsIn, uint8 assetOffset) public pure returns (bool) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


45          constructor(
81          function depositIntoPrisma(address pool, uint256 amount, bool curveOrConvex) public onlyManager nonReentrant {
103         function depositIntoConvexBooster(address pool, uint256 pid, uint256 amount, bool stake) public onlyManager {
117         function openCurvePosition(address pool, uint256 depositIndex, uint256 amount, uint256 minAmount)
160         function decreaseCurvePosition(address pool, uint256 withdrawIndex, uint256 amount, uint256 minAmount)
182         function withdrawFromConvexBooster(uint256 pid, uint256 amount) public onlyManager {
202         function withdrawFromGauge(address pool, uint256 amount) public onlyManager {
212         function withdrawFromPrisma(address depostiToken, uint256 amount) public onlyManager {
221         function harvestRewards(address[] calldata gauges) public onlyManager nonReentrant {
233         function harvestPrismaRewards(address[] calldata pools) public onlyManager nonReentrant {
247         function harvestConvexRewards(address[] calldata rewardsPools) public onlyManager nonReentrant {
258         function _getPoolInfo(address pool) internal view returns (PoolInfo memory) {
265         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
279         function LPToUnder(PoolInfo memory info, uint256 balance) public view returns (uint256, address) {
311         function totalLpBalanceOf(PoolInfo memory info) public view returns (uint256) {
325         function balanceOfConvexRewardPool(PoolInfo memory info) public view returns (uint256) {
335         function balanceOfLPToken(PoolInfo memory info) public view returns (uint256) {
344         function balanceOfRewardPool(PoolInfo memory info) public view returns (uint256) {
354         function balanceOfPrisma(address prismaPool) public view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


18          constructor(
30          function deposit(uint256 marketId, uint256 _amount) public onlyManager nonReentrant {
43          function withdraw(uint256 marketId, uint256 _amount) public onlyManager nonReentrant {
58          function openBorrowPosition(uint256 marketId, uint256 _amountWei, uint256 accountId)
77          function transferBetweenAccounts(uint256 accountId, uint256 marketId, uint256 _amountWei, bool borrowOrRepay)
98          function closeBorrowPosition(uint256[] memory marketIds, uint256 accountId) public onlyManager nonReentrant {
106         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


29          constructor(BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) { }
68          function withdraw(IFraxPair pool, uint256 withdrawAmount) public onlyManager nonReentrant {
104         function verifyHealthFactor(IFraxPair pool) public view {
142         function _getUnderlyingTokens(uint256 p, bytes memory data) public view override returns (address[] memory) {
150         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


17          constructor(BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) { }
24          function openAccount(address facade, uint256 ref) public onlyManager {
41          function closeAccount(address facade, address creditAccount) public onlyManager nonReentrant {
62          function executeCommands(
93          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


20          constructor(address _lido, address _lidoW, address _steth, address w, BaseConnectorCP memory baseConnectorParams)
37          function deposit(uint256 amountIn) external onlyManager nonReentrant {
51          function requestWithdrawals(uint256 amount) public onlyManager nonReentrant {
69          function claimWithdrawal(uint256 requestId) public onlyManager nonReentrant {
89          receive() external payable { }
91          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


43          constructor(address _mav, address _veMav, address mr, address pi, BaseConnectorCP memory baseCP)
56          receive() external payable { }
64          function stake(uint256 amount, uint256 duration, bool doDelegation) external onlyManager nonReentrant {
78          function unstake(uint256 lockupId) external onlyManager nonReentrant {
115         function removeLiquidityFromMaverickPool(MavericRemoveLiquidityParams calldata p)
137         function claimBoostedPositionRewards(IMaverickReward rewardContract) external onlyManager nonReentrant {
149         function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {
153         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
161         function _getUnderlyingTokens(uint256 id, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


23          constructor(address MB, BaseConnectorCP memory baseCP) BaseConnector(baseCP) {
58          function withdraw(uint256 amount, Id id, bool sOrC) external onlyManager nonReentrant {
80          function borrow(uint256 amount, Id id) external onlyManager nonReentrant {
95          function repay(uint256 amount, Id id) public onlyManager nonReentrant {
108         function getHealthFactor(Id _id, Market memory _market) public view returns (uint256) {
118         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
137         function convertCToL(uint256 amount, address marketOracle, address collateral) public view returns (uint256) {
141         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


19          constructor(address MC, address _positionManager, address _factory, BaseConnectorCP memory baseConnectorParams)
31          function sendPositionToMasterChef(uint256 tokenId) external onlyManager nonReentrant {
40          function updatePosition(uint256 tokenId) public onlyManager nonReentrant {
50          function withdraw(uint256 tokenId) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


97          function mintPTAndYT(address market, uint256 syAmount) external onlyManager nonReentrant {
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
149         function swapYTForPT(address market, uint256 exactYTIn, uint256 min, ApproxParams memory guess)
183         function swapExactPTForSY(IPMarket market, uint256 exactPTIn, bytes calldata swapData, uint256 minSY)
203         function burnLP(IPMarket market, uint256 amount) external onlyManager nonReentrant {
216         function decreasePosition(IPMarket market, uint256 _amount, bool closePosition) external onlyManager nonReentrant {
241         function claimRewards(IPMarket market) external onlyManager nonReentrant {
257         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
293         function getYTValue(address market, uint256 balance) public view returns (uint256) {
303         function isMarketEmpty(IPMarket market) public view returns (bool) {
311         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


33          function approveZap(IStakeNTroveZap zap, address tm, bool approve) public onlyManager nonReentrant {
52          function openTrove(IStakeNTroveZap zap, address tm, uint256 maxFee, uint256 dAmount, uint256 bAmount)
145         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
164         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


20          constructor(address _SNXCoreProxy, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {
25          function createAccount() public onlyManager {
30          function deposit(address _token, uint256 _amount, uint128 _accountId) public onlyManager {
46          function withdraw(address _token, uint256 _amount, uint128 _accountId) public onlyManager {
64          function onERC721Received(address, address, uint256, bytes memory) external pure override returns (bytes4) {
68          function delegateIntoPreferredPool(
81          function delegateIntoApprovedPool(
94          function claimRewards(uint128 accountId, uint128 poolId, address collateralType, address distributor)
102         function mintOrBurnSUSD(
121         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
128         function _getUnderlyingTokens(uint256, bytes memory) public pure override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


17          constructor(address SR, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {
33          function deposit(address siloToken, address dToken, uint256 amount, bool oC) external onlyManager nonReentrant {
71          function getData(address siloToken)
85          function borrow(address siloToken, address bToken, uint256 amount) external onlyManager nonReentrant {
98          function repay(address siloToken, address rToken, uint256 amount) external onlyManager nonReentrant {
109         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
130         function isSiloEmpty(ISilo silo) public view returns (bool) {
143         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


33          constructor(address lpStacking, address _stargateRouter, BaseConnectorCP memory baseConnectorParams)
76          function withdrawFromStargatePool(StargateRequest calldata withdrawRequest) external onlyManager nonReentrant {
103         function claimStargateRewards(uint256 poolId) external onlyManager nonReentrant {
110         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
123         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


27          constructor(address _positionManager, address _factory, BaseConnectorCP memory baseConnectorParams)
63          function decreasePosition(DecreaseLiquidityParams memory p) external onlyManager nonReentrant {
87          function increasePosition(IncreaseLiquidityParams memory p) external onlyManager nonReentrant {
122         function _collectFees(uint256 tokenId) internal returns (uint256 amount0, uint256 amount1) {
127         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
152         function _getUnderlyingTokens(uint256, bytes memory data) public pure override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


42          function updateOwners(address[] memory _owners, bool[] memory addOrRemove) public onlyOwner {
63          function setThreshold(uint8 _threshold) public onlyOwner {
84          function execute(
124         function domainSeparatorV4() public view returns (bytes32) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/governance/NoyaGovernanceBase.sol


21          constructor(PositionRegistry _registry, uint256 _vaultId) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L0:0

```solidity
File: contracts/governance/TimeLock.sol


7           constructor(uint256 minDelay, address[] memory proposers, address[] memory executors, address owner)


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/TimeLock.sol#L0:0

```solidity
File: contracts/governance/Watchers.sol


7           constructor(address[] memory _owners, uint8 _threshold) Keepers(_owners, _threshold) { }
8           function verifyRemoveLiquidity(uint256 withdrawAmount, uint256 sentAmount, bytes memory data) external view { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Watchers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


33          constructor(BaseConnectorCP memory params) NoyaGovernanceBase(params.registry, params.vaultId) {
67          function updateValueOracle(address _valueOracle) external onlyMaintainer {
84          function sendTokensToTrustedAddress(address token, uint256 amount, address caller, bytes memory data)
122         function transferPositionToAnotherConnector(
135         function _updateTokenInRegistry(address token, bool remove) internal {
153         function updateTokenInRegistry(address token) public onlyManager {
158         function _updateTokenInRegistry(address token) internal {
169         function addLiquidity(address[] memory tokens, uint256[] memory amounts, bytes memory data)
221         function _executeSwap(SwapRequest memory swapRequest) internal returns (uint256 amountOut) {
232         function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {
249         function getPositionTVL(HoldingPI memory p, address baseToken) public view returns (uint256) {
253         function _getValue(address token, address baseToken, uint256 amount) internal view returns (uint256) {
263         function _getUnderlyingTokens(uint256, bytes memory) public view virtual returns (address[] memory) {
267         function _addLiquidity(address[] memory, uint256[] memory, bytes memory) internal virtual returns (bool) {
271         function _getPositionTVL(HoldingPI memory, address) public view virtual returns (uint256 tvl) {
277         function _approveOperations(address _token, address _spender, uint256 _amount) internal virtual {
285         function _revokeApproval(address _token, address _spender) internal virtual {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


22          constructor(address _registry, uint256 _vaultId) {
27          function sendTokensToTrustedAddress(address token, uint256 amount, address caller, bytes memory data)
40          function addLiquidity(address[] memory tokens, uint256[] memory amounts, bytes memory data) external {
51          function updatePositionToRegistryUsingType(bytes32 _positionId, bytes memory data, bool remove) external {
59          function addPositionToRegistryUsingType(uint256 _positionType, bytes memory data) external {
65          function addPositionToRegistry(bytes memory data) external {
71          function getPositionTVL(HoldingPI memory p, address baseToken) public view returns (uint256) {
75          function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {
79          function _updateTokenInRegistry(address token, bool remove) internal {
91          function _updateTokenInRegistry(address token) internal {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


31          constructor(address _endpoint, address _owner) OAppReceiver() OAppCore(_endpoint, _owner) { }
65          function _lzReceive(Origin calldata _origin, bytes32, bytes calldata _message, address, bytes calldata)


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


27          receive() external payable { }
29          constructor(address _endpoint, address _owner) OAppSender() OAppCore(_endpoint, _owner) { }
36          function updateMessageSetting(bytes memory _messageSetting) public onlyOwner {
40          function _payNative(uint256 amount) internal override returns (uint256) {
51          function setChainInfo(uint256 chainId, uint32 lzChainId, address lzHelperAddress) public onlyOwner {
63          function addVaultInfo(uint256 vaultId, uint256 baseChainId, address omniChainManager) public onlyOwner {
75          function updateTVL(uint256 vaultId, uint256 tvl, uint256 updateTime) public {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


46          function updateChainInfo(uint256 chainId, address destinationAddress) external onlyMaintainer {
57          function updateBridgeTransactionApproval(bytes32 transactionHash) public onlyManager {
68          function startBridgeTransaction(BridgeRequest memory bridgeRequest) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


19          constructor(uint256 dl, address payable _lzHelper, BaseConnectorCP memory baseConnectorParams)
51          function _getPositionTVL(HoldingPI memory position, address) public view override returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol


11          constructor(address payable _lzHelper, BaseConnectorCP memory baseConnectorParams)
19          function getTVL() public view returns (uint256) {
28          function updateTVLInfo() external onlyManager {
33          function _getPositionTVL(HoldingPI memory position, address base) public view override returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


34          constructor(address[] memory usersAddresses, address _valueOracle, PositionRegistry _registry, uint256 _vaultId)
158         function setEnableRoute(uint256 _routeId, bool enable) external onlyMaintainerOrEmergency {
164         function verifyRoute(uint256 _routeId, address addr) external view onlyExistingRoute(_routeId) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


27          constructor(address swapHandler, address _lifi) Ownable2Step() Ownable(msg.sender) {
150         function verifyBridgeData(BridgeRequest calldata _request) public view override returns (bool) {
165         function _forward(IERC20 token, address from, uint256 amount, address caller, bytes calldata data, uint256 routeId)
185         function _setAllowance(IERC20 token, address spender, uint256 amount) internal {
189         function _isNative(IERC20 token) internal pure returns (bool isNative) {
193         function rescueFunds(address token, address userAddress, uint256 amount) external onlyOwner {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/TVLHelper.sol


41          function getLatestUpdateTime(uint256 vaultId, PositionRegistry registry) public view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/TVLHelper.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


29          constructor(PositionRegistry _registry) {
61          function updatePriceRoute(address asset, address base, address[] calldata s) external onlyMaintainer {
71          function getValue(address asset, address baseToken, uint256 amount) public view returns (uint256) {
81          function _getValue(address asset, address baseToken, uint256 amount, address[] memory sources)
95          function _getValue(address quotingToken, address baseToken, uint256 amount) internal view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


46          constructor(address _reg) {
138         function getTokenDecimals(address token) public view returns (uint256) {
143         function getSourceOfAsset(address asset, address baseToken) public view returns (address source, bool isInverse) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/WETH_Oracle.sol


5           function latestRoundData()


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/WETH_Oracle.sol#L0:0

</details>

## NC104 - Missing events in sensitive functions:

Sensitive setter functions in smart contracts often alter critical state variables. Without events emitted in these functions, external observers or dApps cannot easily track or react to these state changes. Missing events can obscure contract activity, hampering transparency and making integration more challenging. To resolve this, incorporate appropriate event emissions within these functions. Events offer an efficient way to log crucial changes, aiding in real-time tracking and post-transaction verification..


<details>
<summary>Click to show 4 findings</summary>

```solidity
File: contracts/accountingManager/Registry.sol


79          function setMaxNumHoldingPositions(uint256 _maxNumHoldingPositions) external onlyRole(MAINTAINER_ROLE) {
80              require(_maxNumHoldingPositions <= MAX_NUM_HOLDING_POSITIONS);
81              maxNumHoldingPositions = _maxNumHoldingPositions;
82          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


40          function setChainInfo(uint256 chainId, uint32 lzChainId, address lzHelperAddress) public onlyOwner {
41              require(lzHelperAddress != address(0));
42              chainInfo[lzChainId] = ChainInfo(chainId, lzHelperAddress);
43          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


51          function setChainInfo(uint256 chainId, uint32 lzChainId, address lzHelperAddress) public onlyOwner {
52              require(lzHelperAddress != address(0));
53              chainInfo[chainId] = ChainInfo(lzChainId, lzHelperAddress);
54          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


185         function _setAllowance(IERC20 token, address spender, uint256 amount) internal {
186             token.forceApprove(spender, amount);
187         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

</details>

## NC105 - If statement control structures do not comply with best practices:

If statements which include a single line do not need to have curly brackets, however according to the Solidiity style guide the line of code executed upon the if statement condition being met should still be on the next line, not on the same line as the if statement declaration.


<details>
<summary>Click to show 20 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


560                 if (balanceBefore + amount > balanceAfter) revert NoyaAccounting_banalceAfterIsNotEnough();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


54              if (vaults[_vaultId].accountManager == address(0)) revert NotExist();
118             if (vaults[vaultId].accountManager != address(0)) revert AlreadyExists();
250                 if (vault.trustedPositionsBP[positionId].isEnabled) revert AlreadyExists();
251                 if (vault.connectors[calculatorConnector].enabled == false) revert NotExist();
272             if (!vault.trustedPositionsBP[_positionId].isEnabled) revert NotExist();
343             if (!vault.connectors[msg.sender].enabled) revert UnauthorizedAccess();
344             if (!vault.trustedPositionsBP[_positionId].isEnabled) revert InvalidPosition(_positionId);
347             if (positionIndex == 0 && removePosition) return type(uint256).max;
526             if (addr == vaults[vaultId].accountManager) return true;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


73              if (healthFactor < minimumHealthFactor) revert IConnector_LowHealthFactor(healthFactor);
104             if (healthFactor < minimumHealthFactor) revert IConnector_LowHealthFactor(healthFactor);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


78                  if (amounts[i] > 0) _approveOperations(tokens[i], balancerVault, amounts[i]);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


31              if (!registry.isTokenTrusted(vaultId, asset, address(this))) revert IConnector_UntrustedToken(asset);
50              if (!registry.isTokenTrusted(vaultId, asset, address(this))) revert IConnector_UntrustedToken(asset);
52              if (healthFactor < minimumHealthFactor) revert IConnector_LowHealthFactor(healthFactor);
77              if (borrowBalanceInBase == 0) return type(uint256).max;
86              if (borrowBalanceInBase == 0) return 0;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


280             if (balance == 0) return (0, info.tokens[info.defaultWithdrawIndex]);
326             if (info.convexRewardPool == address(0)) return 0;
345             if (info.gauge == address(0)) return 0;
355             if (prismaPool == address(0)) return 0;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


124             if (_borrowerAmount == 0) return type(uint256).max;
126             if (_collateralAmount == 0) return 0;
133             if (currentPositionLTV == 0) return type(uint256).max; // loan is small


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


70                  if (calls[i].target != facade) revert IConnector_InvalidTarget(calls[i].target);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


112             if (borrowAmount == 0) return type(uint256).max;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


275                 if (PTAmount > 0) SYAmount += PTAmount * IPMarket(market).getPtToAssetRate(10) / 1e18;
278                 if (YTBalance > 0) SYAmount += getYTValue(market, YTBalance);
280                 if (SYAmount > 0) underlyingBalance += SYAmount * _SY.exchangeRate() / 1e18;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/governance/NoyaGovernanceBase.sol


45              if (msg.sender != emergencyManager) revert NoyaGovernance_Unauthorized(msg.sender);
67              if (msg.sender != maintainer && msg.sender != emergencyManager) revert NoyaGovernance_Unauthorized(msg.sender);
77              if (msg.sender != maintainer) revert NoyaGovernance_Unauthorized(msg.sender);
87              if (msg.sender != governer) revert NoyaGovernance_Unauthorized(msg.sender);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


103                 if (caller != address(this)) revert IConnector_InvalidAddress(caller);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


76              if (msg.sender != vaultIdToVaultInfo[vaultId].omniChainManager) revert InvalidSender();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


74              if (bridgeRequest.from != address(this)) revert IConnector_InvalidInput();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


33              if (msg.sender != lzHelper) revert IConnector_InvalidSender();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


30              if (routes[_routeId].route == address(0) && !routes[_routeId].isEnabled) revert RouteNotFound();
98              if (_swapRequest.amount == 0) revert InvalidAmount();
100             if (swapImplInfo.isBridge) revert RouteNotAllowedForThisAction();
135             if (!bridgeImplInfo.isBridge) revert RouteNotAllowedForThisAction();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


118             if (from != _request.from) revert InvalidReceiver(from, _request.from);
119             if (receivingAmount < _request.minAmount) revert InvalidMinAmount();
120             if (sendingAssetId != _request.inputToken) revert InvalidInputToken();
121             if (receivingAssetId != _request.outputToken) revert InvalidOutputToken();
122             if (amount != _request.amount) revert InvalidAmount();
153             if (isBridgeWhiteListed[bridgeData.bridge] == false) revert BridgeBlacklisted();
154             if (isChainSupported[bridgeData.destinationChainId] == false) revert InvalidChainId();
155             if (bridgeData.sendingAssetId != _request.inputToken) revert InvalidFromToken();
159             if (bridgeData.minAmount > _request.amount) revert InvalidMinAmount();
160             if (bridgeData.destinationChainId != _request.destChainId) revert InvalidToChainId();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


25              if (!registry.hasRole(registry.MAINTAINER_ROLE(), msg.sender)) revert INoyaValueOracle_Unauthorized(msg.sender);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


42              if (!registry.hasRole(registry.MAINTAINER_ROLE(), msg.sender)) revert INoyaValueOracle_Unauthorized(msg.sender);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


25              if (!registry.hasRole(registry.MAINTAINER_ROLE(), msg.sender)) revert INoyaValueOracle_Unauthorized(msg.sender);
39              if (_period == 0) revert INoyaValueOracle_InvalidInput();
66              if (pool == address(0)) revert INoyaOracle_ValueOracleUnavailable(tokenIn, baseToken);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## NC106 - A event should be emitted if a non immutable state variable is set in a constructor:

  


<details>
<summary>Click to show 26 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


94          constructor(AccountingManagerConstructorParams memory p)
95              ERC4626(IERC20(p._baseTokenAddress))
96              ERC20(p._name, p._symbol)
97              NoyaGovernanceBase(PositionRegistry(p._registry), p._vaultId)
98          {
99              baseToken = IERC20(p._baseTokenAddress);
100             valueOracle = INoyaValueOracle(p._valueOracle);
101             lastFeeDistributionTime = block.timestamp;
102             withdrawFeeReceiver = p._withdrawFeeReceiver;
103             performanceFeeReceiver = p._performanceFeeReceiver;
104             managementFeeReceiver = p._managementFeeReceiver;
105     
106             require(p._baseTokenAddress != address(0));
107             require(p._valueOracle != address(0));
108             require(p._withdrawFeeReceiver != address(0));
109             require(p._performanceFeeReceiver != address(0));
110             require(p._managementFeeReceiver != address(0));
111     
112             if (
113                 p._withdrawFee > WITHDRAWAL_MAX_FEE || p._performanceFee > PERFORMANCE_MAX_FEE
114                     || p._managementFee > MANAGEMENT_MAX_FEE
115             ) {
116                 revert NoyaAccounting_INVALID_FEE();
117             }
118             withdrawFee = p._withdrawFee;
119             performanceFee = p._performanceFee;
120             managementFee = p._managementFee;
121         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


14          constructor(address _accountingManager, address _baseToken, address _receiver) Ownable(msg.sender) {
15              require(_accountingManager != address(0));
16              require(_baseToken != address(0));
17              require(_receiver != address(0));
18              accountingManager = _accountingManager;
19              baseToken = _baseToken;
20              receiver = _receiver;
21          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


66          constructor(address _governer, address _maintainer, address _emergency, address _flashLoan) {
67              require(_governer != address(0));
68              require(_maintainer != address(0));
69              require(_emergency != address(0));
70              _grantRole(GOVERNER_ROLE, _governer);
71              _grantRole(MAINTAINER_ROLE, _maintainer);
72              _grantRole(EMERGENCY_ROLE, _emergency);
73              _setRoleAdmin(GOVERNER_ROLE, GOVERNER_ROLE);
74              _setRoleAdmin(MAINTAINER_ROLE, GOVERNER_ROLE);
75              _setRoleAdmin(EMERGENCY_ROLE, GOVERNER_ROLE);
76              flashLoan = _flashLoan;
77          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


40          constructor(address _router, address _voter, BaseConnectorCP memory baseConnectorParams)
41              BaseConnector(baseConnectorParams)
42          {
43              require(_router != address(0));
44              aerodromeRouter = IRouter(_router);
45              voter = IVoter(_voter);
46          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


42          constructor(address _balancerVault, address bal, address aura, BaseConnectorCP memory baseConnectorParams)
43              BaseConnector(baseConnectorParams)
44          {
45              require(_balancerVault != address(0));
46              require(bal != address(0));
47              require(aura != address(0));
48              AURA = aura;
49              BAL = bal;
50              balancerVault = _balancerVault;
51          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


24          constructor(address _balancerVault, PositionRegistry _registry) {
25              require(_balancerVault != address(0));
26              require(address(_registry) != address(0));
27              vault = IBalancerVault(_balancerVault);
28              registry = _registry;
29          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


36          constructor(address _router, address _factory, BaseConnectorCP memory baseCP) BaseConnector(baseCP) {
37              require(_router != address(0));
38              require(_factory != address(0));
39              router = ICamelotRouter(_router);
40              factory = ICamelotFactory(_factory);
41          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


45          constructor(
46              address _convexBooster,
47              address cvx,
48              address crv,
49              address prisma,
50              BaseConnectorCP memory baseConnectorParams
51          ) BaseConnector(baseConnectorParams) {
52              require(_convexBooster != address(0));
53              require(cvx != address(0));
54              require(crv != address(0));
55              require(prisma != address(0));
56              convexBooster = IBooster(_convexBooster);
57              CVX = cvx;
58              CRV = crv;
59              PRISMA = prisma;
60          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


18          constructor(
19              address _depositWithdrawalProxy,
20              address _dolomiteMargin,
21              address _borrowPositionProxy,
22              BaseConnectorCP memory baseConnectorParams
23          ) BaseConnector(baseConnectorParams) {
24              require(_depositWithdrawalProxy != address(0));
25              depositWithdrawalProxy = IDepositWithdrawalProxy(_depositWithdrawalProxy);
26              dolomiteMargin = IDolomiteMargin(_dolomiteMargin);
27              borrowPositionProxy = IBorrowPositionProxyV1(_borrowPositionProxy);
28          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


20          constructor(address _lido, address _lidoW, address _steth, address w, BaseConnectorCP memory baseConnectorParams)
21              BaseConnector(baseConnectorParams)
22          {
23              require(_lido != address(0));
24              require(_lidoW != address(0));
25              require(_steth != address(0));
26              require(w != address(0));
27              lido = _lido;
28              lidoWithdrawal = _lidoW;
29              steth = _steth;
30              weth = w;
31          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


43          constructor(address _mav, address _veMav, address mr, address pi, BaseConnectorCP memory baseCP)
44              BaseConnector(baseCP)
45          {
46              require(_mav != address(0));
47              require(_veMav != address(0));
48              require(mr != address(0));
49              require(pi != address(0));
50              mav = _mav;
51              veMav = _veMav;
52              maverickRouter = mr;
53              positionInspector = IPositionInspector(pi);
54          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


19          constructor(address MC, address _positionManager, address _factory, BaseConnectorCP memory baseConnectorParams)
20              UNIv3Connector(_positionManager, _factory, baseConnectorParams)
21          {
22              require(MC != address(0));
23              masterchef = IMasterchefV3(MC);
24          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


57          constructor(address _pendleMarketDepositHelper, address _pendleRouter, address SR, BaseConnectorCP memory baseCP)
58              BaseConnector(baseCP)
59          {
60              require(_pendleMarketDepositHelper != address(0));
61              require(_pendleRouter != address(0));
62              require(SR != address(0));
63              pendleMarketDepositHelper = IPendleMarketDepositHelper(_pendleMarketDepositHelper);
64              pendleRouter = IPAllActionV3(_pendleRouter);
65              staticRouter = IPendleStaticRouter(SR);
66          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


20          constructor(address _SNXCoreProxy, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {
21              require(_SNXCoreProxy != address(0));
22              SNXCoreProxy = IV3CoreProxy(_SNXCoreProxy);
23          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


17          constructor(address SR, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {
18              require(SR != address(0));
19      
20              siloRepository = ISiloRepository(SR);
21              MINIMUM_HEALTH_FACTOR = 5e17;
22      
23              minimumHealthFactor = MINIMUM_HEALTH_FACTOR;
24          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


33          constructor(address lpStacking, address _stargateRouter, BaseConnectorCP memory baseConnectorParams)
34              BaseConnector(baseConnectorParams)
35          {
36              require(lpStacking != address(0));
37              require(_stargateRouter != address(0));
38      
39              LPStaking = IStargateLPStaking(lpStacking);
40              stargateRouter = IStargateRouter(_stargateRouter);
41              rewardToken = LPStaking.stargate();
42          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


27          constructor(address[] memory _owners, uint8 _threshold) EIP712("Keepers", "1") Ownable2Step() Ownable(msg.sender) {
28              require(_owners.length <= 10 && _threshold <= _owners.length && _threshold > 1);
29              for (uint256 i = 0; i < _owners.length; i++) {
30                  isOwner[_owners[i]] = true;
31              }
32              numOwners = _owners.length;
33              threshold = _threshold;
34          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/governance/NoyaGovernanceBase.sol


21          constructor(PositionRegistry _registry, uint256 _vaultId) {
22              require(address(_registry) != address(0));
23              registry = _registry;
24              vaultId = _vaultId;
25          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


33          constructor(BaseConnectorCP memory params) NoyaGovernanceBase(params.registry, params.vaultId) {
34              swapHandler = params.swapHandler;
35              valueOracle = params.valueOracle;
36              minimumHealthFactor = MINIMUM_HEALTH_FACTOR;
37          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


22          constructor(address _registry, uint256 _vaultId) {
23              registry = PositionRegistry(_registry);
24              vaultId = _vaultId;
25          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


33          constructor(address payable _lzHelper, BaseConnectorCP memory baseConnectorParams)
34              BaseConnector(baseConnectorParams)
35          {
36              lzHelper = _lzHelper;
37              require(_lzHelper != address(0));
38          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


34          constructor(address[] memory usersAddresses, address _valueOracle, PositionRegistry _registry, uint256 _vaultId)
35              NoyaGovernanceBase(_registry, _vaultId)
36          {
37              for (uint256 i = 0; i < usersAddresses.length; i++) {
38                  isEligibleToUse[usersAddresses[i]] = true;
39              }
40              valueOracle = INoyaValueOracle(_valueOracle);
41              require(_valueOracle != address(0));
42          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


27          constructor(address swapHandler, address _lifi) Ownable2Step() Ownable(msg.sender) {
28              isHandler[swapHandler] = true;
29              lifi = _lifi;
30          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


29          constructor(PositionRegistry _registry) {
30              require(address(_registry) != address(0));
31              registry = _registry;
32          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


46          constructor(address _reg) {
47              require(_reg != address(0));
48              registry = PositionRegistry(_reg);
49          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


31          constructor(address _factory, PositionRegistry _registry) {
32              factory = _factory;
33              registry = _registry;
34          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## NC107 - Public state arrays should have a getter to return all elements:

In Solidity, public state variables automatically generate a getter function. For non-array types, this is straightforward: it simply returns the value. However, for arrays, the automatically generated getter only allows retrieval of an element at a specific index, not the entire array. This is mainly to prevent unintentional high gas costs, as returning the entire array can be expensive if it's large. If developers want to retrieve the whole array, they must explicitly define a function, as auto-generation could inadvertently expose contracts to gas-related vulnerabilities or lead to unwanted behavior for larger arrays.


```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


17          RouteData[] public routes;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

## NC108 - It is best practice to use linear inheritance:

In Solidity, complex inheritance structures can obfuscate code understanding, introducing potential security risks. Multiple inheritance, especially with overlapping function names or state variables, can cause unintentional overrides or ambiguous behavior. Resolution: Strive for linear and simple inheritance chains. Avoid diamond or circular inheritance patterns. Clearly document the purpose and relationships of base contracts, ensuring that overrides are intentional. Tools like Remix or Hardhat can visualize inheritance chains, assisting in verification. Keeping inheritance streamlined aids in better code readability, reduces potential errors, and ensures smoother audits and upgrades.


<details>
<summary>Click to show 11 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


16      contract AccountingManager is IAccountingManager, ERC4626, ReentrancyGuard, Pausable, NoyaGovernanceBase {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


12      contract PositionRegistry is AccessControl, IPositionRegistry, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


12      contract BalancerFlashLoan is IFlashLoanRecipient, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


7       contract LidoConnector is BaseConnector, ERC721Holder {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


29      contract MaverickConnector is BaseConnector, IERC721Receiver {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


7       contract SNXV3Connector is BaseConnector, IERC721Receiver {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


12      contract UNIv3Connector is BaseConnector, ERC721Holder {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


9       contract Keepers is EIP712, Ownable2Step {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


22      contract BaseConnector is NoyaGovernanceBase, IConnector, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


10      contract SwapAndBridgeHandler is NoyaGovernanceBase, ISwapAndBridgeHandler, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


10      contract LifiImplementation is ISwapAndBridgeImplementation, Ownable2Step, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

</details>

## NC109 - Use a struct to encapsulate multiple function parameters:

Using a struct to encapsulate multiple parameters in Solidity functions can significantly enhance code readability and maintainability. Instead of passing a long list of arguments, which can be error-prone and hard to manage, a struct allows grouping related data into a single, coherent entity. This approach simplifies function signatures and makes the code more organized. It also enhances code clarity, as developers can easily understand the relationship between the parameters. Moreover, it aids in future code modifications and expansions, as adding or modifying a parameter only requires changes in the struct definition, rather than in every function that uses these parameters.


<details>
<summary>Click to show 13 findings</summary>

```solidity
File: contracts/accountingManager/Registry.sol


106         function addVault(
107             uint256 vaultId,
108             address _accountingManager,
109             address _baseToken,
110             address _governer,
111             address _maintainer,
112             address _maintainerWithoutTimelock,
113             address _keeperContract,
114             address _watcher,
115             address _emergency,
116             address[] calldata _trustedTokens
117         ) external onlyRole(MAINTAINER_ROLE) {
158         function changeVaultAddresses(
159             uint256 vaultId,
160             address _governer,
161             address _maintainer,
162             address _maintainerWithoutTimelock,
163             address _keeperContract,
164             address _watcher,
165             address _emergency
166         ) external onlyVaultGoverner(vaultId) vaultExists(vaultId) {
238         function addTrustedPosition(
239             uint256 vaultId,
240             uint256 _positionTypeId,
241             address calculatorConnector,
242             bool onlyOwner,
243             bool _isDebt,
244             bytes calldata _data,
245             bytes calldata _additionalData
246         ) external onlyVaultMaintainerWithoutTimeLock(vaultId) vaultExists(vaultId) nonReentrant {
293         function updateHoldingPosition(
294             Vault storage vault,
295             uint256 vaultId,
296             bytes32 _positionId,
297             bytes calldata d,
298             bytes calldata AD,
299             uint256 index,
300             bytes32 holdingPositionId
301         ) internal returns (uint256) {
335         function updateHoldingPosition(
336             uint256 vaultId,
337             bytes32 _positionId,
338             bytes calldata _data,
339             bytes calldata additionalData,
340             bool removePosition
341         ) public vaultExists(vaultId) returns (uint256) {
370         function updateHoldingPostionWithTime(
371             uint256 vaultId,
372             bytes32 _positionId,
373             bytes calldata _data,
374             bytes calldata additionalData,
375             bool removePosition,
376             uint256 positionTimestamp
377         ) external vaultExists(vaultId) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


64          function openPosition(
65              bytes32 poolId,
66              uint256[] memory amounts,
67              uint256[] memory amountsWithoutBPT,
68              uint256 minBPT,
69              uint256 auraAmount
70          ) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


45          constructor(
46              address _convexBooster,
47              address cvx,
48              address crv,
49              address prisma,
50              BaseConnectorCP memory baseConnectorParams
51          ) BaseConnector(baseConnectorParams) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


62          function executeCommands(
63              address facade,
64              address creditAccount,
65              MultiCall[] calldata calls,
66              address approvalToken,
67              uint256 amount
68          ) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


20          constructor(address _lido, address _lidoW, address _steth, address w, BaseConnectorCP memory baseConnectorParams)
21              BaseConnector(baseConnectorParams)
22          {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


43          constructor(address _mav, address _veMav, address mr, address pi, BaseConnectorCP memory baseCP)
44              BaseConnector(baseCP)
45          {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


52          function openTrove(IStakeNTroveZap zap, address tm, uint256 maxFee, uint256 dAmount, uint256 bAmount)
53              public
54              onlyManager
55              nonReentrant
56          {
97          function adjustTrove(
98              IStakeNTroveZap zapContract,
99              address tm,
100             uint256 mFee,
101             uint256 wAmount,
102             uint256 bAmount,
103             bool isBorrowing
104         ) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


81          function delegateIntoApprovedPool(
82              uint256 poolIndex,
83              uint128 _accountId,
84              address collateralType,
85              uint256 newCollateralAmountD18,
86              uint256 leverage
87          ) public onlyManager {
102         function mintOrBurnSUSD(
103             uint256 _amount,
104             uint128 _accountId,
105             uint128 poolId,
106             address collateralType,
107             bool mintOrBurn
108         ) public onlyManager {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


52          function withdraw(address siloToken, address wToken, uint256 amount, bool oC, bool closePosition)
53              external
54              onlyManager
55              nonReentrant
56          {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


84          function execute(
85              address destination,
86              bytes calldata data,
87              uint256 gasLimit,
88              address executor,
89              bytes32[] memory sigR,
90              bytes32[] memory sigS,
91              uint8[] memory sigV,
92              uint256 deadline
93          ) public {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


204         function swapHoldings(
205             address[] memory tokensIn,
206             address[] memory tokensOut,
207             uint256[] memory amountsIn,
208             bytes[] memory swapData,
209             uint256[] memory routeIds
210         ) external onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


65          function _lzReceive(Origin calldata _origin, bytes32, bytes calldata _message, address, bytes calldata)
66              internal
67              override
68          {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


165         function _forward(IERC20 token, address from, uint256 amount, address caller, bytes calldata data, uint256 routeId)
166             internal
167             virtual
168             nonReentrant
169         {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

</details>

## NC110 - Avoid defining a function in a single line including it's contents:

  


<details>
<summary>Click to show 9 findings</summary>

```solidity
File: contracts/connectors/CompoundConnector.sol


17          constructor(BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


29          constructor(BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


17          constructor(BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


89          receive() external payable { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


56          receive() external payable { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


25          constructor(BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/governance/Watchers.sol


7           constructor(address[] memory _owners, uint8 _threshold) Keepers(_owners, _threshold) { }
8           function verifyRemoveLiquidity(uint256 withdrawAmount, uint256 sentAmount, bytes memory data) external view { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Watchers.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


31          constructor(address _endpoint, address _owner) OAppReceiver() OAppCore(_endpoint, _owner) { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


27          receive() external payable { }
29          constructor(address _endpoint, address _owner) OAppSender() OAppCore(_endpoint, _owner) { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

</details>

## NC111 - Empty bytes check is missing:

When developing smart contracts in Solidity, it's crucial to validate the inputs of your functions. This includes ensuring that the bytes parameters are not empty, especially when they represent crucial data such as addresses, identifiers, or raw data that the contract needs to process.Missing empty bytes checks can lead to unexpected behaviour in your contract.For instance, certain operations might fail, produce incorrect results, or consume unnecessary gas when performed with empty bytes.  Moreover, missing input validation can potentially expose your contract to malicious activity, including exploitation of unhandled edge cases.To mitigate these issues, always validate that bytes parameters are not empty when the logic of your contract requires it.


<details>
<summary>Click to show 21 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


150         function sendTokensToTrustedAddress(address token, uint256 amount, address _caller, bytes calldata _data)
257         function executeDeposit(uint256 maxI, address connector, bytes memory addLPdata)
649         function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


238         function addTrustedPosition(
239             uint256 vaultId,
240             uint256 _positionTypeId,
241             address calculatorConnector,
242             bool onlyOwner,
243             bool _isDebt,
244             bytes calldata _data,
245             bytes calldata _additionalData
246         ) external onlyVaultMaintainerWithoutTimeLock(vaultId) vaultExists(vaultId) nonReentrant {
293         function updateHoldingPosition(
294             Vault storage vault,
295             uint256 vaultId,
296             bytes32 _positionId,
297             bytes calldata d,
298             bytes calldata AD,
299             uint256 index,
300             bytes32 holdingPositionId
301         ) internal returns (uint256) {
335         function updateHoldingPosition(
336             uint256 vaultId,
337             bytes32 _positionId,
338             bytes calldata _data,
339             bytes calldata additionalData,
340             bool removePosition
341         ) public vaultExists(vaultId) returns (uint256) {
370         function updateHoldingPostionWithTime(
371             uint256 vaultId,
372             bytes32 _positionId,
373             bytes calldata _data,
374             bytes calldata additionalData,
375             bool removePosition,
376             uint256 positionTimestamp
377         ) external vaultExists(vaultId) {
394         function getHoldingPositionIndex(uint256 vaultId, bytes32 _positionId, address _connector, bytes memory data)
486         function calculatePositionId(address calculatorConnector, uint256 positionTypeId, bytes memory data)


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


117         function _getUnderlyingTokens(uint256 p, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


37          function makeFlashLoan(IERC20[] memory tokens, uint256[] memory amounts, bytes memory userData)
54          function receiveFlashLoan(
55              IERC20[] memory tokens,
56              uint256[] memory amounts,
57              uint256[] memory feeAmounts,
58              bytes memory userData
59          ) external override {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


99          function _getUnderlyingTokens(uint256 id, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


134         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


142         function _getUnderlyingTokens(uint256 p, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


161         function _getUnderlyingTokens(uint256 id, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


141         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


183         function swapExactPTForSY(IPMarket market, uint256 exactPTIn, bytes calldata swapData, uint256 minSY)
311         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


164         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


143         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


123         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


152         function _getUnderlyingTokens(uint256, bytes memory data) public pure override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


84          function execute(
85              address destination,
86              bytes calldata data,
87              uint256 gasLimit,
88              address executor,
89              bytes32[] memory sigR,
90              bytes32[] memory sigS,
91              uint8[] memory sigV,
92              uint256 deadline
93          ) public {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/governance/Watchers.sol


8           function verifyRemoveLiquidity(uint256 withdrawAmount, uint256 sentAmount, bytes memory data) external view { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Watchers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


84          function sendTokensToTrustedAddress(address token, uint256 amount, address caller, bytes memory data)
122         function transferPositionToAnotherConnector(
123             address[] memory tokens,
124             uint256[] memory amounts,
125             bytes memory data,
126             address connector
127         ) external onlyManager nonReentrant {
169         function addLiquidity(address[] memory tokens, uint256[] memory amounts, bytes memory data)
232         function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


27          function sendTokensToTrustedAddress(address token, uint256 amount, address caller, bytes memory data)
40          function addLiquidity(address[] memory tokens, uint256[] memory amounts, bytes memory data) external {
51          function updatePositionToRegistryUsingType(bytes32 _positionId, bytes memory data, bool remove) external {
59          function addPositionToRegistryUsingType(uint256 _positionType, bytes memory data) external {
65          function addPositionToRegistry(bytes memory data) external {
75          function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


65          function _lzReceive(Origin calldata _origin, bytes32, bytes calldata _message, address, bytes calldata)


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


36          function updateMessageSetting(bytes memory _messageSetting) public onlyOwner {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


165         function _forward(IERC20 token, address from, uint256 amount, address caller, bytes calldata data, uint256 routeId)


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

</details>

## NC112 - Defining All External/Public Functions in Contract Interfaces:

It is preferable to have all the external and public function in an interface to make using them easier by developers. This helps ensure the whole API is extracted in a interface.


<details>
<summary>Click to show 32 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


124         function updateValueOracle(INoyaValueOracle _valueOracle) public onlyMaintainer {
135         function setFeeReceivers(
136             address _withdrawFeeReceiver,
137             address _performanceFeeReceiver,
138             address _managementFeeReceiver
139         ) public onlyMaintainer {
170         function setFees(uint256 _withdrawFee, uint256 _performanceFee, uint256 _managementFee) public onlyMaintainer {
200         function deposit(address receiver, uint256 amount, address referrer) public nonReentrant whenNotPaused {
226         function calculateDepositShares(uint256 maxIterations) public onlyManager nonReentrant whenNotPaused {
257         function executeDeposit(uint256 maxI, address connector, bytes memory addLPdata)
304         function withdraw(uint256 share, address receiver) public nonReentrant whenNotPaused {
328         function calculateWithdrawShares(uint256 maxIterations) public onlyManager nonReentrant whenNotPaused {
360         function startCurrentWithdrawGroup() public onlyManager nonReentrant whenNotPaused {
370         function fulfillCurrentWithdrawGroup() public onlyManager nonReentrant whenNotPaused {
396         function executeWithdraw(uint256 maxIterations) public onlyManager nonReentrant whenNotPaused {
453         function resetMiddle(uint256 newMiddle, bool depositOrWithdraw) public onlyManager {
475         function recordProfitForFee() public onlyManager nonReentrant {
493         function checkIfTVLHasDroped() public nonReentrant {
505         function collectManagementFees() public onlyManager nonReentrant returns (uint256, uint256) {
526         function collectPerformanceFees() public onlyManager nonReentrant {
543         function burnShares(uint256 amount) public {
548         function retrieveTokensForWithdraw(RetrieveData[] calldata retrieveData) public onlyManager nonReentrant {
582         function getProfit() public view returns (uint256) {
591         function totalAssets() public view override returns (uint256) {
596         function getQueueItems(bool depositOrWithdraw, uint256[] memory items)
616         function neededAssetsForWithdraw() public view returns (uint256) {
627         function TVL() public view returns (uint256) {
632         function getPositionTVL(HoldingPI memory position, address base) public view returns (uint256) {
649         function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {
659         function emergencyStop() public whenNotPaused onlyEmergency {
663         function unpause() public whenPaused onlyEmergency {
667         function setDepositLimits(uint256 _depositLimitPerTransaction, uint256 _depositTotalAmount) public onlyMaintainer {
673         function changeDepositWaitingTime(uint256 _depositWaitingTime) public onlyMaintainer {
678         function changeWithdrawWaitingTime(uint256 _withdrawWaitingTime) public onlyMaintainer {
683         function rescue(address token, uint256 amount) public onlyEmergency nonReentrant {
693         function mint(uint256 shares, address receiver) public override returns (uint256) {
697         function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256) {
701         function redeem(uint256 shares, address receiver, address shareOwner) public override returns (uint256) {
705         function deposit(uint256 assets, address receiver) public override returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


224         function getPositionBP(uint256 vaultId, bytes32 _positionId) public view returns (PositionBP memory) {
335         function updateHoldingPosition(
336             uint256 vaultId,
337             bytes32 _positionId,
338             bytes calldata _data,
339             bytes calldata additionalData,
340             bool removePosition
341         ) public vaultExists(vaultId) returns (uint256) {
394         function getHoldingPositionIndex(uint256 vaultId, bytes32 _positionId, address _connector, bytes memory data)
408         function getHoldingPosition(uint256 vaultId, uint256 i) public view returns (HoldingPI memory) {
416         function getHoldingPositions(uint256 vaultId) public view returns (HoldingPI[] memory) {
426         function isPositionTrusted(uint256 vaultId, bytes32 _positionId) public view returns (bool) {
436         function isPositionTrustedForConnector(uint256 vaultId, bytes32 _positionId, address connector)
449         function getGovernanceAddresses(uint256 vaultId)
470         function isTokenTrusted(uint256 vaultId, address token, address connector) public view returns (bool) {
486         function calculatePositionId(address calculatorConnector, uint256 positionTypeId, bytes memory data)
499         function isAnActiveConnector(uint256 vaultId, address connectorAddress) public view returns (bool) {
508         function isPositionDebt(uint256 vaultId, bytes32 _positionId) public view returns (bool) {
516         function getVaultAddresses(uint256 vaultId) public view returns (address, address) {
525         function isAddressTrusted(uint256 vaultId, address addr) public view returns (bool) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


114         function _getPositionTVL(HoldingPI memory, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


53          function supply(DepositData memory data) public onlyManager nonReentrant {
79          function withdraw(WithdrawData memory data) public onlyManager nonReentrant {
100         function stake(address pool, uint256 liquidity) public onlyManager nonReentrant {
106         function unstake(address pool, uint256 liquidity) public onlyManager nonReentrant {
111         function claim(address pool) public onlyManager nonReentrant {
117         function _getUnderlyingTokens(uint256 p, bytes memory data) public view override returns (address[] memory) {
125         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


53          function harvestAuraRewards(address[] calldata rewardsPools) public onlyManager nonReentrant {
64          function openPosition(
65              bytes32 poolId,
66              uint256[] memory amounts,
67              uint256[] memory amountsWithoutBPT,
68              uint256 minBPT,
69              uint256 auraAmount
70          ) public onlyManager nonReentrant {
109         function depositIntoAuraBooster(bytes32 poolId, uint256 _amount) public onlyManager nonReentrant {
115         function decreasePosition(DecreasePositionParams memory p) public onlyManager nonReentrant {
162         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {
175         function totalLpBalanceOf(PoolInfo memory pool) public view returns (uint256) {
184         function totalLpBalanceOf(bytes32 poolId) public view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


88          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
99          function _getUnderlyingTokens(uint256 id, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


74          function getAccountHealthFactor(IComet comet) public view returns (uint256) {
84          function getBorrowBalanceInBase(IComet comet) public view returns (uint256 borrowBalanceInVirtualBase) {
95          function getCollBlanace(IComet comet, bool riskAdjusted) public view returns (uint256 CollValue) {
125         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {
134         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {
141         function isInAsset(uint16 assetsIn, uint8 assetOffset) public pure returns (bool) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


68          function depositIntoGauge(address pool, uint256 amount) public onlyManager nonReentrant {
81          function depositIntoPrisma(address pool, uint256 amount, bool curveOrConvex) public onlyManager nonReentrant {
103         function depositIntoConvexBooster(address pool, uint256 pid, uint256 amount, bool stake) public onlyManager {
117         function openCurvePosition(address pool, uint256 depositIndex, uint256 amount, uint256 minAmount)
160         function decreaseCurvePosition(address pool, uint256 withdrawIndex, uint256 amount, uint256 minAmount)
182         function withdrawFromConvexBooster(uint256 pid, uint256 amount) public onlyManager {
192         function withdrawFromConvexRewardPool(address pool, uint256 amount) public onlyManager {
202         function withdrawFromGauge(address pool, uint256 amount) public onlyManager {
212         function withdrawFromPrisma(address depostiToken, uint256 amount) public onlyManager {
221         function harvestRewards(address[] calldata gauges) public onlyManager nonReentrant {
233         function harvestPrismaRewards(address[] calldata pools) public onlyManager nonReentrant {
247         function harvestConvexRewards(address[] calldata rewardsPools) public onlyManager nonReentrant {
265         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
279         function LPToUnder(PoolInfo memory info, uint256 balance) public view returns (uint256, address) {
297         function estimateWithdrawAmount(ICurveSwap curvePool, uint256 amount, uint256 index)
311         function totalLpBalanceOf(PoolInfo memory info) public view returns (uint256) {
325         function balanceOfConvexRewardPool(PoolInfo memory info) public view returns (uint256) {
335         function balanceOfLPToken(PoolInfo memory info) public view returns (uint256) {
344         function balanceOfRewardPool(PoolInfo memory info) public view returns (uint256) {
354         function balanceOfPrisma(address prismaPool) public view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


30          function deposit(uint256 marketId, uint256 _amount) public onlyManager nonReentrant {
43          function withdraw(uint256 marketId, uint256 _amount) public onlyManager nonReentrant {
58          function openBorrowPosition(uint256 marketId, uint256 _amountWei, uint256 accountId)
77          function transferBetweenAccounts(uint256 accountId, uint256 marketId, uint256 _amountWei, bool borrowOrRepay)
98          function closeBorrowPosition(uint256[] memory marketIds, uint256 accountId) public onlyManager nonReentrant {
106         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


68          function withdraw(IFraxPair pool, uint256 withdrawAmount) public onlyManager nonReentrant {
87          function repay(IFraxPair pool, uint256 sharesToRepay) public onlyManager nonReentrant {
104         function verifyHealthFactor(IFraxPair pool) public view {
142         function _getUnderlyingTokens(uint256 p, bytes memory data) public view override returns (address[] memory) {
150         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


24          function openAccount(address facade, uint256 ref) public onlyManager {
41          function closeAccount(address facade, address creditAccount) public onlyManager nonReentrant {
62          function executeCommands(
63              address facade,
64              address creditAccount,
65              MultiCall[] calldata calls,
66              address approvalToken,
67              uint256 amount
68          ) public onlyManager nonReentrant {
93          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


51          function requestWithdrawals(uint256 amount) public onlyManager nonReentrant {
69          function claimWithdrawal(uint256 requestId) public onlyManager nonReentrant {
91          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


149         function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {
153         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
161         function _getUnderlyingTokens(uint256 id, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


95          function repay(uint256 amount, Id id) public onlyManager nonReentrant {
108         function getHealthFactor(Id _id, Market memory _market) public view returns (uint256) {
118         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
137         function convertCToL(uint256 amount, address marketOracle, address collateral) public view returns (uint256) {
141         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


40          function updatePosition(uint256 tokenId) public onlyManager nonReentrant {
50          function withdraw(uint256 tokenId) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


126         function depositIntoPenpie(address _market, uint256 _amount) public onlyManager nonReentrant {
137         function withdrawFromPenpie(address _market, uint256 _amount) public onlyManager nonReentrant {
166         function swapYTForSY(address market, uint256 exactYTIn, uint256 min, LimitOrderData memory orderData)
257         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
293         function getYTValue(address market, uint256 balance) public view returns (uint256) {
303         function isMarketEmpty(IPMarket market) public view returns (bool) {
311         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


33          function approveZap(IStakeNTroveZap zap, address tm, bool approve) public onlyManager nonReentrant {
52          function openTrove(IStakeNTroveZap zap, address tm, uint256 maxFee, uint256 dAmount, uint256 bAmount)
75          function addColl(IStakeNTroveZap zapContract, address tm, uint256 amountIn) public onlyManager nonReentrant {
97          function adjustTrove(
98              IStakeNTroveZap zapContract,
99              address tm,
100             uint256 mFee,
101             uint256 wAmount,
102             uint256 bAmount,
103             bool isBorrowing
104         ) public onlyManager nonReentrant {
129         function closeTrove(IStakeNTroveZap zapContract, address troveManager) public onlyManager nonReentrant {
145         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
164         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


25          function createAccount() public onlyManager {
30          function deposit(address _token, uint256 _amount, uint128 _accountId) public onlyManager {
46          function withdraw(address _token, uint256 _amount, uint128 _accountId) public onlyManager {
68          function delegateIntoPreferredPool(
69              uint128 _accountId,
70              address collateralType,
71              uint256 newCollateralAmountD18,
72              uint256 leverage
73          ) public onlyManager {
81          function delegateIntoApprovedPool(
82              uint256 poolIndex,
83              uint128 _accountId,
84              address collateralType,
85              uint256 newCollateralAmountD18,
86              uint256 leverage
87          ) public onlyManager {
94          function claimRewards(uint128 accountId, uint128 poolId, address collateralType, address distributor)
102         function mintOrBurnSUSD(
103             uint256 _amount,
104             uint128 _accountId,
105             uint128 poolId,
106             address collateralType,
107             bool mintOrBurn
108         ) public onlyManager {
121         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


71          function getData(address siloToken)
109         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
130         function isSiloEmpty(ISilo silo) public view returns (bool) {
143         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


110         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
123         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


101         function collectAllFees(uint256[] memory tokenIds) public onlyManager nonReentrant {
116         function getCurrentLiquidity(uint256 tokenId) public view returns (uint128, address, address) {
127         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
152         function _getUnderlyingTokens(uint256, bytes memory data) public pure override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


42          function updateOwners(address[] memory _owners, bool[] memory addOrRemove) public onlyOwner {
63          function setThreshold(uint8 _threshold) public onlyOwner {
84          function execute(
85              address destination,
86              bytes calldata data,
87              uint256 gasLimit,
88              address executor,
89              bytes32[] memory sigR,
90              bytes32[] memory sigS,
91              uint8[] memory sigV,
92              uint256 deadline
93          ) public {
124         function domainSeparatorV4() public view returns (bytes32) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


153         function updateTokenInRegistry(address token) public onlyManager {
232         function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {
249         function getPositionTVL(HoldingPI memory p, address baseToken) public view returns (uint256) {
263         function _getUnderlyingTokens(uint256, bytes memory) public view virtual returns (address[] memory) {
271         function _getPositionTVL(HoldingPI memory, address) public view virtual returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


40          function setChainInfo(uint256 chainId, uint32 lzChainId, address lzHelperAddress) public onlyOwner {
52          function addVaultInfo(uint256 vaultId, uint256 baseChainId, address omniChainManager) public onlyOwner {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


36          function updateMessageSetting(bytes memory _messageSetting) public onlyOwner {
51          function setChainInfo(uint256 chainId, uint32 lzChainId, address lzHelperAddress) public onlyOwner {
63          function addVaultInfo(uint256 vaultId, uint256 baseChainId, address omniChainManager) public onlyOwner {
75          function updateTVL(uint256 vaultId, uint256 tvl, uint256 updateTime) public {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


51          function _getPositionTVL(HoldingPI memory position, address) public view override returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol


19          function getTVL() public view returns (uint256) {
33          function _getPositionTVL(HoldingPI memory position, address base) public view override returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


147         function addRoutes(RouteData[] memory _routes) public onlyMaintainer {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


110         function verifySwapData(SwapRequest calldata _request) public view override returns (bool) {
150         function verifyBridgeData(BridgeRequest calldata _request) public view override returns (bool) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


37          function updateDefaultPriceSource(address[] calldata baseCurrencies, INoyaValueOracle[] calldata oracles)
71          function getValue(address asset, address baseToken, uint256 amount) public view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


89          function getValue(address asset, address baseToken, uint256 amount) public view returns (uint256) {
115         function getValueFromChainlinkFeed(
116             AggregatorV3Interface source,
117             uint256 amountIn,
118             uint256 sourceTokenUnit,
119             bool isInverse
120         ) public view returns (uint256) {
138         function getTokenDecimals(address token) public view returns (uint256) {
143         function getSourceOfAsset(address asset, address baseToken) public view returns (address source, bool isInverse) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


60          function getValue(address tokenIn, address baseToken, uint256 amount) public view returns (uint256 _amountOut) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## NC113 - Avoid mutating function parameters:

Function parameters in Solidity are passed by value, meaning they are essentially local copies. Mutating them can lead to confusion and errors because the changes don't persist outside the function. By keeping function parameters immutable, you ensure clarity in code behavior, preventing unintended side-effects. If you need to modify a value based on a parameter, use a local variable inside the function, leaving the original parameter unaltered. By adhering to this practice, you maintain a clear distinction between input data and the internal processing logic, improving code readability and reducing the potential for bugs.


```solidity
File: contracts/helpers/BaseConnector.sol


97                  amount = newAmount;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

## G001 - Don't Initialize Variables with Default Value:

  


<details>
<summary>Click to show 58 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


uint64 i = 0;

uint64 i = 0;

uint256 processedBaseTokenAmount = 0;

uint64 i = 0;

uint256 processedShares = 0;

uint256 assetsNeededForWithdraw = 0;

uint64 i = 0;

uint256 withdrawFeeAmount = 0;

uint256 processedBaseTokenAmount = 0;

uint256 amountAskedForWithdraw_temp = 0;

for (uint256 i = 0; i < retrieveData.length; i++) {

for (uint256 i = 0; i < items.length; i++) {

for (uint256 i = 0; i < items.length; i++) {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L608:608

```solidity
File: contracts/accountingManager/Registry.sol


for (uint256 i = 0; i < _trustedTokens.length; i++) {

for (uint256 i = 0; i < _connectorAddresses.length; i++) {

for (uint256 i = 0; i < _tokens.length; i++) {

for (uint256 i = 0; i < usingTokens.length; i++) {

for (uint256 i = 0; i < length; i++) {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L274:274

```solidity
File: contracts/connectors/BalancerConnector.sol


for (uint256 i = 0; i < rewardsPools.length; i++) {

for (uint256 i = 0; i < tokens.length; i++) {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L77:77

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


for (uint256 i = 0; i < tokens.length; i++) {

for (uint256 i = 0; i < destinationConnector.length; i++) {

for (uint256 i = 0; i < tokens.length; i++) {

for (uint256 i = 0; i < tokens.length; i++) {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L89:89

```solidity
File: contracts/connectors/CurveConnector.sol


for (uint256 i = 0; i < gauges.length; i++) {

for (uint256 i = 0; i < pools.length; i++) {

for (uint256 i = 0; i < rewardsPools.length; i++) {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L248:248

```solidity
File: contracts/connectors/Dolomite.sol


uint256 totalDebt = 0;

uint256 totalCollateral = 0;

for (uint256 i = 0; i < markets.length; i++) {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L113:113

```solidity
File: contracts/connectors/GearBoxV3.sol


for (uint256 i = 0; i < calls.length; i++) {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L69:69

```solidity
File: contracts/connectors/MaverickConnector.sol


for (uint256 i = 0; i < earnedInfo.length; i++) {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L140:140

```solidity
File: contracts/connectors/PendleConnector.sol


for (uint256 i = 0; i < rewardTokens.length; i++) {

uint256 underlyingBalance = 0;

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L260:260

```solidity
File: contracts/connectors/SiloConnector.sol


uint256 totalDepositAmount = 0;

uint256 totalBAmount = 0;

for (uint256 i = 0; i < assets.length; i++) {

for (uint256 i = 0; i < assetsS.length; i++) {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L132:132

```solidity
File: contracts/connectors/UNIv3Connector.sol


for (uint256 i = 0; i < tokenIds.length; i++) {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L102:102

```solidity
File: contracts/governance/Keepers.sol


for (uint256 i = 0; i < _owners.length; i++) {

for (uint256 i = 0; i < _owners.length; i++) {

for (uint256 i = 0; i < threshold;) {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L104:104

```solidity
File: contracts/helpers/BaseConnector.sol


for (uint256 i = 0; i < tokens.length; i++) {

for (uint256 i = 0; i < tokens.length; i++) {

for (uint256 i = 0; i < tokensIn.length; i++) {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L211:211

```solidity
File: contracts/helpers/ConnectorMock2.sol


uint256 public vaultId = 0;

for (uint256 i = 0; i < tokens.length; i++) {

for (uint256 i = 0; i < tokens.length; i++) {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L46:46

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


for (uint256 i = 0; i < usersAddresses.length; i++) {

for (uint256 i = 0; i < _routes.length;) {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L148:148

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


uint256 balanceOut0 = 0;

uint256 balanceOut1 = 0;

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L92:92

```solidity
File: contracts/helpers/TVLHelper.sol


for (uint256 i = 0; i < positions.length; i++) {

for (uint256 i = 0; i < positions.length; i++) {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/TVLHelper.sol#L44:44

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


for (uint256 i = 0; i < baseCurrencies.length; i++) {

for (uint256 i = 0; i < oracle.length; i++) {

for (uint256 i = 0; i < sources.length; i++) {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L88:88

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


for (uint256 i = 0; i < assets.length; i++) {

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L74:74

</details>

## G002 - Cache Array Length Outside of Loop:

If not cached, the solidity compiler will always read the length of the array during each iteration. That is, if it is a storage array, this is an extra sload operation (100 additional extra gas for each iteration except for the first) and if it is a memory array, this is an extra mload operation (3 additional gas for each iteration except for the first).


<details>
<summary>Click to show 18 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


551             for (uint256 i = 0; i < retrieveData.length; i++) {
603                 for (uint256 i = 0; i < items.length; i++) {
608                 for (uint256 i = 0; i < items.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


138             for (uint256 i = 0; i < _trustedTokens.length; i++) {
194             for (uint256 i = 0; i < _connectorAddresses.length; i++) {
214             for (uint256 i = 0; i < _tokens.length; i++) {
253                 for (uint256 i = 0; i < usingTokens.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


54              for (uint256 i = 0; i < rewardsPools.length; i++) {
77              for (uint256 i = 0; i < tokens.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


74                  for (uint256 i = 0; i < tokens.length; i++) {
79                  for (uint256 i = 0; i < destinationConnector.length; i++) {
84                  for (uint256 i = 0; i < tokens.length; i++) {
89              for (uint256 i = 0; i < tokens.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


222             for (uint256 i = 0; i < gauges.length; i++) {
234             for (uint256 i = 0; i < pools.length; i++) {
248             for (uint256 i = 0; i < rewardsPools.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


113             for (uint256 i = 0; i < markets.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


69              for (uint256 i = 0; i < calls.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


140             for (uint256 i = 0; i < earnedInfo.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


244             for (uint256 i = 0; i < rewardTokens.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


116             for (uint256 i = 0; i < assets.length; i++) {
132             for (uint256 i = 0; i < assetsS.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


102             for (uint256 i = 0; i < tokenIds.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


29              for (uint256 i = 0; i < _owners.length; i++) {
44              for (uint256 i = 0; i < _owners.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


178             for (uint256 i = 0; i < tokens.length; i++) {
189             for (uint256 i = 0; i < tokens.length; i++) {
211             for (uint256 i = 0; i < tokensIn.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


41              for (uint256 i = 0; i < tokens.length; i++) {
46              for (uint256 i = 0; i < tokens.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


37              for (uint256 i = 0; i < usersAddresses.length; i++) {
148             for (uint256 i = 0; i < _routes.length;) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/TVLHelper.sol


18              for (uint256 i = 0; i < positions.length; i++) {
44              for (uint256 i = 0; i < positions.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/TVLHelper.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


41              for (uint256 i = 0; i < baseCurrencies.length; i++) {
55              for (uint256 i = 0; i < oracle.length; i++) {
88              for (uint256 i = 0; i < sources.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


74              for (uint256 i = 0; i < assets.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

</details>

## G003 - Use != 0 instead of > 0 for Unsigned Integer Comparison:

Checking for `!= 0` is cheaper than `> 0` for unsigned integers.


<details>
<summary>Click to show 8 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


288             if (registry.isAnActiveConnector(vaultId, connector) && processedBaseTokenAmount > 0) {
438             if (withdrawFeeAmount > 0) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


99              if (auraAmount > 0) {
116             if (p._auraAmount > 0) {
122             if (p._lpAmount > 0) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


46              if (collateralAmount > 0) {
49              if (borrowAmount > 0) {
52              } else if (collateralAmount > 0) {
55              if (collateralAmount > 0) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


270                 if (lpBalance > 0) {
275                 if (PTAmount > 0) SYAmount += PTAmount * IPMarket(market).getPtToAssetRate(10) / 1e18;
278                 if (YTBalance > 0) SYAmount += getYTValue(market, YTBalance);
280                 if (SYAmount > 0) underlyingBalance += SYAmount * _SY.exchangeRate() / 1e18;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


111             if (bAmount > 0 && !isBorrowing) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


52              if (depositRequest.routerAmount > 0) {
57              if (depositRequest.LPStakingAmount > 0) {
79              if (withdrawRequest.LPStakingAmount > 0) {
82              if (withdrawRequest.routerAmount > 0) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


142             if ((positionIndex == 0 && !remove) || (positionIndex > 0 && remove)) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


86              if ((positionIndex == 0 && !remove) || (positionIndex > 0 && remove)) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

</details>

## G004 - Using `private` rather than `public` for constants, saves gas:

If needed, the values can be read from the verified contract source code, or if there are multiple values there can be a single getter function that [returns a tuple](https://github.com/code-423n4/2022-08-frax/blob/90f55a9ce4e25bceed3a74290b854341d8de6afa/src/contracts/FraxlendPair.sol#L156-L178) of the values of all currently-public constants. Saves **3406-3606 gas** in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table


<details>
<summary>Click to show 29 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


uint256 public constant FEE_PRECISION = 1e6;

uint256 public constant WITHDRAWAL_MAX_FEE = 5e4;

uint256 public constant MANAGEMENT_MAX_FEE = 5e5;

uint256 public constant PERFORMANCE_MAX_FEE = 1e5;

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L55:55

```solidity
File: contracts/accountingManager/Registry.sol


bytes32 public constant MAINTAINER_ROLE = keccak256("MAINTAINER_ROLE");

bytes32 public constant GOVERNER_ROLE = keccak256("GOVERNER_ROLE");

bytes32 public constant EMERGENCY_ROLE = keccak256("EMERGENCY_ROLE");

uint256 public constant MAX_NUM_HOLDING_POSITIONS = 40;

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L21:21

```solidity
File: contracts/connectors/AaveConnector.sol


uint256 public constant AAVE_POSITION_ID = 1;

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L24:24

```solidity
File: contracts/connectors/AerodromeConnector.sol


uint256 public constant AERODROME_POSITION_TYPE = 1;

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L31:31

```solidity
File: contracts/connectors/CamelotConnector.sol


uint256 public constant CAMELOT_POSITION_ID = 1;

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L34:34

```solidity
File: contracts/connectors/CurveConnector.sol


uint256 public constant CURVE_LP_POSITION = 4;

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L31:31

```solidity
File: contracts/connectors/Dolomite.sol


uint256 public constant DOL_POSITION_ID = 1;

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L16:16

```solidity
File: contracts/connectors/GearBoxV3.sol


uint256 public constant GEARBOX_POSITION_ID = 3;

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L9:9

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


uint256 public constant MORPHO_POSITION_ID = 1;

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L15:15

```solidity
File: contracts/connectors/PendleConnector.sol


uint256 public constant PENDLE_POSITION_ID = 11;

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L26:26

```solidity
File: contracts/connectors/PrismaConnector.sol


uint256 public constant PRISMA_POSITION_ID = 10;

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L14:14

```solidity
File: contracts/connectors/SNXConnector.sol


uint256 public constant SNX_POSITION_ID = 1;

uint256 public constant SNX_POOL_POSITION_ID = 2;

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L17:17

```solidity
File: contracts/connectors/SiloConnector.sol


uint256 public constant SILO_LP_ID = 11;

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L10:10

```solidity
File: contracts/connectors/StargateConnector.sol


uint256 public constant STARGATE_LP_POSITION_TYPE = 1;

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L26:26

```solidity
File: contracts/connectors/UNIv3Connector.sol


uint256 public constant UNI_LP_POSITION_TYPE = 5;

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L19:19

```solidity
File: contracts/governance/Keepers.sol


bytes32 public constant TXTYPE_HASH = keccak256(

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L11:11

```solidity
File: contracts/helpers/ConnectorMock2.sol


uint256 public constant positionType = 1;

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L20:20

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


uint256 public constant BRIDGE_TXN_WAITING_TIME = 30 minutes;

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L19:19

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


uint256 public constant OMNICHAIN_POSITION_ID = 13;

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L11:11

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


bytes4 public constant LI_FI_GENERIC_SWAP_SELECTOR = 0x4630a0d8;

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L18:18

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


address public constant ETH = address(0);

address public constant USD = address(840);

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L26:26

</details>

## G005 - Long Revert Strings:

  


<details>
<summary>Click to show 5 findings</summary>

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


require(success, "BalancerFlashLoan: Flash loan failed");

require(tokens[i].balanceOf(address(this)) == 0, "BalancerFlashLoan: Flash loan extra tokens");

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L92:92

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


require(isEligibleToUse[msg.sender], "NoyaSwapHandler: Not eligible to use");

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L25:25

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


require(isHandler[msg.sender] == true, "LifiImplementation: INVALID_SENDER");

require(verifySwapData(_request), "LifiImplementation: INVALID_SWAP_DATA");

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L84:84

</details>

## G006 - Use Custom Errors:

Instead of using error strings, to reduce deployment and runtime cost, you should use Custom Errors. This would save both deployment and runtime cost.

Source: https://consensys.net/diligence/blog/2019/09/stop-using-string-error-messages/


<details>
<summary>Click to show 27 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


106             require(p._baseTokenAddress != address(0));
107             require(p._valueOracle != address(0));
108             require(p._withdrawFeeReceiver != address(0));
109             require(p._performanceFeeReceiver != address(0));
110             require(p._managementFeeReceiver != address(0));
125             require(address(_valueOracle) != address(0));
140             require(_withdrawFeeReceiver != address(0));
141             require(_performanceFeeReceiver != address(0));
142             require(_managementFeeReceiver != address(0));
361             require(currentWithdrawGroup.isStarted == false && currentWithdrawGroup.isFullfilled == false);
371             require(currentWithdrawGroup.isStarted == true && currentWithdrawGroup.isFullfilled == false);
686                 require(success, "Transfer failed.");
694             revert NoyaAccounting_NOT_ALLOWED();
698             revert NoyaAccounting_NOT_ALLOWED();
702             revert NoyaAccounting_NOT_ALLOWED();
706             revert NoyaAccounting_NOT_ALLOWED();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


15              require(_accountingManager != address(0));
16              require(_baseToken != address(0));
17              require(_receiver != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


67              require(_governer != address(0));
68              require(_maintainer != address(0));
69              require(_emergency != address(0));
80              require(_maxNumHoldingPositions <= MAX_NUM_HOLDING_POSITIONS);
120             require(_governer != address(0));
121             require(_accountingManager != address(0));
122             require(_baseToken != address(0));
123             require(_maintainer != address(0));
124             require(_keeperContract != address(0));
125             require(_watcher != address(0));
167             require(_governer != address(0));
168             require(_maintainer != address(0));
169             require(_keeperContract != address(0));
170             require(_watcher != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


36              require(_pool != address(0));
37              require(_poolBaseToken != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


43              require(_router != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


45              require(_balancerVault != address(0));
46              require(bal != address(0));
47              require(aura != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


25              require(_balancerVault != address(0));
26              require(address(_registry) != address(0));
61              require(msg.sender == address(vault));
82                      require(success, "BalancerFlashLoan: Flash loan failed");
92                  require(tokens[i].balanceOf(address(this)) == 0, "BalancerFlashLoan: Flash loan extra tokens");


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


37              require(_router != address(0));
38              require(_factory != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


52              require(_convexBooster != address(0));
53              require(cvx != address(0));
54              require(crv != address(0));
55              require(prisma != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


24              require(_depositWithdrawalProxy != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


23              require(_lido != address(0));
24              require(_lidoW != address(0));
25              require(_steth != address(0));
26              require(w != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


46              require(_mav != address(0));
47              require(_veMav != address(0));
48              require(mr != address(0));
49              require(pi != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


24              require(MB != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


22              require(MC != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


60              require(_pendleMarketDepositHelper != address(0));
61              require(_pendleRouter != address(0));
62              require(SR != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


21              require(_SNXCoreProxy != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


18              require(SR != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


36              require(lpStacking != address(0));
37              require(_stargateRouter != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


28              require(_owners.length <= 10 && _threshold <= _owners.length && _threshold > 1);
53              require(numOwnersTemp <= 10 && threshold <= numOwnersTemp && threshold > 1);
64              require(_threshold <= numOwners && _threshold > 1);
94              require(isOwner[msg.sender], "Not an owner");
95              require(sigR.length == threshold, "Not enough signatures");
96              require(sigR.length == sigS.length && sigR.length == sigV.length, "Lengths do not match");
97              require(executor == msg.sender, "Invalid executor");
98              require(block.timestamp <= deadline, "Transaction expired");
106                     require(recovered > lastAdd && isOwner[recovered]);
117             require(success, "Transaction execution reverted.");


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/governance/NoyaGovernanceBase.sol


22              require(address(_registry) != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


41              require(lzHelperAddress != address(0));
53              require(omniChainManager != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


52              require(lzHelperAddress != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


25              require(isEligibleToUse[msg.sender], "NoyaSwapHandler: Not eligible to use");
41              require(_valueOracle != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


35              require(isHandler[msg.sender] == true, "LifiImplementation: INVALID_SENDER");
84              require(verifySwapData(_request), "LifiImplementation: INVALID_SWAP_DATA");
196                 require(success, "Transfer failed.");


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


30              require(address(_registry) != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


47              require(_reg != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


50              require(pool != address(0), "pool doesn't exist");


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## G007 - ++i costs less gas than i++, especially when it's used in for-loops (--i/i-- too):

Using ++i or --i instead of i++ or i-- can save gas, especially in for-loops.


<details>
<summary>Click to show 18 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


551             for (uint256 i = 0; i < retrieveData.length; i++) {
603                 for (uint256 i = 0; i < items.length; i++) {
608                 for (uint256 i = 0; i < items.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


138             for (uint256 i = 0; i < _trustedTokens.length; i++) {
194             for (uint256 i = 0; i < _connectorAddresses.length; i++) {
214             for (uint256 i = 0; i < _tokens.length; i++) {
253                 for (uint256 i = 0; i < usingTokens.length; i++) {
274             for (uint256 i = 0; i < length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


54              for (uint256 i = 0; i < rewardsPools.length; i++) {
77              for (uint256 i = 0; i < tokens.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


74                  for (uint256 i = 0; i < tokens.length; i++) {
79                  for (uint256 i = 0; i < destinationConnector.length; i++) {
84                  for (uint256 i = 0; i < tokens.length; i++) {
89              for (uint256 i = 0; i < tokens.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


222             for (uint256 i = 0; i < gauges.length; i++) {
234             for (uint256 i = 0; i < pools.length; i++) {
248             for (uint256 i = 0; i < rewardsPools.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


113             for (uint256 i = 0; i < markets.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


69              for (uint256 i = 0; i < calls.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


140             for (uint256 i = 0; i < earnedInfo.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


244             for (uint256 i = 0; i < rewardTokens.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


116             for (uint256 i = 0; i < assets.length; i++) {
132             for (uint256 i = 0; i < assetsS.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


102             for (uint256 i = 0; i < tokenIds.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


29              for (uint256 i = 0; i < _owners.length; i++) {
44              for (uint256 i = 0; i < _owners.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


178             for (uint256 i = 0; i < tokens.length; i++) {
189             for (uint256 i = 0; i < tokens.length; i++) {
211             for (uint256 i = 0; i < tokensIn.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


41              for (uint256 i = 0; i < tokens.length; i++) {
46              for (uint256 i = 0; i < tokens.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


37              for (uint256 i = 0; i < usersAddresses.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/TVLHelper.sol


18              for (uint256 i = 0; i < positions.length; i++) {
44              for (uint256 i = 0; i < positions.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/TVLHelper.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


41              for (uint256 i = 0; i < baseCurrencies.length; i++) {
55              for (uint256 i = 0; i < oracle.length; i++) {
88              for (uint256 i = 0; i < sources.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


74              for (uint256 i = 0; i < assets.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

</details>

## G008 - Use assembly to check for `address(0)`:

*Saves 6 gas per instance*


<details>
<summary>Click to show 29 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


106             require(p._baseTokenAddress != address(0));
107             require(p._valueOracle != address(0));
108             require(p._withdrawFeeReceiver != address(0));
109             require(p._performanceFeeReceiver != address(0));
110             require(p._managementFeeReceiver != address(0));
125             require(address(_valueOracle) != address(0));
140             require(_withdrawFeeReceiver != address(0));
141             require(_performanceFeeReceiver != address(0));
142             require(_managementFeeReceiver != address(0));
186             if (!(from == address(0)) && balanceOf(from) < amount + withdrawRequestsByAddress[from]) {
684             if (token == address(0)) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


15              require(_accountingManager != address(0));
16              require(_baseToken != address(0));
17              require(_receiver != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


54              if (vaults[_vaultId].accountManager == address(0)) revert NotExist();
67              require(_governer != address(0));
68              require(_maintainer != address(0));
69              require(_emergency != address(0));
118             if (vaults[vaultId].accountManager != address(0)) revert AlreadyExists();
120             require(_governer != address(0));
121             require(_accountingManager != address(0));
122             require(_baseToken != address(0));
123             require(_maintainer != address(0));
124             require(_keeperContract != address(0));
125             require(_watcher != address(0));
167             require(_governer != address(0));
168             require(_maintainer != address(0));
169             require(_keeperContract != address(0));
170             require(_watcher != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


36              require(_pool != address(0));
37              require(_poolBaseToken != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


43              require(_router != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


45              require(_balancerVault != address(0));
46              require(bal != address(0));
47              require(aura != address(0));
177             if (pool.auraPoolAddress != address(0)) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


25              require(_balancerVault != address(0));
26              require(address(_registry) != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


37              require(_router != address(0));
38              require(_factory != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


52              require(_convexBooster != address(0));
53              require(cvx != address(0));
54              require(crv != address(0));
55              require(prisma != address(0));
126             address poolAddress = (poolInfo.tokens.length > 2 && poolInfo.zap != address(0)) ? poolInfo.zap : pool;
283             if (info.poolAddressIfDefaultWithdrawTokenIsAnotherPosition != address(0)) {
326             if (info.convexRewardPool == address(0)) return 0;
345             if (info.gauge == address(0)) return 0;
355             if (prismaPool == address(0)) return 0;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


24              require(_depositWithdrawalProxy != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


78              if (approvalToken != address(0)) {
82              if (approvalToken != address(0)) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


23              require(_lido != address(0));
24              require(_lidoW != address(0));
25              require(_steth != address(0));
26              require(w != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


46              require(_mav != address(0));
47              require(_veMav != address(0));
48              require(mr != address(0));
49              require(pi != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


24              require(MB != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


22              require(MC != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


60              require(_pendleMarketDepositHelper != address(0));
61              require(_pendleRouter != address(0));
62              require(SR != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


21              require(_SNXCoreProxy != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


18              require(SR != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


36              require(lpStacking != address(0));
37              require(_stargateRouter != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/governance/NoyaGovernanceBase.sol


22              require(address(_registry) != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


41              require(lzHelperAddress != address(0));
53              require(omniChainManager != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


52              require(lzHelperAddress != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


37              require(_lzHelper != address(0));
47              require(destinationAddress != address(0));
76                  destChainAddress[bridgeRequest.destChainId] == address(0)


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


30              if (routes[_routeId].route == address(0) && !routes[_routeId].isEnabled) revert RouteNotFound();
41              require(_valueOracle != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


86              if (_request.outputToken == address(0)) {
93              if (_request.outputToken == address(0)) {
190             return address(token) == address(0);
194             if (token == address(0)) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/TVLHelper.sol


19                  if (positions[i].calculatorConnector == address(0)) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/TVLHelper.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


30              require(address(_registry) != address(0));
97              if (address(oracle) == address(0)) {
100             if (address(oracle) == address(0)) {
103             if (address(oracle) == address(0)) {
106             if (address(oracle) == address(0)) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


47              require(_reg != address(0));
95              if (primarySource == address(0)) {
144             if (assetsSources[asset][baseToken] != address(0)) {
146             } else if (assetsSources[baseToken][asset] != address(0)) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


50              require(pool != address(0), "pool doesn't exist");
63              if (pool == address(0)) {
66              if (pool == address(0)) revert INoyaOracle_ValueOracleUnavailable(tokenIn, baseToken);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## G009 - `internal` functions not called by the contract should be removed to save deployment gas:

If the functions are required by an interface, the contract should inherit from that interface and use the override keyword


```solidity
File: contracts/accountingManager/AccountingManager.sol


    function _update(address from, address to, uint256 amount) internal override {
        if (!(from == address(0)) && balanceOf(from) < amount + withdrawRequestsByAddress[from]) {
            revert NoyaAccounting_INSUFFICIENT_FUNDS(balanceOf(from), amount, withdrawRequestsByAddress[from]);
        }
        super._update(from, to, amount);
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L185:190

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


    function _lzReceive(Origin calldata _origin, bytes32, bytes calldata _message, address, bytes calldata)
        internal
        override
    {
        (uint256 vaultId, uint256 tvl, uint256 updateTime) = abi.decode(_message, (uint256, uint256, uint256));
        uint256 _srcChainId = chainInfo[_origin.srcEid].chainId;
        OmnichainManagerBaseChain(vaultIdToVaultInfo[vaultId].omniChainManager).updateTVL(_srcChainId, tvl, updateTime);
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L65:72

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


    function _payNative(uint256 amount) internal override returns (uint256) {
        return amount;
    }

```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L40:42

## G010 - Use calldata instead of memory for function arguments that do not get mutated:

Mark data types as `calldata` instead of `memory` where possible. This makes it so that the data is not automatically loaded into memory. If the data passed into the function does not need to be changed (like updating values in an array), it can be passed in as `calldata`. The one exception to this is if the argument must later be passed into another function that takes an argument that specifies `memory` storage.


<details>
<summary>Click to show 31 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


257         function executeDeposit(uint256 maxI, address connector, bytes memory addLPdata)
649         function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {
596         function getQueueItems(bool depositOrWithdraw, uint256[] memory items)
632         function getPositionTVL(HoldingPI memory position, address base) public view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


486         function calculatePositionId(address calculatorConnector, uint256 positionTypeId, bytes memory data)
394         function getHoldingPositionIndex(uint256 vaultId, bytes32 _positionId, address _connector, bytes memory data)


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


114         function _getPositionTVL(HoldingPI memory, address base) public view override returns (uint256 tvl) {
120         function _getUnderlyingTokens(uint256, bytes memory) public pure override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


79          function withdraw(WithdrawData memory data) public onlyManager nonReentrant {
125         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {
53          function supply(DepositData memory data) public onlyManager nonReentrant {
117         function _getUnderlyingTokens(uint256 p, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


162         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {
115         function decreasePosition(DecreasePositionParams memory p) public onlyManager nonReentrant {
67              uint256[] memory amountsWithoutBPT,
66              uint256[] memory amounts,
175         function totalLpBalanceOf(PoolInfo memory pool) public view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


58              bytes memory userData
55              IERC20[] memory tokens,
57              uint256[] memory feeAmounts,
37          function makeFlashLoan(IERC20[] memory tokens, uint256[] memory amounts, bytes memory userData)
56              uint256[] memory amounts,


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


99          function _getUnderlyingTokens(uint256 id, bytes memory data) public view override returns (address[] memory) {
88          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


125         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256) {
134         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


311         function totalLpBalanceOf(PoolInfo memory info) public view returns (uint256) {
325         function balanceOfConvexRewardPool(PoolInfo memory info) public view returns (uint256) {
279         function LPToUnder(PoolInfo memory info, uint256 balance) public view returns (uint256, address) {
335         function balanceOfLPToken(PoolInfo memory info) public view returns (uint256) {
344         function balanceOfRewardPool(PoolInfo memory info) public view returns (uint256) {
265         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


98          function closeBorrowPosition(uint256[] memory marketIds, uint256 accountId) public onlyManager nonReentrant {
106         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


142         function _getUnderlyingTokens(uint256 p, bytes memory data) public view override returns (address[] memory) {
150         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


93          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


91          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


149         function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {
153         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
161         function _getUnderlyingTokens(uint256 id, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


118         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
141         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {
108         function getHealthFactor(Id _id, Market memory _market) public view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


257         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
149         function swapYTForPT(address market, uint256 exactYTIn, uint256 min, ApproxParams memory guess)
311         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {
166         function swapYTForSY(address market, uint256 exactYTIn, uint256 min, LimitOrderData memory orderData)


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


145         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
164         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


128         function _getUnderlyingTokens(uint256, bytes memory) public pure override returns (address[] memory) {
64          function onERC721Received(address, address, uint256, bytes memory) external pure override returns (bytes4) {
121         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


109         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
143         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


110         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
123         function _getUnderlyingTokens(uint256, bytes memory data) public view override returns (address[] memory) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


87          function increasePosition(IncreaseLiquidityParams memory p) external onlyManager nonReentrant {
152         function _getUnderlyingTokens(uint256, bytes memory data) public pure override returns (address[] memory) {
63          function decreasePosition(DecreaseLiquidityParams memory p) external onlyManager nonReentrant {
127         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
40          function openPosition(MintParams memory p) external onlyManager nonReentrant returns (uint256 tokenId) {
101         function collectAllFees(uint256[] memory tokenIds) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


89              bytes32[] memory sigR,
91              uint8[] memory sigV,
90              bytes32[] memory sigS,
42          function updateOwners(address[] memory _owners, bool[] memory addOrRemove) public onlyOwner {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/governance/Watchers.sol


8           function verifyRemoveLiquidity(uint256 withdrawAmount, uint256 sentAmount, bytes memory data) external view { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Watchers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


169         function addLiquidity(address[] memory tokens, uint256[] memory amounts, bytes memory data)
232         function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {
84          function sendTokensToTrustedAddress(address token, uint256 amount, address caller, bytes memory data)
123             address[] memory tokens,
205             address[] memory tokensIn,
125             bytes memory data,
206             address[] memory tokensOut,
207             uint256[] memory amountsIn,
209             uint256[] memory routeIds
263         function _getUnderlyingTokens(uint256, bytes memory) public view virtual returns (address[] memory) {
271         function _getPositionTVL(HoldingPI memory, address) public view virtual returns (uint256 tvl) {
208             bytes[] memory swapData,
124             uint256[] memory amounts,
249         function getPositionTVL(HoldingPI memory p, address baseToken) public view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


27          function sendTokensToTrustedAddress(address token, uint256 amount, address caller, bytes memory data)
71          function getPositionTVL(HoldingPI memory p, address baseToken) public view returns (uint256) {
65          function addPositionToRegistry(bytes memory data) external {
75          function getUnderlyingTokens(uint256 positionTypeId, bytes memory data) public view returns (address[] memory) {
59          function addPositionToRegistryUsingType(uint256 _positionType, bytes memory data) external {
51          function updatePositionToRegistryUsingType(bytes32 _positionId, bytes memory data, bool remove) external {
40          function addLiquidity(address[] memory tokens, uint256[] memory amounts, bytes memory data) external {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


36          function updateMessageSetting(bytes memory _messageSetting) public onlyOwner {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


68          function startBridgeTransaction(BridgeRequest memory bridgeRequest) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


51          function _getPositionTVL(HoldingPI memory position, address) public view override returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol


33          function _getPositionTVL(HoldingPI memory position, address base) public view override returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


147         function addRoutes(RouteData[] memory _routes) public onlyMaintainer {
90          function executeSwap(SwapRequest memory _swapRequest)


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


65          function addBridgeBlacklist(string memory bridgeName, bool state) external onlyOwner {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

</details>

## G011 - Multiple address/ID mappings can be combined into a single mapping of an address/ID to a struct, where appropriate:

Saves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (20000 gas) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot. Finally, if both fields are accessed in the same function, can save ~42 gas per access due to not having to recalculate the key's keccak256 hash (Gkeccak256 - 30 gas) and that calculation's associated stack operations.


<details>
<summary>Click to show 5 findings</summary>

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


20          mapping(uint256 => ChainInfo) public chainInfo; // chainId => ChainInfo
21          mapping(uint256 => VaultInfo) public vaultIdToVaultInfo; // vaultId => VaultInfo


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


15          mapping(address => mapping(address => uint256)) public slippageTolerance;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


13          mapping(address => INoyaValueOracle) public defaultPriceSource;
14          mapping(address => mapping(address => address[])) public priceRoutes;
15          /// @notice Price sources for assets
16          mapping(address => mapping(address => INoyaValueOracle)) public priceSource;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


20          mapping(address => mapping(address => address)) private assetsSources;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


14          mapping(address => mapping(address => address)) public assetToBaseToPool;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## G012 - Using storage instead of `memory` for structs/arrays saves gas:

When fetching data from a storage location, assigning the data to a memory variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (2100 gas) for each field of the struct/array. If the fields are read from the new memory variable, they incur an additional MLOAD rather than a cheap stack read. Instead of declearing the variable with the memory keyword, declaring the variable with the storage keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a memory variable, is if the full struct/array is being returned by the function, is being passed to a function that requires memory, or if the array/struct is being read from another memory array/struct


<details>
<summary>Click to show 7 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


272                 DepositRequest memory data = depositQueue.queue[firstTemp];
412                 WithdrawRequest memory data = withdrawQueue.queue[firstTemp];
633             PositionBP memory p = registry.getPositionBP(vaultId, position.positionId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


441             PositionBP memory position = vaults[vaultId].trustedPositionsBP[_positionId];


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


50              (uint256[] memory markets,,,) = dolomiteMargin.getAccountBalances(Info(address(this), 0));
109             (uint256[] memory markets, address[] memory tokens,, Types.Wei[] memory amounts) =
110                 dolomiteMargin.getAccountBalances(Info(address(this), accountId));
109             (uint256[] memory markets, address[] memory tokens,, Types.Wei[] memory amounts) =
110                 dolomiteMargin.getAccountBalances(Info(address(this), accountId));
109             (uint256[] memory markets, address[] memory tokens,, Types.Wei[] memory amounts) =
110                 dolomiteMargin.getAccountBalances(Info(address(this), accountId));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


36              MarketParams memory params = morphoBlue.idToMarketParams(id);
59              MarketParams memory params = morphoBlue.idToMarketParams(id);
65              Position memory p = morphoBlue.position(id, address(this));
81              MarketParams memory market = morphoBlue.idToMarketParams(id);
96              MarketParams memory params = morphoBlue.idToMarketParams(id);
109             MarketParams memory market = morphoBlue.idToMarketParams(_id);
110             Position memory p = morphoBlue.position(_id, address(this));
122                 MarketParams memory params = morphoBlue.idToMarketParams(id);
123                 Market memory market = morphoBlue.market(id);
124                 Position memory pos = morphoBlue.position(id, address(this));
143             MarketParams memory params = morphoBlue.idToMarketParams(id);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


88              uint256[] memory poolIds = SNXCoreProxy.getApprovedPools();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


99              RouteData memory swapImplInfo = routes[_swapRequest.routeId];
133             RouteData memory bridgeImplInfo = routes[_bridgeRequest.routeId];


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


76              address[] memory sources = priceRoutes[asset][baseToken];


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

</details>

## G013 - Multiple accesses of a mapping/array should use a local variable cache.:

The instances below point to the second+ access of a value inside a mapping/array, within a function. Caching a mapping's value in a local storage or calldata variable when the value is accessed multiple times, saves ~42 gas per access due to not having to recalculate the key's keccak256 hash (Gkeccak256 - 30 gas) and that calculation's associated stack operations. Caching an array's struct avoids recalculating the array offsets into memory/calldata


<details>
<summary>Click to show 19 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


187                 revert NoyaAccounting_INSUFFICIENT_FUNDS(balanceOf(from), amount, withdrawRequestsByAddress[from]);
237                 DepositRequest storage data = depositQueue.queue[middleTemp];
281                 delete depositQueue.queue[firstTemp];
310             withdrawRequestsByAddress[msg.sender] += share;
343                 WithdrawRequest storage data = withdrawQueue.queue[middleTemp];
432                 delete withdrawQueue.queue[firstTemp];
564                     retrieveData[i].connectorAddress,
609                     withdrawData[i] = withdrawQueue.queue[items[i]];


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


119             Vault storage vault = vaults[vaultId];
139                 vault.connectors[vault.accountManager].trustedTokens[_trustedTokens[i]] = true;
177             vaults[vaultId].emergency = _emergency;
196                 emit ConnectorAdded(vaultId, _connectorAddresses[i]);
259                 vault.trustedPositionsBP[positionId] =
255                         revert TokenNotTrusted(usingTokens[i]);
280             delete vault.trustedPositionsBP[_positionId];
360                 vault.isPositionUsed[holdingPositionId] = 0;
355                             vault.holdingPositions[positionIndex].data
460                 vaults[vaultId].emergency
473                     || vaults[vaultId].connectors[connector].trustedTokens[token]
473                     || vaults[vaultId].connectors[connector].trustedTokens[token]
517             return (vaults[vaultId].accountManager, vaults[vaultId].baseToken);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


78                  if (amounts[i] > 0) _approveOperations(tokens[i], balancerVault, amounts[i]);
171             uint256 token1bal = valueOracle.getValue(pool.tokens[pool.tokenIndex], base, _tokenBalances[pool.tokenIndex]);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


92                  require(tokens[i].balanceOf(address(this)) == 0, "BalancerFlashLoan: Flash loan extra tokens");
91                  tokens[i].safeTransfer(msg.sender, amounts[i]);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


146                 amounts[depositIndex] = amount;
287             return (underlyingAssetAmount, info.tokens[info.defaultWithdrawIndex]);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


115                 if (amounts[i].sign) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


74                      (address token) = abi.decode(calls[i].callData[4:], (address));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


142                     tokenIndex = rewardContract.tokenIndex(address(earnedInfo[i].rewardToken));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


119                 uint256 borrowAmount = IERC20(assetsS[i].debtToken).balanceOf(address(this));
135                         + IERC20(assetsS[i].collateralOnlyToken).balanceOf(address(this)) > 0


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


107                 emit CollectFees(tokenIds[i]);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


48                  } else if (!addOrRemove[i] && isOwner[_owners[i]]) {
49                      isOwner[_owners[i]] = false;
49                      isOwner[_owners[i]] = false;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


190                 _updateTokenInRegistry(tokens[i]); // update the token in the registry
184                     revert IConnector_InsufficientDepositAmount(_balanceAfter - _balance, amounts[i]);
217                 emit SwapHoldings(tokensIn[i], tokensOut[i], amountsIn[i], swapData[i]);
217                 emit SwapHoldings(tokensIn[i], tokensOut[i], amountsIn[i], swapData[i]);
217                 emit SwapHoldings(tokensIn[i], tokensOut[i], amountsIn[i], swapData[i]);
217                 emit SwapHoldings(tokensIn[i], tokensOut[i], amountsIn[i], swapData[i]);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


47                  _updateTokenInRegistry(tokens[i]); // update the token in the registry


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


78              uint32 lzChainId = chainInfo[vaultIdToVaultInfo[vaultId].baseChainId].lzChainId;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


59              else approvedBridgeTXN[transactionHash] = block.timestamp;
81              approvedBridgeTXN[txn] = 0;
77                      || destChainAddress[bridgeRequest.destChainId] != bridgeRequest.receiverAddress


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


150                 emit NewRouteAdded(i, _routes[i].route, _routes[i].isEnabled, _routes[i].isBridge);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/TVLHelper.sol


23                  bool isPositionDebt = registry.isPositionDebt(vaultId, positions[i].positionId);
46                      latestUpdateTime = positions[i].positionTimestamp;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/TVLHelper.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


90                  quotingToken = sources[i];


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


76                  emit AssetSourceUpdated(assets[i], baseTokens[i], sources[i]);
76                  emit AssetSourceUpdated(assets[i], baseTokens[i], sources[i]);
76                  emit AssetSourceUpdated(assets[i], baseTokens[i], sources[i]);
145                 return (assetsSources[asset][baseToken], false);
147                 return (assetsSources[baseToken][asset], true);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

</details>

## G014 - Internal functions only called once can be inlined to save gas:

Not inlining costs 20 to 40 gas because of two extra JUMP instructions and additional stack operations needed for function calls.


<details>
<summary>Click to show 4 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


642         function _getValue(address token, address base, uint256 amount) internal view returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


120         function _getHealthFactor(IFraxPair _fraxlendPair, uint256 _exchangeRate) internal view virtual returns (uint256) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


267         function _addLiquidity(address[] memory, uint256[] memory, bytes memory) internal virtual returns (bool) {
221         function _executeSwap(SwapRequest memory swapRequest) internal returns (uint256 amountOut) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


189         function _isNative(IERC20 token) internal pure returns (bool isNative) {
185         function _setAllowance(IERC20 token, address spender, uint256 amount) internal {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

</details>

## G015 - Add unchecked {} for subtractions where the operands cannot underflow because of a previous require() or if-statement:

`require(a <= b); x = b - a` => `require(a <= b); unchecked { x = b - a }`


```solidity
File: contracts/accountingManager/AccountingManager.sol


624             return currentWithdrawGroup.totalCBAmount - availableAssets;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

## G016 - Optimize names to save gas:

public/external function names and public member variable names can be optimized to save gas.


<details>
<summary>Click to show 39 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


16      contract AccountingManager is IAccountingManager, ERC4626, ReentrancyGuard, Pausable, NoyaGovernanceBase {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


7       contract NoyaFeeReceiver is Ownable {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


12      contract PositionRegistry is AccessControl, IPositionRegistry, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


11      contract AaveConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


27      contract AerodromeConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


26      contract BalancerConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


12      contract BalancerFlashLoan is IFlashLoanRecipient, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


30      contract CamelotConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


7       contract CompoundConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


24      contract CurveConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


9       contract DolomiteConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


18      contract FraxConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


8       contract Gearboxv3 is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


7       contract LidoConnector is BaseConnector, ERC721Holder {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


29      contract MaverickConnector is BaseConnector, IERC721Receiver {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


8       contract MorphoBlueConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


8       contract PancakeswapConnector is UNIv3Connector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


12      contract PendleConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


11      contract PrismaConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


7       contract SNXV3Connector is BaseConnector, IERC721Receiver {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


8       contract SiloConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


19      contract StargateConnector is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


12      contract UNIv3Connector is BaseConnector, ERC721Holder {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


9       contract Keepers is EIP712, Ownable2Step {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/governance/Watchers.sol


6       contract Watchers is Keepers {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Watchers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


22      contract BaseConnector is NoyaGovernanceBase, IConnector, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


14      contract ConnectorMock2 {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


18      contract LZHelperReceiver is OAppReceiver {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


19      contract LZHelperSender is OAppSender {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


14      abstract contract OmnichainLogic is BaseConnector {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


8       contract OmnichainManagerBaseChain is OmnichainLogic {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol


10      contract OmnichainManagerNormalChain is OmnichainLogic {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


10      contract SwapAndBridgeHandler is NoyaGovernanceBase, ISwapAndBridgeHandler, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


10      contract LifiImplementation is ISwapAndBridgeImplementation, Ownable2Step, ReentrancyGuard {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/TVLHelper.sol


7       library TVLHelper {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/TVLHelper.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


10      contract NoyaValueOracle is INoyaValueOracle {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


10      contract ChainlinkOracleConnector is INoyaValueOracle {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


12      contract UniswapValueOracle is INoyaValueOracle {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/WETH_Oracle.sol


4       contract WETH_Oracle {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/WETH_Oracle.sol#L0:0

</details>

## G017 - Structs should group like types together to save gas:

Structs can be more gas-efficient by grouping together members of the same type. This ordering can potentially save gas.


```solidity
File: contracts/connectors/BalancerConnector.sol


7       struct PoolInfo {
8           address pool;
9           address[] tokens;
10          uint256 tokenIndex;
11          bytes32 poolId;
12          uint256[] weights;
13          address auraPoolAddress;
14          uint256 boosterPoolId;
15      }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


9       struct PoolInfo {
10          address pool;
11          uint256 tokensSize;
12          address lpToken;
13          address gauge;
14          address convexLPToken;
15          address convexRewardPool;
16          address prismaCurvePool;
17          address prismaConvexPool;
18          address[] tokens;
19          address zap;
20          uint256 defaultWithdrawIndex;
21          address poolAddressIfDefaultWithdrawTokenIsAnotherPosition;
22      }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

## G018 - The result of function calls should be cached rather than re-calling the function:

Caching the result of a function call in a local variable when the function is called multiple times can save gas due to avoiding the need to execute the function code multiple times.


```solidity
File: contracts/connectors/MorphoBlueConnector.sol


84                  revert IConnector_LowHealthFactor(getHealthFactor(id, morphoBlue.market(id)));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

## G019 - Splitting require() statements that use && saves gas:

Splitting require statements that use && operator can save gas. There is a larger deployment gas cost, but with enough runtime calls, the change ends up being cheaper by 3 gas.


```solidity
File: contracts/accountingManager/AccountingManager.sol


361             require(currentWithdrawGroup.isStarted == false && currentWithdrawGroup.isFullfilled == false);
371             require(currentWithdrawGroup.isStarted == true && currentWithdrawGroup.isFullfilled == false);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


28              require(_owners.length <= 10 && _threshold <= _owners.length && _threshold > 1);
53              require(numOwnersTemp <= 10 && threshold <= numOwnersTemp && threshold > 1);
64              require(_threshold <= numOwners && _threshold > 1);
96              require(sigR.length == sigS.length && sigR.length == sigV.length, "Lengths do not match");
106                     require(recovered > lastAdd && isOwner[recovered]);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

## G020 - Stack variable used as a cheaper cache for a state variable is only used once:

If the variable is only accessed once, it's cheaper to use the state variable directly that one time, and save the 3 gas the extra stack assignment would spend.


<details>
<summary>Click to show 12 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


560                 if (balanceBefore + amount > balanceAfter) revert NoyaAccounting_banalceAfterIsNotEnough();
560                 if (balanceBefore + amount > balanceAfter) revert NoyaAccounting_banalceAfterIsNotEnough();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


251                 if (vault.connectors[calculatorConnector].enabled == false) revert NotExist();
442             return position.isEnabled && (!position.onlyOwner || position.calculatorConnector == connector);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


108             IGauge(gauge).withdraw(liquidity);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


49              _updateTokenInRegistry(token);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


78              SNXCoreProxy.delegateCollateral(_accountId, poolId, collateralType, newCollateralAmountD18, leverage);
90                  _accountId, uint128(poolIds[poolIndex]), collateralType, newCollateralAmountD18, leverage


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


89              if (IERC20(lpAddress).balanceOf(address(this)) + LPAmount == 0) {
127             tokens[0] = IStargatePool(lpAddress).token();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


52                  vaultId, positionId, positionData, abi.encode(p.tickLower, p.tickUpper, p.fee), false


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


71              OmnichainManagerBaseChain(vaultIdToVaultInfo[vaultId].omniChainManager).updateTVL(_srcChainId, tvl, updateTime);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


80              _lzSend(lzChainId, data, messageSetting, MessagingFee(address(this).balance, 0), payable(address(this))); // TODO: send event here


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


115             _amountOut = ISwapAndBridgeImplementation(swapImplInfo.route).performSwapAction(msg.sender, _swapRequest);
137             ISwapAndBridgeImplementation(bridgeImplInfo.route).performBridgeAction(msg.sender, _bridgeRequest);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


78              return _getValue(asset, baseToken, amount, sources);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


74              (int56[] memory tickCumulatives,) = IUniswapV3Pool(pool).observe(secondsAgos);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## G021 - Functions guaranteed to revert when called by normal users can be marked payable:

If a function modifier such as onlyOwner is used, the function will revert if a normal user tries to pay the function. Marking the function as payable will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are CALLVALUE(2),DUP1(3),ISZERO(3),PUSH2(3),JUMPI(10),PUSH1(3),DUP1(3),REVERT(0),JUMPDEST(1),POP(2), which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost.


<details>
<summary>Click to show 33 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


124         function updateValueOracle(INoyaValueOracle _valueOracle) public onlyMaintainer {
135         function setFeeReceivers(
136             address _withdrawFeeReceiver,
137             address _performanceFeeReceiver,
138             address _managementFeeReceiver
139         ) public onlyMaintainer {
170         function setFees(uint256 _withdrawFee, uint256 _performanceFee, uint256 _managementFee) public onlyMaintainer {
226         function calculateDepositShares(uint256 maxIterations) public onlyManager nonReentrant whenNotPaused {
257         function executeDeposit(uint256 maxI, address connector, bytes memory addLPdata)
258             public
259             onlyManager
260             whenNotPaused
261             nonReentrant
262         {
328         function calculateWithdrawShares(uint256 maxIterations) public onlyManager nonReentrant whenNotPaused {
360         function startCurrentWithdrawGroup() public onlyManager nonReentrant whenNotPaused {
370         function fulfillCurrentWithdrawGroup() public onlyManager nonReentrant whenNotPaused {
396         function executeWithdraw(uint256 maxIterations) public onlyManager nonReentrant whenNotPaused {
453         function resetMiddle(uint256 newMiddle, bool depositOrWithdraw) public onlyManager {
475         function recordProfitForFee() public onlyManager nonReentrant {
505         function collectManagementFees() public onlyManager nonReentrant returns (uint256, uint256) {
526         function collectPerformanceFees() public onlyManager nonReentrant {
548         function retrieveTokensForWithdraw(RetrieveData[] calldata retrieveData) public onlyManager nonReentrant {
659         function emergencyStop() public whenNotPaused onlyEmergency {
663         function unpause() public whenPaused onlyEmergency {
667         function setDepositLimits(uint256 _depositLimitPerTransaction, uint256 _depositTotalAmount) public onlyMaintainer {
673         function changeDepositWaitingTime(uint256 _depositWaitingTime) public onlyMaintainer {
678         function changeWithdrawWaitingTime(uint256 _withdrawWaitingTime) public onlyMaintainer {
683         function rescue(address token, uint256 amount) public onlyEmergency nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


23          function withdrawShares(uint256 amount) external onlyOwner {
27          function burnShares(uint256 amount) external onlyOwner {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


79          function setMaxNumHoldingPositions(uint256 _maxNumHoldingPositions) external onlyRole(MAINTAINER_ROLE) {
84          function setFlashLoanAddress(address _flashLoan) external onlyRole(MAINTAINER_ROLE) {
106         function addVault(
107             uint256 vaultId,
108             address _accountingManager,
109             address _baseToken,
110             address _governer,
111             address _maintainer,
112             address _maintainerWithoutTimelock,
113             address _keeperContract,
114             address _watcher,
115             address _emergency,
116             address[] calldata _trustedTokens
117         ) external onlyRole(MAINTAINER_ROLE) {
158         function changeVaultAddresses(
159             uint256 vaultId,
160             address _governer,
161             address _maintainer,
162             address _maintainerWithoutTimelock,
163             address _keeperContract,
164             address _watcher,
165             address _emergency
166         ) external onlyVaultGoverner(vaultId) vaultExists(vaultId) {
188         function addConnector(uint256 vaultId, address[] calldata _connectorAddresses, bool[] calldata _enableds)
189             external
190             onlyVaultMaintainer(vaultId)
191             vaultExists(vaultId)
192         {
207         function updateConnectorTrustedTokens(
208             uint256 vaultId,
209             address _connectorAddress,
210             address[] calldata _tokens,
211             bool trusted
212         ) external onlyVaultMaintainer(vaultId) vaultExists(vaultId) {
238         function addTrustedPosition(
239             uint256 vaultId,
240             uint256 _positionTypeId,
241             address calculatorConnector,
242             bool onlyOwner,
243             bool _isDebt,
244             bytes calldata _data,
245             bytes calldata _additionalData
246         ) external onlyVaultMaintainerWithoutTimeLock(vaultId) vaultExists(vaultId) nonReentrant {
266         function removeTrustedPosition(uint256 vaultId, bytes32 _positionId)
267             external
268             onlyVaultMaintainer(vaultId)
269             vaultExists(vaultId)
270         {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


46          function supply(address supplyToken, uint256 amount) external onlyManager nonReentrant {
62          function borrow(uint256 _amount, uint256 _interestRateMode, address _borrowAsset)
63              external
64              onlyManager
65              nonReentrant
66          {
81          function repay(address asset, uint256 amount, uint256 i) external onlyManager nonReentrant {
88          function repayWithCollateral(uint256 _amount, uint256 i, address _borrowAsset) external onlyManager {
100         function withdrawCollateral(uint256 _collateralAmount, address _collateral) external onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


53          function supply(DepositData memory data) public onlyManager nonReentrant {
79          function withdraw(WithdrawData memory data) public onlyManager nonReentrant {
100         function stake(address pool, uint256 liquidity) public onlyManager nonReentrant {
106         function unstake(address pool, uint256 liquidity) public onlyManager nonReentrant {
111         function claim(address pool) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


53          function harvestAuraRewards(address[] calldata rewardsPools) public onlyManager nonReentrant {
64          function openPosition(
65              bytes32 poolId,
66              uint256[] memory amounts,
67              uint256[] memory amountsWithoutBPT,
68              uint256 minBPT,
69              uint256 auraAmount
70          ) public onlyManager nonReentrant {
109         function depositIntoAuraBooster(bytes32 poolId, uint256 _amount) public onlyManager nonReentrant {
115         function decreasePosition(DecreasePositionParams memory p) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


43          function addLiquidityInCamelotPool(CamelotAddLiquidityParams calldata p) external onlyManager nonReentrant {
65          function removeLiquidityFromCamelotPool(CamelotRemoveLiquidityParams calldata p)
66              external
67              onlyManager
68              nonReentrant
69          {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


29          function supply(address market, address asset, uint256 amount) external onlyManager nonReentrant {
48          function withdrawOrBorrow(address _market, address asset, uint256 amount) external onlyManager nonReentrant {
63          function claimRewards(address rewardContract, address market) external onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


68          function depositIntoGauge(address pool, uint256 amount) public onlyManager nonReentrant {
81          function depositIntoPrisma(address pool, uint256 amount, bool curveOrConvex) public onlyManager nonReentrant {
103         function depositIntoConvexBooster(address pool, uint256 pid, uint256 amount, bool stake) public onlyManager {
117         function openCurvePosition(address pool, uint256 depositIndex, uint256 amount, uint256 minAmount)
118             public
119             onlyManager
120             nonReentrant
121         {
160         function decreaseCurvePosition(address pool, uint256 withdrawIndex, uint256 amount, uint256 minAmount)
161             public
162             onlyManager
163             nonReentrant
164         {
182         function withdrawFromConvexBooster(uint256 pid, uint256 amount) public onlyManager {
192         function withdrawFromConvexRewardPool(address pool, uint256 amount) public onlyManager {
202         function withdrawFromGauge(address pool, uint256 amount) public onlyManager {
212         function withdrawFromPrisma(address depostiToken, uint256 amount) public onlyManager {
221         function harvestRewards(address[] calldata gauges) public onlyManager nonReentrant {
233         function harvestPrismaRewards(address[] calldata pools) public onlyManager nonReentrant {
247         function harvestConvexRewards(address[] calldata rewardsPools) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


30          function deposit(uint256 marketId, uint256 _amount) public onlyManager nonReentrant {
43          function withdraw(uint256 marketId, uint256 _amount) public onlyManager nonReentrant {
58          function openBorrowPosition(uint256 marketId, uint256 _amountWei, uint256 accountId)
59              public
60              onlyManager
61              nonReentrant
62          {
77          function transferBetweenAccounts(uint256 accountId, uint256 marketId, uint256 _amountWei, bool borrowOrRepay)
78              public
79              onlyManager
80              nonReentrant
81          {
98          function closeBorrowPosition(uint256[] memory marketIds, uint256 accountId) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


38          function borrowAndSupply(IFraxPair pool, uint256 borrowAmount, uint256 collateralAmount)
39              external
40              onlyManager
41              nonReentrant
42          {
68          function withdraw(IFraxPair pool, uint256 withdrawAmount) public onlyManager nonReentrant {
87          function repay(IFraxPair pool, uint256 sharesToRepay) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


24          function openAccount(address facade, uint256 ref) public onlyManager {
41          function closeAccount(address facade, address creditAccount) public onlyManager nonReentrant {
62          function executeCommands(
63              address facade,
64              address creditAccount,
65              MultiCall[] calldata calls,
66              address approvalToken,
67              uint256 amount
68          ) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


37          function deposit(uint256 amountIn) external onlyManager nonReentrant {
51          function requestWithdrawals(uint256 amount) public onlyManager nonReentrant {
69          function claimWithdrawal(uint256 requestId) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


64          function stake(uint256 amount, uint256 duration, bool doDelegation) external onlyManager nonReentrant {
78          function unstake(uint256 lockupId) external onlyManager nonReentrant {
91          function addLiquidityInMaverickPool(MavericAddLiquidityParams calldata p) external onlyManager nonReentrant {
115         function removeLiquidityFromMaverickPool(MavericRemoveLiquidityParams calldata p)
116             external
117             onlyManager
118             nonReentrant
119         {
137         function claimBoostedPositionRewards(IMaverickReward rewardContract) external onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


35          function supply(uint256 amount, Id id, bool sOrC) external onlyManager nonReentrant {
58          function withdraw(uint256 amount, Id id, bool sOrC) external onlyManager nonReentrant {
80          function borrow(uint256 amount, Id id) external onlyManager nonReentrant {
95          function repay(uint256 amount, Id id) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


31          function sendPositionToMasterChef(uint256 tokenId) external onlyManager nonReentrant {
40          function updatePosition(uint256 tokenId) public onlyManager nonReentrant {
50          function withdraw(uint256 tokenId) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


78          function supply(address market, uint256 amount) external onlyManager nonReentrant {
97          function mintPTAndYT(address market, uint256 syAmount) external onlyManager nonReentrant {
112         function depositIntoMarket(IPMarket market, uint256 SYamount, uint256 PTamount) external onlyManager nonReentrant {
126         function depositIntoPenpie(address _market, uint256 _amount) public onlyManager nonReentrant {
137         function withdrawFromPenpie(address _market, uint256 _amount) public onlyManager nonReentrant {
149         function swapYTForPT(address market, uint256 exactYTIn, uint256 min, ApproxParams memory guess)
150             external
151             onlyManager
152         {
166         function swapYTForSY(address market, uint256 exactYTIn, uint256 min, LimitOrderData memory orderData)
167             public
168             onlyManager
169         {
183         function swapExactPTForSY(IPMarket market, uint256 exactPTIn, bytes calldata swapData, uint256 minSY)
184             external
185             onlyManager
186             nonReentrant
187         {
203         function burnLP(IPMarket market, uint256 amount) external onlyManager nonReentrant {
216         function decreasePosition(IPMarket market, uint256 _amount, bool closePosition) external onlyManager nonReentrant {
241         function claimRewards(IPMarket market) external onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


33          function approveZap(IStakeNTroveZap zap, address tm, bool approve) public onlyManager nonReentrant {
52          function openTrove(IStakeNTroveZap zap, address tm, uint256 maxFee, uint256 dAmount, uint256 bAmount)
53              public
54              onlyManager
55              nonReentrant
56          {
75          function addColl(IStakeNTroveZap zapContract, address tm, uint256 amountIn) public onlyManager nonReentrant {
97          function adjustTrove(
98              IStakeNTroveZap zapContract,
99              address tm,
100             uint256 mFee,
101             uint256 wAmount,
102             uint256 bAmount,
103             bool isBorrowing
104         ) public onlyManager nonReentrant {
129         function closeTrove(IStakeNTroveZap zapContract, address troveManager) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


25          function createAccount() public onlyManager {
30          function deposit(address _token, uint256 _amount, uint128 _accountId) public onlyManager {
46          function withdraw(address _token, uint256 _amount, uint128 _accountId) public onlyManager {
68          function delegateIntoPreferredPool(
69              uint128 _accountId,
70              address collateralType,
71              uint256 newCollateralAmountD18,
72              uint256 leverage
73          ) public onlyManager {
81          function delegateIntoApprovedPool(
82              uint256 poolIndex,
83              uint128 _accountId,
84              address collateralType,
85              uint256 newCollateralAmountD18,
86              uint256 leverage
87          ) public onlyManager {
94          function claimRewards(uint128 accountId, uint128 poolId, address collateralType, address distributor)
95              public
96              onlyManager
97          {
102         function mintOrBurnSUSD(
103             uint256 _amount,
104             uint128 _accountId,
105             uint128 poolId,
106             address collateralType,
107             bool mintOrBurn
108         ) public onlyManager {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


33          function deposit(address siloToken, address dToken, uint256 amount, bool oC) external onlyManager nonReentrant {
52          function withdraw(address siloToken, address wToken, uint256 amount, bool oC, bool closePosition)
53              external
54              onlyManager
55              nonReentrant
56          {
85          function borrow(address siloToken, address bToken, uint256 amount) external onlyManager nonReentrant {
98          function repay(address siloToken, address rToken, uint256 amount) external onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


49          function depositIntoStargatePool(StargateRequest calldata depositRequest) external onlyManager nonReentrant {
76          function withdrawFromStargatePool(StargateRequest calldata withdrawRequest) external onlyManager nonReentrant {
103         function claimStargateRewards(uint256 poolId) external onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


40          function openPosition(MintParams memory p) external onlyManager nonReentrant returns (uint256 tokenId) {
63          function decreasePosition(DecreaseLiquidityParams memory p) external onlyManager nonReentrant {
87          function increasePosition(IncreaseLiquidityParams memory p) external onlyManager nonReentrant {
101         function collectAllFees(uint256[] memory tokenIds) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


42          function updateOwners(address[] memory _owners, bool[] memory addOrRemove) public onlyOwner {
63          function setThreshold(uint8 _threshold) public onlyOwner {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


45          function updateMinimumHealthFactor(uint256 _minimumHealthFactor) external onlyMaintainer {
58          function updateSwapHandler(address payable _swapHandler) external onlyMaintainer {
67          function updateValueOracle(address _valueOracle) external onlyMaintainer {
122         function transferPositionToAnotherConnector(
123             address[] memory tokens,
124             uint256[] memory amounts,
125             bytes memory data,
126             address connector
127         ) external onlyManager nonReentrant {
153         function updateTokenInRegistry(address token) public onlyManager {
204         function swapHoldings(
205             address[] memory tokensIn,
206             address[] memory tokensOut,
207             uint256[] memory amountsIn,
208             bytes[] memory swapData,
209             uint256[] memory routeIds
210         ) external onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


40          function setChainInfo(uint256 chainId, uint32 lzChainId, address lzHelperAddress) public onlyOwner {
52          function addVaultInfo(uint256 vaultId, uint256 baseChainId, address omniChainManager) public onlyOwner {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


36          function updateMessageSetting(bytes memory _messageSetting) public onlyOwner {
51          function setChainInfo(uint256 chainId, uint32 lzChainId, address lzHelperAddress) public onlyOwner {
63          function addVaultInfo(uint256 vaultId, uint256 baseChainId, address omniChainManager) public onlyOwner {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


46          function updateChainInfo(uint256 chainId, address destinationAddress) external onlyMaintainer {
57          function updateBridgeTransactionApproval(bytes32 transactionHash) public onlyManager {
68          function startBridgeTransaction(BridgeRequest memory bridgeRequest) public onlyManager nonReentrant {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol


28          function updateTVLInfo() external onlyManager {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


48          function setValueOracle(address _valueOracle) external onlyMaintainerOrEmergency {
57          function setGeneralSlippageTolerance(uint256 _slippageTolerance) external onlyMaintainerOrEmergency {
68          function setSlippageTolerance(address _inputToken, address _outputToken, uint256 _slippageTolerance)
69              external
70              onlyMaintainerOrEmergency
71          {
80          function addEligibleUser(address _user) external onlyMaintainerOrEmergency {
147         function addRoutes(RouteData[] memory _routes) public onlyMaintainer {
158         function setEnableRoute(uint256 _routeId, bool enable) external onlyMaintainerOrEmergency {
164         function verifyRoute(uint256 _routeId, address addr) external view onlyExistingRoute(_routeId) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


45          function addHandler(address _handler, bool state) external onlyOwner {
55          function addChain(uint256 _chainId, bool state) external onlyOwner {
65          function addBridgeBlacklist(string memory bridgeName, bool state) external onlyOwner {
193         function rescueFunds(address token, address userAddress, uint256 amount) external onlyOwner {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


37          function updateDefaultPriceSource(address[] calldata baseCurrencies, INoyaValueOracle[] calldata oracles)
38              public
39              onlyMaintainer
40          {
51          function updateAssetPriceSource(address[] calldata asset, address[] calldata baseToken, address[] calldata oracle)
52              external
53              onlyMaintainer
54          {
61          function updatePriceRoute(address asset, address base, address[] calldata s) external onlyMaintainer {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


56          function updateChainlinkPriceAgeThreshold(uint256 _chainlinkPriceAgeThreshold) external onlyMaintainer {
70          function setAssetSources(address[] calldata assets, address[] calldata baseTokens, address[] calldata sources)
71              external
72              onlyMaintainer
73          {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


38          function setPeriod(uint32 _period) external onlyMaintainer {
48          function addPool(address tokenIn, address baseToken, uint24 fee) external onlyMaintainer {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## G022 - `<x> += <y>` costs more gas than `<x> = <x> + <y>` for state variables:

Using the addition operator instead of plus-equals saves 113 gas


```solidity
File: contracts/accountingManager/AccountingManager.sol


217             depositQueue.last += 1;
218             depositQueue.totalAWFDeposit += amount;
284             depositQueue.totalAWFDeposit -= processedBaseTokenAmount;
286             totalDepositedAmount += processedBaseTokenAmount;
310             withdrawRequestsByAddress[msg.sender] += share;
315             withdrawQueue.last += 1;
353             currentWithdrawGroup.totalCBAmount += assetsNeededForWithdraw;
418                 withdrawRequestsByAddress[data.owner] -= shares;
436             totalWithdrawnAmount += processedBaseTokenAmount;
569             amountAskedForWithdraw += amountAskedForWithdraw_temp;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

## G023 - Constructors can be marked payable:

Payable functions cost less gas to execute, since the compiler does not have to add extra checks to ensure that a payment wasn't provided. A constructor can safely be marked as payable, since only the deployer would be able to pass funds, and the project itself would not pass any funds.


<details>
<summary>Click to show 39 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


94          constructor(AccountingManagerConstructorParams memory p)
95              ERC4626(IERC20(p._baseTokenAddress))
96              ERC20(p._name, p._symbol)
97              NoyaGovernanceBase(PositionRegistry(p._registry), p._vaultId)
98          {
99              baseToken = IERC20(p._baseTokenAddress);
100             valueOracle = INoyaValueOracle(p._valueOracle);
101             lastFeeDistributionTime = block.timestamp;
102             withdrawFeeReceiver = p._withdrawFeeReceiver;
103             performanceFeeReceiver = p._performanceFeeReceiver;
104             managementFeeReceiver = p._managementFeeReceiver;
105     
106             require(p._baseTokenAddress != address(0));
107             require(p._valueOracle != address(0));
108             require(p._withdrawFeeReceiver != address(0));
109             require(p._performanceFeeReceiver != address(0));
110             require(p._managementFeeReceiver != address(0));
111     
112             if (
113                 p._withdrawFee > WITHDRAWAL_MAX_FEE || p._performanceFee > PERFORMANCE_MAX_FEE
114                     || p._managementFee > MANAGEMENT_MAX_FEE
115             ) {
116                 revert NoyaAccounting_INVALID_FEE();
117             }
118             withdrawFee = p._withdrawFee;
119             performanceFee = p._performanceFee;
120             managementFee = p._managementFee;
121         }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


14          constructor(address _accountingManager, address _baseToken, address _receiver) Ownable(msg.sender) {
15              require(_accountingManager != address(0));
16              require(_baseToken != address(0));
17              require(_receiver != address(0));
18              accountingManager = _accountingManager;
19              baseToken = _baseToken;
20              receiver = _receiver;
21          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


66          constructor(address _governer, address _maintainer, address _emergency, address _flashLoan) {
67              require(_governer != address(0));
68              require(_maintainer != address(0));
69              require(_emergency != address(0));
70              _grantRole(GOVERNER_ROLE, _governer);
71              _grantRole(MAINTAINER_ROLE, _maintainer);
72              _grantRole(EMERGENCY_ROLE, _emergency);
73              _setRoleAdmin(GOVERNER_ROLE, GOVERNER_ROLE);
74              _setRoleAdmin(MAINTAINER_ROLE, GOVERNER_ROLE);
75              _setRoleAdmin(EMERGENCY_ROLE, GOVERNER_ROLE);
76              flashLoan = _flashLoan;
77          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


33          constructor(address _pool, address _poolBaseToken, BaseConnectorCP memory baseConnectorParams)
34              BaseConnector(baseConnectorParams)
35          {
36              require(_pool != address(0));
37              require(_poolBaseToken != address(0));
38              poolBaseToken = _poolBaseToken;
39              pool = _pool;
40          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


40          constructor(address _router, address _voter, BaseConnectorCP memory baseConnectorParams)
41              BaseConnector(baseConnectorParams)
42          {
43              require(_router != address(0));
44              aerodromeRouter = IRouter(_router);
45              voter = IVoter(_voter);
46          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


42          constructor(address _balancerVault, address bal, address aura, BaseConnectorCP memory baseConnectorParams)
43              BaseConnector(baseConnectorParams)
44          {
45              require(_balancerVault != address(0));
46              require(bal != address(0));
47              require(aura != address(0));
48              AURA = aura;
49              BAL = bal;
50              balancerVault = _balancerVault;
51          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


24          constructor(address _balancerVault, PositionRegistry _registry) {
25              require(_balancerVault != address(0));
26              require(address(_registry) != address(0));
27              vault = IBalancerVault(_balancerVault);
28              registry = _registry;
29          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


36          constructor(address _router, address _factory, BaseConnectorCP memory baseCP) BaseConnector(baseCP) {
37              require(_router != address(0));
38              require(_factory != address(0));
39              router = ICamelotRouter(_router);
40              factory = ICamelotFactory(_factory);
41          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


17          constructor(BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


45          constructor(
46              address _convexBooster,
47              address cvx,
48              address crv,
49              address prisma,
50              BaseConnectorCP memory baseConnectorParams
51          ) BaseConnector(baseConnectorParams) {
52              require(_convexBooster != address(0));
53              require(cvx != address(0));
54              require(crv != address(0));
55              require(prisma != address(0));
56              convexBooster = IBooster(_convexBooster);
57              CVX = cvx;
58              CRV = crv;
59              PRISMA = prisma;
60          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


18          constructor(
19              address _depositWithdrawalProxy,
20              address _dolomiteMargin,
21              address _borrowPositionProxy,
22              BaseConnectorCP memory baseConnectorParams
23          ) BaseConnector(baseConnectorParams) {
24              require(_depositWithdrawalProxy != address(0));
25              depositWithdrawalProxy = IDepositWithdrawalProxy(_depositWithdrawalProxy);
26              dolomiteMargin = IDolomiteMargin(_dolomiteMargin);
27              borrowPositionProxy = IBorrowPositionProxyV1(_borrowPositionProxy);
28          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


29          constructor(BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


17          constructor(BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


20          constructor(address _lido, address _lidoW, address _steth, address w, BaseConnectorCP memory baseConnectorParams)
21              BaseConnector(baseConnectorParams)
22          {
23              require(_lido != address(0));
24              require(_lidoW != address(0));
25              require(_steth != address(0));
26              require(w != address(0));
27              lido = _lido;
28              lidoWithdrawal = _lidoW;
29              steth = _steth;
30              weth = w;
31          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


43          constructor(address _mav, address _veMav, address mr, address pi, BaseConnectorCP memory baseCP)
44              BaseConnector(baseCP)
45          {
46              require(_mav != address(0));
47              require(_veMav != address(0));
48              require(mr != address(0));
49              require(pi != address(0));
50              mav = _mav;
51              veMav = _veMav;
52              maverickRouter = mr;
53              positionInspector = IPositionInspector(pi);
54          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


23          constructor(address MB, BaseConnectorCP memory baseCP) BaseConnector(baseCP) {
24              require(MB != address(0));
25              morphoBlue = IMorpho(MB);
26          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


19          constructor(address MC, address _positionManager, address _factory, BaseConnectorCP memory baseConnectorParams)
20              UNIv3Connector(_positionManager, _factory, baseConnectorParams)
21          {
22              require(MC != address(0));
23              masterchef = IMasterchefV3(MC);
24          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


57          constructor(address _pendleMarketDepositHelper, address _pendleRouter, address SR, BaseConnectorCP memory baseCP)
58              BaseConnector(baseCP)
59          {
60              require(_pendleMarketDepositHelper != address(0));
61              require(_pendleRouter != address(0));
62              require(SR != address(0));
63              pendleMarketDepositHelper = IPendleMarketDepositHelper(_pendleMarketDepositHelper);
64              pendleRouter = IPAllActionV3(_pendleRouter);
65              staticRouter = IPendleStaticRouter(SR);
66          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


25          constructor(BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


20          constructor(address _SNXCoreProxy, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {
21              require(_SNXCoreProxy != address(0));
22              SNXCoreProxy = IV3CoreProxy(_SNXCoreProxy);
23          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


17          constructor(address SR, BaseConnectorCP memory baseConnectorParams) BaseConnector(baseConnectorParams) {
18              require(SR != address(0));
19      
20              siloRepository = ISiloRepository(SR);
21              MINIMUM_HEALTH_FACTOR = 5e17;
22      
23              minimumHealthFactor = MINIMUM_HEALTH_FACTOR;
24          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


33          constructor(address lpStacking, address _stargateRouter, BaseConnectorCP memory baseConnectorParams)
34              BaseConnector(baseConnectorParams)
35          {
36              require(lpStacking != address(0));
37              require(_stargateRouter != address(0));
38      
39              LPStaking = IStargateLPStaking(lpStacking);
40              stargateRouter = IStargateRouter(_stargateRouter);
41              rewardToken = LPStaking.stargate();
42          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


27          constructor(address _positionManager, address _factory, BaseConnectorCP memory baseConnectorParams)
28              BaseConnector(baseConnectorParams)
29          {
30              positionManager = INonfungiblePositionManager(_positionManager);
31              factory = IUniswapV3Factory(_factory);
32          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


27          constructor(address[] memory _owners, uint8 _threshold) EIP712("Keepers", "1") Ownable2Step() Ownable(msg.sender) {
28              require(_owners.length <= 10 && _threshold <= _owners.length && _threshold > 1);
29              for (uint256 i = 0; i < _owners.length; i++) {
30                  isOwner[_owners[i]] = true;
31              }
32              numOwners = _owners.length;
33              threshold = _threshold;
34          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/governance/NoyaGovernanceBase.sol


21          constructor(PositionRegistry _registry, uint256 _vaultId) {
22              require(address(_registry) != address(0));
23              registry = _registry;
24              vaultId = _vaultId;
25          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L0:0

```solidity
File: contracts/governance/TimeLock.sol


7           constructor(uint256 minDelay, address[] memory proposers, address[] memory executors, address owner)
8               TimelockController(minDelay, proposers, executors, owner)
9           { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/TimeLock.sol#L0:0

```solidity
File: contracts/governance/Watchers.sol


7           constructor(address[] memory _owners, uint8 _threshold) Keepers(_owners, _threshold) { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Watchers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


33          constructor(BaseConnectorCP memory params) NoyaGovernanceBase(params.registry, params.vaultId) {
34              swapHandler = params.swapHandler;
35              valueOracle = params.valueOracle;
36              minimumHealthFactor = MINIMUM_HEALTH_FACTOR;
37          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


22          constructor(address _registry, uint256 _vaultId) {
23              registry = PositionRegistry(_registry);
24              vaultId = _vaultId;
25          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


31          constructor(address _endpoint, address _owner) OAppReceiver() OAppCore(_endpoint, _owner) { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


29          constructor(address _endpoint, address _owner) OAppSender() OAppCore(_endpoint, _owner) { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


33          constructor(address payable _lzHelper, BaseConnectorCP memory baseConnectorParams)
34              BaseConnector(baseConnectorParams)
35          {
36              lzHelper = _lzHelper;
37              require(_lzHelper != address(0));
38          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


19          constructor(uint256 dl, address payable _lzHelper, BaseConnectorCP memory baseConnectorParams)
20              OmnichainLogic(_lzHelper, baseConnectorParams)
21          {
22              DUST_LEVEL = dl;
23          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol


11          constructor(address payable _lzHelper, BaseConnectorCP memory baseConnectorParams)
12              OmnichainLogic(_lzHelper, baseConnectorParams)
13          { }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


34          constructor(address[] memory usersAddresses, address _valueOracle, PositionRegistry _registry, uint256 _vaultId)
35              NoyaGovernanceBase(_registry, _vaultId)
36          {
37              for (uint256 i = 0; i < usersAddresses.length; i++) {
38                  isEligibleToUse[usersAddresses[i]] = true;
39              }
40              valueOracle = INoyaValueOracle(_valueOracle);
41              require(_valueOracle != address(0));
42          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


27          constructor(address swapHandler, address _lifi) Ownable2Step() Ownable(msg.sender) {
28              isHandler[swapHandler] = true;
29              lifi = _lifi;
30          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


29          constructor(PositionRegistry _registry) {
30              require(address(_registry) != address(0));
31              registry = _registry;
32          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


46          constructor(address _reg) {
47              require(_reg != address(0));
48              registry = PositionRegistry(_reg);
49          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


31          constructor(address _factory, PositionRegistry _registry) {
32              factory = _factory;
33              registry = _registry;
34          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## G024 - Remove unused local variables:

Removing unused local variables saves gas.


<details>
<summary>Click to show 5 findings</summary>

```solidity
File: contracts/connectors/BalancerConnector.sol


117                 (PoolInfo memory _poolInfo, bytes32 positionId) = _getPoolInfo(p.poolId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


69              (,,, address keeperContract,, address emergencyManager) = registry.getGovernanceAddresses(vaultId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


79              (IPStandardizedYield _SY, IPPrincipalToken _PT,) = IPMarket(market).readTokens();
98              (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
153             (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
153             (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
170             (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
170             (IPStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT) = IPMarket(market).readTokens();
188             (IPStandardizedYield _SY, IPPrincipalToken _PT,) = IPMarket(market).readTokens();
190             (uint256 netSyOut, uint256 netSyFee) = market.swapExactPtForSy(address(this), exactPTIn, swapData);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


123             (uint256 totalDeposited, uint256 totalAssigned, uint256 totalLocked) =


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


129             uint256 tokenId = abi.decode(p.data, (uint256));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

</details>

## G025 - Use solidity version 0.8.20 or above to improve gas performance:

Upgrade to the latest solidity version 0.8.20 to get additional gas savings. See the latest release for reference: https://blog.soliditylang.org/2023/05/10/solidity-0.8.20-release-announcement/


<details>
<summary>Click to show 41 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/governance/NoyaGovernanceBase.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L0:0

```solidity
File: contracts/governance/TimeLock.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/TimeLock.sol#L0:0

```solidity
File: contracts/governance/Watchers.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Watchers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperReceiver.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperReceiver.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerBaseChain.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainManagerNormalChain.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/TVLHelper.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/TVLHelper.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/WETH_Oracle.sol


2       pragma solidity 0.8.20;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/WETH_Oracle.sol#L0:0

</details>

## G026 - Use assembly to emit events:

Using the [scratch space](https://github.com/Vectorized/solady/blob/30558f5402f02351b96eeb6eaf32bcea29773841/src/tokens/ERC1155.sol#L501-L504) for event arguments (two words or fewer) will save gas over needing Solidity's full abi memory expansion used for emitting normally. 


<details>
<summary>Click to show 27 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


127             emit ValueOracleUpdated(address(_valueOracle));
146             emit FeeRecepientsChanged(_withdrawFeeReceiver, _performanceFeeReceiver, _managementFeeReceiver);
154             emit TransferTokensToTrustedAddress(token, amount, _caller, _data);
180             emit FeeRatesChanged(_withdrawFee, _performanceFee, _managementFee);
216             emit RecordDeposit(depositQueue.last, receiver, block.timestamp, amount, referrer);
242                 emit CalculateDeposit(
243                     middleTemp, data.receiver, block.timestamp, shares, data.amount, shares * 1e18 / data.amount
244                 );
274                 emit ExecuteDeposit(
275                     firstTemp, data.receiver, block.timestamp, data.shares, data.amount, data.shares * 1e18 / data.amount
276                 );
314             emit RecordWithdraw(withdrawQueue.last, msg.sender, receiver, share, block.timestamp);
349                 emit CalculateWithdraw(middleTemp, data.owner, data.receiver, data.shares, assets, block.timestamp);
364             emit WithdrawGroupStarted(currentWithdrawGroup.lastId, currentWithdrawGroup.totalCBAmount);
387             emit WithdrawGroupFulfilled(
388                 currentWithdrawGroup.lastId, currentWithdrawGroup.totalCBAmount, currentWithdrawGroup.totalABAmount
389             );
429                 emit ExecuteWithdraw(
430                     firstTemp, data.owner, data.receiver, shares, data.amount, baseTokenAmount, block.timestamp
431                 );
455                 emit ResetMiddle(newMiddle, depositQueue.middle, depositOrWithdraw);
462                 emit ResetMiddle(newMiddle, withdrawQueue.middle, depositOrWithdraw);
485             emit RecordProfit(
486                 storedProfitForFee, totalProfitCalculated, preformanceFeeSharesWaitingForDistribution, block.timestamp
487             );
496                 emit ResetFee(currentProfit, storedProfitForFee, block.timestamp);
520             emit CollectManagementFee(managementFeeAmount, timePassed, totalShares, currentFeeShares);
538             emit CollectPerformanceFee(preformanceFeeSharesWaitingForDistribution);
562                 emit RetrieveTokensForWithdraw(
563                     retrieveData[i].withdrawAmount,
564                     retrieveData[i].connectorAddress,
565                     amount,
566                     amountAskedForWithdraw + amountAskedForWithdraw_temp
567                 );
670             emit SetDepositLimits(_depositLimitPerTransaction, _depositTotalAmount);
675             emit SetDepositWaitingTime(_depositWaitingTime);
680             emit SetWithdrawWaitingTime(_withdrawWaitingTime);
690             emit Rescue(msg.sender, token, amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


85              emit updateFlashloanAddress(_flashLoan, flashLoan);
142             emit VaultAdded(vaultId, _accountingManager, _baseToken, _trustedTokens);
143             emit VaultAddressesChanged(
144                 vaultId, _governer, _maintainer, _maintainerWithoutTimelock, _keeperContract, _watcher, _emergency
145             );
178             emit VaultAddressesChanged(
179                 vaultId, _governer, _maintainer, _maintainerWithoutTimelock, _keeperContract, _watcher, _emergency
180             );
196                 emit ConnectorAdded(vaultId, _connectorAddresses[i]);
217             emit ConnectorTrustedTokensUpdated(vaultId, _connectorAddress, _tokens, trusted);
262             emit TrustedPositionAdded(vaultId, positionId, calculatorConnector, _positionTypeId, onlyOwner, _isDebt, _data);
279             emit TrustedPositionRemoved(vaultId, _positionId);
302             emit HoldingPositionUpdated(vaultId, _positionId, d, AD, false, index);
361                 emit HoldingPositionUpdated(vaultId, _positionId, _data, additionalData, removePosition, positionIndex);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


53              emit Supply(supplyToken, amount);
75              emit Borrow(_borrowAsset, _amount);
85              emit Repay(asset, amount, i);
90              emit RepayWithCollateral(_borrowAsset, _amount, i);
111             emit WithdrawCollateral(_collateral, _collateralAmount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


72              emit Supply(data.pool, data.amount0, data.amount1);
97              emit Withdraw(data.pool, data.amountLiquidity);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


106             emit OpenPosition(poolId, amounts, amountsWithoutBPT, minBPT, auraAmount);
159             emit DecreasePosition(p);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


42              emit MakeFlashLoan(tokens, amounts);
60              emit ReceiveFlashLoan(tokens, amounts, feeAmounts, userData);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


37              emit Supply(market, asset, amount);
59              emit WithdrawOrBorrow(_market, asset, amount);
67              emit ClaimRewards(rewardContract, market);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


149             emit OpenCurvePosition(pool, depositIndex, amount, minAmount);
174             emit DecreaseCurvePosition(pool, withdrawIndex, amount, minAmount);
184             emit WithdrawFromConvexBooster(pid, amount);
194             emit WithdrawFromConvexRewardPool(pool, amount);
204             emit WithdrawFromGauge(pool, amount);
214             emit WithdrawFromPrisma(depostiToken, amount);
226             emit HarvestRewards(gauges);
240             emit HarvestPrismaRewards(pools);
254             emit HarvestConvexRewards(rewardsPools);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


60              emit BorrowAndSupply(address(pool), borrowAmount, collateralAmount);
79              emit Withdraw(address(pool), withdrawAmount);
97              emit Repay(address(pool), sharesToRepay);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


33              emit OpenAccount(facade, ref);
51              emit CloseAccount(facade, creditAccount);
85              emit ExecuteCommands(facade, creditAccount, calls, approvalToken, amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


44              emit Deposit(amountIn);
62              emit RequestWithdrawals(amount);
86              emit ClaimWithdrawal(requestId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


71              emit Stake(amount, duration, doDelegation);
83              emit Unstake(lockupId);
107             emit AddLiquidityInMaverickPool(p);
130             emit RemoveLiquidityFromMaverickPool(p);
146             emit ClaimBoostedPositionRewards(rewardContract);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


49              emit Supply(amount, id, sOrC);
72              emit Withdraw(amount, id, sOrC);
87              emit Borrow(amount, id);
100             emit Repay(amount, id);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


33              emit SendPositionToMasterChef(tokenId);
43              emit UpdatePosition(tokenId);
53              emit Withdraw(tokenId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


89              emit Supply(market, syMinted);
101             emit MintPTAndYT(market, syAmount);
118             emit DepositIntoMarket(address(market), SYamount, PTamount);
129             emit DepositIntoPenpie(_market, _amount);
139             emit WithdrawFromPenpie(_market, _amount);
156             emit SwapYTForPT(market, exactYTIn, min, guess);
173             emit SwapYTForSY(market, exactYTIn, min, orderData);
195             emit SwapExactPTForSY(address(market), exactPTIn, swapData, minSY);
207             emit BurnLP(address(market), amount);
232             emit DecreasePosition(address(market), _amount, closePosition);
247             emit ClaimRewards(address(market));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


66              emit OpenTrove(address(zap), tm, maxFee, dAmount, bAmount);
85              emit AddColl(address(zapContract), tm, amountIn);
121             emit AdjustTrove(address(zapContract), tm, mFee, wAmount, bAmount, isBorrowing);
135             emit CloseTrove(address(zapContract), troveManager);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


41              emit Deposit(siloToken, dToken, amount, oC);
68              emit Withdraw(siloToken, wToken, amount, oC, closePosition);
89              emit Borrow(siloToken, bToken, amount);
106             emit Repay(siloToken, rToken, amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


69              emit DepositIntoStargatePool(depositRequest);
96              emit WithdrawFromStargatePool(withdrawRequest);
106             emit ClaimStargateRewards(poolId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


56              emit OpenPosition(p, tokenId);
80              emit DecreasePosition(p);
95              emit IncreasePosition(p);
107                 emit CollectFees(tokenIds[i]);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


55              emit UpdateOwners(_owners, addOrRemove);
66              emit UpdateThreshold(_threshold);
115             emit Execute(destination, data, gasLimit, executor, deadline);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


50              emit MinimumHealthFactorUpdated(_minimumHealthFactor);
60              emit SwapHandlerUpdated(_swapHandler);
69              emit ValueOracleUpdated(_valueOracle);
88              emit TransferTokensToTrustedAddress(token, amount, caller, data);
128             emit TransferPositionToConnector(tokens, amounts, connector, data);
143                 emit UpdateTokenInRegistry(token, remove);
192             emit AddLiquidity(tokens, amounts, data);
217                 emit SwapHoldings(tokensIn[i], tokensOut[i], amountsIn[i], swapData[i]);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


49              emit UpdateChainInfo(chainId, destinationAddress);
60              emit UpdateBridgeTransactionApproval(transactionHash, block.timestamp);
70              emit StartBridgeTransaction(bridgeRequest, txn);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


50              emit SetValueOracle(_valueOracle);
59              emit SetSlippageTolerance(address(0), address(0), _slippageTolerance);
73              emit SetSlippageTolerance(_inputToken, _outputToken, _slippageTolerance);
82              emit AddEligibleUser(_user);
117             emit ExecutionCompleted(
118                 _swapRequest.routeId, _swapRequest.amount, _amountOut, _swapRequest.inputToken, _swapRequest.outputToken
119             );
139             emit BridgeExecutionCompleted(_bridgeRequest);
150                 emit NewRouteAdded(i, _routes[i].route, _routes[i].isEnabled, _routes[i].isBridge);
160             emit RouteUpdate(_routeId, false);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


47              emit AddedHandler(_handler, state);
57              emit AddedChain(_chainId, state);
67              emit AddedBridgeBlacklist(bridgeName, state);
99              emit Swapped(balanceOut0, balanceOut1, _request.outputToken);
141             emit Bridged(_request.from, _request.inputToken, _request.amount, _request.data);
182             emit Forwarded(lifi, address(token), amount, data);
200             emit Rescued(token, userAddress, amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


44              emit UpdatedDefaultPriceSource(baseCurrencies, oracles);
58              emit UpdatedAssetPriceSource(asset, baseToken, oracle);
63              emit UpdatedPriceRoute(asset, base, s);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


61              emit ChainlinkPriceAgeThresholdUpdated(_chainlinkPriceAgeThreshold);
76                  emit AssetSourceUpdated(assets[i], baseTokens[i], sources[i]);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


41              emit NewPeriod(_period);
52              emit PoolsForAsset(tokenIn, baseToken, pool);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## G027 - Comparing to constant boolean:

There is no need to verify that `== true` or `== false` when the variable checked upon is a boolean as well. Instead simply check for `variable` or `!variable`.


```solidity
File: contracts/accountingManager/AccountingManager.sol


335             if (currentWithdrawGroup.isFullfilled == false && currentWithdrawGroup.isStarted == true) {
335             if (currentWithdrawGroup.isFullfilled == false && currentWithdrawGroup.isStarted == true) {
361             require(currentWithdrawGroup.isStarted == false && currentWithdrawGroup.isFullfilled == false);
361             require(currentWithdrawGroup.isStarted == false && currentWithdrawGroup.isFullfilled == false);
371             require(currentWithdrawGroup.isStarted == true && currentWithdrawGroup.isFullfilled == false);
371             require(currentWithdrawGroup.isStarted == true && currentWithdrawGroup.isFullfilled == false);
397             if (currentWithdrawGroup.isFullfilled == false) {
619                 currentWithdrawGroup.isStarted == false || currentWithdrawGroup.isFullfilled == true
619                 currentWithdrawGroup.isStarted == false || currentWithdrawGroup.isFullfilled == true


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


33              if (msg.sender != vaults[_vaultId].maintainer || hasRole(EMERGENCY_ROLE, msg.sender) == false) {
40              if (msg.sender != vaults[_vaultId].maintainerWithoutTimeLock && hasRole(EMERGENCY_ROLE, msg.sender) == false) {
47              if (msg.sender != vaults[_vaultId].governer && hasRole(EMERGENCY_ROLE, msg.sender) == false) {
251                 if (vault.connectors[calculatorConnector].enabled == false) revert NotExist();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


35              require(isHandler[msg.sender] == true, "LifiImplementation: INVALID_SENDER");
153             if (isBridgeWhiteListed[bridgeData.bridge] == false) revert BridgeBlacklisted();
154             if (isChainSupported[bridgeData.destinationChainId] == false) revert InvalidChainId();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

## G028 - Don't compare boolean expressions to boolean literals:

For cases of: `if (<x> == true)`, use `if (<x>)` instead. For cases of: `if (<x> == false)`, use `if (!<x>)` instead.


```solidity
File: contracts/accountingManager/AccountingManager.sol


335             if (currentWithdrawGroup.isFullfilled == false && currentWithdrawGroup.isStarted == true) {
335             if (currentWithdrawGroup.isFullfilled == false && currentWithdrawGroup.isStarted == true) {
361             require(currentWithdrawGroup.isStarted == false && currentWithdrawGroup.isFullfilled == false);
361             require(currentWithdrawGroup.isStarted == false && currentWithdrawGroup.isFullfilled == false);
371             require(currentWithdrawGroup.isStarted == true && currentWithdrawGroup.isFullfilled == false);
371             require(currentWithdrawGroup.isStarted == true && currentWithdrawGroup.isFullfilled == false);
397             if (currentWithdrawGroup.isFullfilled == false) {
619                 currentWithdrawGroup.isStarted == false || currentWithdrawGroup.isFullfilled == true
619                 currentWithdrawGroup.isStarted == false || currentWithdrawGroup.isFullfilled == true


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


33              if (msg.sender != vaults[_vaultId].maintainer || hasRole(EMERGENCY_ROLE, msg.sender) == false) {
40              if (msg.sender != vaults[_vaultId].maintainerWithoutTimeLock && hasRole(EMERGENCY_ROLE, msg.sender) == false) {
47              if (msg.sender != vaults[_vaultId].governer && hasRole(EMERGENCY_ROLE, msg.sender) == false) {
251                 if (vault.connectors[calculatorConnector].enabled == false) revert NotExist();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


35              require(isHandler[msg.sender] == true, "LifiImplementation: INVALID_SENDER");
153             if (isBridgeWhiteListed[bridgeData.bridge] == false) revert BridgeBlacklisted();
154             if (isChainSupported[bridgeData.destinationChainId] == false) revert InvalidChainId();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

## G029 - State variables only set in the constructor should be declared `immutable`:


        Avoids a Gsset (**20000 gas**) in the constructor, and replaces the first access in each transaction (Gcoldsload - **2100 gas**) and each access thereafter (Gwarmacces - **100 gas**) with a `PUSH32` (**3 gas**). 

        While `string`s are not value types, and therefore cannot be `immutable`/`constant` if not hard-coded outside of the constructor, the same behavior can be achieved by making the current contract `abstract` with `virtual` functions for the `string` accessors, and having a child contract override the functions with the hard-coded implementation-specific values.
        


<details>
<summary>Click to show 22 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


99              baseToken = IERC20(p._baseTokenAddress);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol


18              accountingManager = _accountingManager;
19              baseToken = _baseToken;
20              receiver = _receiver;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


44              aerodromeRouter = IRouter(_router);
45              voter = IVoter(_voter);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


48              AURA = aura;
49              BAL = bal;
50              balancerVault = _balancerVault;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


27              vault = IBalancerVault(_balancerVault);
28              registry = _registry;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


39              router = ICamelotRouter(_router);
40              factory = ICamelotFactory(_factory);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


56              convexBooster = IBooster(_convexBooster);
57              CVX = cvx;
58              CRV = crv;
59              PRISMA = prisma;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


25              depositWithdrawalProxy = IDepositWithdrawalProxy(_depositWithdrawalProxy);
26              dolomiteMargin = IDolomiteMargin(_dolomiteMargin);
27              borrowPositionProxy = IBorrowPositionProxyV1(_borrowPositionProxy);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


27              lido = _lido;
28              lidoWithdrawal = _lidoW;
29              steth = _steth;
30              weth = w;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


50              mav = _mav;
51              veMav = _veMav;
52              maverickRouter = mr;
53              positionInspector = IPositionInspector(pi);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/PancakeswapConnector.sol


23              masterchef = IMasterchefV3(MC);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PancakeswapConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


63              pendleMarketDepositHelper = IPendleMarketDepositHelper(_pendleMarketDepositHelper);
64              pendleRouter = IPAllActionV3(_pendleRouter);
65              staticRouter = IPendleStaticRouter(SR);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


22              SNXCoreProxy = IV3CoreProxy(_SNXCoreProxy);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


20              siloRepository = ISiloRepository(SR);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


39              LPStaking = IStargateLPStaking(lpStacking);
40              stargateRouter = IStargateRouter(_stargateRouter);
41              rewardToken = LPStaking.stargate();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/governance/NoyaGovernanceBase.sol


23              registry = _registry;
24              vaultId = _vaultId;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


23              registry = PositionRegistry(_registry);
24              vaultId = _vaultId;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


36              lzHelper = _lzHelper;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


29              lifi = _lifi;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


31              registry = _registry;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


48              registry = PositionRegistry(_reg);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


32              factory = _factory;
33              registry = _registry;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## G030 - Use `uint256(1)`/`uint256(2)` instead for `true` and `false` boolean states:

If you don't use boolean for storage you will avoid Gwarmaccess 100 gas. In addition, state changes of boolean from `true` to `false` can cost up to ~20000 gas rather than `uint256(2)` to `uint256(1)` that would cost significantly less.


```solidity
File: contracts/governance/Keepers.sol


10          mapping(address => bool) public isOwner;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


13          mapping(address => bool) public isEligibleToUse;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


13          mapping(address => bool) public isHandler;
14          mapping(string => bool) public isBridgeWhiteListed;
15          mapping(uint256 => bool) public isChainSupported;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

## G031 - Fewer storage slots can be used by storing timestamps in types smaller than uint256:

Ethereum's block.timestamp can be stored in a type smaller than uint256.   A uint32 variable can store a timestamp until year 2106.


```solidity
File: contracts/accountingManager/AccountingManager.sol


43          uint256 public profitStoredTime;
45          uint256 public lastFeeDistributionTime;
82          uint256 public depositWaitingTime = 30 minutes;
84          uint256 public withdrawWaitingTime = 6 hours;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

## G032 - Superfluous event fields:

`block.timestamp` and `block.number` are added to event information by default so adding them manually wastes gas.


```solidity
File: contracts/accountingManager/AccountingManager.sol


216             emit RecordDeposit(depositQueue.last, receiver, block.timestamp, amount, referrer);
242                 emit CalculateDeposit(
243                     middleTemp, data.receiver, block.timestamp, shares, data.amount, shares * 1e18 / data.amount
244                 );
274                 emit ExecuteDeposit(
275                     firstTemp, data.receiver, block.timestamp, data.shares, data.amount, data.shares * 1e18 / data.amount
276                 );
314             emit RecordWithdraw(withdrawQueue.last, msg.sender, receiver, share, block.timestamp);
349                 emit CalculateWithdraw(middleTemp, data.owner, data.receiver, data.shares, assets, block.timestamp);
429                 emit ExecuteWithdraw(
430                     firstTemp, data.owner, data.receiver, shares, data.amount, baseTokenAmount, block.timestamp
431                 );
485             emit RecordProfit(
486                 storedProfitForFee, totalProfitCalculated, preformanceFeeSharesWaitingForDistribution, block.timestamp
487             );
496                 emit ResetFee(currentProfit, storedProfitForFee, block.timestamp);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


60              emit UpdateBridgeTransactionApproval(transactionHash, block.timestamp);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

## G033 - `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops:

The `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves 30-40 gas [per loop](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked).


<details>
<summary>Click to show 19 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


551             for (uint256 i = 0; i < retrieveData.length; i++) {
603                 for (uint256 i = 0; i < items.length; i++) {
608                 for (uint256 i = 0; i < items.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


138             for (uint256 i = 0; i < _trustedTokens.length; i++) {
194             for (uint256 i = 0; i < _connectorAddresses.length; i++) {
214             for (uint256 i = 0; i < _tokens.length; i++) {
253                 for (uint256 i = 0; i < usingTokens.length; i++) {
274             for (uint256 i = 0; i < length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


54              for (uint256 i = 0; i < rewardsPools.length; i++) {
77              for (uint256 i = 0; i < tokens.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


74                  for (uint256 i = 0; i < tokens.length; i++) {
79                  for (uint256 i = 0; i < destinationConnector.length; i++) {
84                  for (uint256 i = 0; i < tokens.length; i++) {
89              for (uint256 i = 0; i < tokens.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


107             for (uint8 i; i < numberOfAssets; ++i) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


222             for (uint256 i = 0; i < gauges.length; i++) {
234             for (uint256 i = 0; i < pools.length; i++) {
248             for (uint256 i = 0; i < rewardsPools.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


113             for (uint256 i = 0; i < markets.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


69              for (uint256 i = 0; i < calls.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


140             for (uint256 i = 0; i < earnedInfo.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


244             for (uint256 i = 0; i < rewardTokens.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


116             for (uint256 i = 0; i < assets.length; i++) {
132             for (uint256 i = 0; i < assetsS.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


102             for (uint256 i = 0; i < tokenIds.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


29              for (uint256 i = 0; i < _owners.length; i++) {
44              for (uint256 i = 0; i < _owners.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


178             for (uint256 i = 0; i < tokens.length; i++) {
189             for (uint256 i = 0; i < tokens.length; i++) {
211             for (uint256 i = 0; i < tokensIn.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


41              for (uint256 i = 0; i < tokens.length; i++) {
46              for (uint256 i = 0; i < tokens.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


37              for (uint256 i = 0; i < usersAddresses.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/TVLHelper.sol


18              for (uint256 i = 0; i < positions.length; i++) {
44              for (uint256 i = 0; i < positions.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/TVLHelper.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


41              for (uint256 i = 0; i < baseCurrencies.length; i++) {
55              for (uint256 i = 0; i < oracle.length; i++) {
88              for (uint256 i = 0; i < sources.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


74              for (uint256 i = 0; i < assets.length; i++) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

</details>

## G034 - Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead:

> When using elements that are smaller than 32 bytes, your contract’s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.htmlEach operation involving a `uint8` costs an extra [**22-28 gas**](https://gist.github.com/IllIllI000/9388d20c70f9a4632eb3ca7836f54977) (depending on whether the other operand is also a variable of type `uint8`) as compared to ones involving `uint256`, due to the compiler having to clear the higher bits of the memory word before operating on the `uint8`, as well as the associated stack operations of doing so. Use a larger size then downcast where needed.


<details>
<summary>Click to show 4 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


228             uint64 i = 0;
264             uint64 i = 0;
330             uint64 i = 0;
400             uint64 i = 0;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


104             uint8 numberOfAssets = comet.numAssets();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


64              (uint128 currentLiquidity, address token0, address token1) = getCurrentLiquidity(p.tokenId);
138                 (uint128 liquidity,,, uint128 tokensOwed0, uint128 tokensOwed1) = pool.positions(key);
138                 (uint128 liquidity,,, uint128 tokensOwed0, uint128 tokensOwed1) = pool.positions(key);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


77              int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## G035 - Consider activating `via-ir` for deploying:


        The IR-based code generator was introduced with an aim to not only allow code generation to be more transparent and auditable but also to enable more powerful optimization passes that span across functions.

        You can enable it on the command line using `--via-ir` or with the option `{"viaIR": true}`.

        This will take longer to compile, but you can just simple test it before deploying and if you got a better benchmark then you can add --via-ir to your deploy command

        More on: https://docs.soliditylang.org/en/v0.8.17/ir-breaking-changes.html
        


```solidity
File: Various Files


None

```

## G036 - Emit Used In Loop:

Emitting an event inside a loop performs a LOG op N times, where N is the loop length. Consider refactoring the code to emit the event only once at the end of loop. Gas savings should be multiplied by the average loop length.


<details>
<summary>Click to show 6 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


562                 emit RetrieveTokensForWithdraw(


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


196                 emit ConnectorAdded(vaultId, _connectorAddresses[i]);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


107                 emit CollectFees(tokenIds[i]);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


217                 emit SwapHoldings(tokensIn[i], tokensOut[i], amountsIn[i], swapData[i]);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


150                 emit NewRouteAdded(i, _routes[i].route, _routes[i].isEnabled, _routes[i].isBridge);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


76                  emit AssetSourceUpdated(assets[i], baseTokens[i], sources[i]);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

</details>

## G037 - Calling External Function With this Keyword:

Calling an external function internally, through the use of this wastes the gas overhead of calling an external function (100 gas). Instead, change the function from external to public, and remove the this.


```solidity
File: contracts/connectors/MaverickConnector.sol


150             return this.onERC721Received.selector;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


65              return this.onERC721Received.selector;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

## G038 - `unchecked {}` can be used on the division of two `uints` in order to save gas:

The division cannot overflow, since both the numerator and the denominator are non-negative.


<details>
<summary>Click to show 11 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


416                     data.amount * currentWithdrawGroup.totalABAmount / currentWithdrawGroup.totalCBAmountFullfilled;
423                     uint256 feeAmount = baseTokenAmount * withdrawFee / FEE_PRECISION;
275                     firstTemp, data.receiver, block.timestamp, data.shares, data.amount, data.shares * 1e18 / data.amount
484                 previewDeposit(((storedProfitForFee - totalProfitCalculated) * performanceFee) / FEE_PRECISION);
243                     middleTemp, data.receiver, block.timestamp, shares, data.amount, shares * 1e18 / data.amount
518                 (timePassed * managementFee * (totalShares - currentFeeShares)) / FEE_PRECISION / 365 days;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


131             uint256 amount0 = balance * reserve0 / totalSupply;
132             uint256 amount1 = balance * reserve1 / totalSupply;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


172             return (((1e18 * token1bal * lpBalance) / _weight) / _totalSupply);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


96              return balanceThis * (_getValue(tokenA, base, reserves0) + _getValue(tokenB, base, reserves1)) / totalSupply;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


118                         collateralBalance * collateralPriceInVirtualBase * baseScale / info.scale / basePrice;
78              return getCollBlanace(comet, true) * 1e18 / borrowBalanceInBase;
89              borrowBalanceInVirtualBase = (borrowBalanceInBase * basePriceInVirtualBase) / comet.baseScale();
119                     if (riskAdjusted) CollValue += collateralValueInVirtualBase * info.liquidateCollateralFactor / 1e18;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


136             uint256 currentHF = (fraxlendPairMaxLTV * 1e18) / currentPositionLTV;
129                 (((_borrowerAmount * _exchangeRate) * LTV_PRECISION) / EXCHANGE_PRECISION) / _collateralAmount;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


138             return amount * IOracle(marketOracle).price() / ORACLE_PRICE_SCALE;
115             return market.lltv * convertCToL(p.collateral, market.oracle, market.collateralToken) / borrowAmount;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


275                 if (PTAmount > 0) SYAmount += PTAmount * IPMarket(market).getPtToAssetRate(10) / 1e18;
280                 if (SYAmount > 0) underlyingBalance += SYAmount * _SY.exchangeRate() / 1e18;
271                     SYAmount += lpBalance * IPMarket(market).getLpToAssetRate(10) / 1e18;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


125                 totalBAmount += borrowAmount * price / 1e18;
124                 totalDepositAmount += depositAmount * price / 1e18;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


112                 _swapRequest.minAmount = (((1e6 - _slippageTolerance) * _outputTokenValue) / 1e6);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


134             return (amountIn * uintprice) / (sourceTokenUnit);
132                 return (amountIn * sourceTokenUnit) / uintprice;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

</details>

## G039 - Low level call can be optimized with assembly:

Low level call can be optimized with assembly. The returnData is copied to memory even if the variable is not utilized: the proper way to handle this is through a low level assembly call.


<details>
<summary>Click to show 4 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


685                 (bool success,) = payable(msg.sender).call{ value: amount }("");


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


81                      (bool success,) = destinationConnector[i].call{ value: 0, gas: gas[i] }(callingData[i]);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


116             (bool success,) = destination.call{ gas: gasLimit }(data);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


195                 (bool success,) = payable(userAddress).call{ value: amount }("");


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

</details>

## G040 - Use assembly to calculate hashes to save gas:

Using assembly to calculate hashes can save 80 gas per instance


<details>
<summary>Click to show 4 findings</summary>

```solidity
File: contracts/accountingManager/Registry.sol


15          bytes32 public constant MAINTAINER_ROLE = keccak256("MAINTAINER_ROLE");
17          bytes32 public constant GOVERNER_ROLE = keccak256("GOVERNER_ROLE");
19          bytes32 public constant EMERGENCY_ROLE = keccak256("EMERGENCY_ROLE");
345             bytes32 holdingPositionId = keccak256(abi.encode(msg.sender, _positionId, _data));
351                     vault.isPositionUsed[keccak256(
352                         abi.encode(
353                             vault.holdingPositions[positionIndex].calculatorConnector,
354                             vault.holdingPositions[positionIndex].positionId,
355                             vault.holdingPositions[positionIndex].data
356                         )
357                     )] = positionIndex;
399             bytes32 holdingPositionId = keccak256(abi.encode(_connector, _positionId, data));
491             return keccak256(abi.encode(calculatorConnector, positionTypeId, data));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


136                 bytes32 key = keccak256(abi.encodePacked(positionManager, tL, tU));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


11          bytes32 public constant TXTYPE_HASH = keccak256(
12              "Execute(uint256 nonce,address destination,bytes data,uint256 gasLimit,address executor, uint256 deadline)"
13          );
101                     keccak256(abi.encode(TXTYPE_HASH, nonce, destination, data, gasLimit, executor, deadline));
102                 bytes32 totalHash = keccak256(abi.encodePacked("\x19\x01", _domainSeparatorV4(), txInputHash));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


69              bytes32 txn = keccak256(abi.encode(bridgeRequest));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

</details>

## G041 - Unused named return variables without optimizer waste gas:

Consider changing the variable to be an unnamed one, since the variable is never assigned, nor is it returned by name. If the optimizer is not turned on, leaving the code as it is will also waste gas for the stack variable.


<details>
<summary>Click to show 16 findings</summary>

```solidity
File: contracts/connectors/AaveConnector.sol


114         function _getPositionTVL(HoldingPI memory, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


88          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


265         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


106         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


150         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


93          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


91          function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


153         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


145         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


74              returns (uint256 userLTV, uint256 LiquidationThreshold, bool isSolvent)


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


110         function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


271         function _getPositionTVL(HoldingPI memory, address) public view virtual returns (uint256 tvl) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


189         function _isNative(IERC20 token) internal pure returns (bool isNative) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


84              returns (uint256 value)


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


143         function getSourceOfAsset(address asset, address baseToken) public view returns (address source, bool isInverse) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/WETH_Oracle.sol


8               returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/WETH_Oracle.sol#L0:0

</details>

## G042 - Avoid updating storage when the value hasn't changed:

If the old value is equal to the new value, not re-storing the value will avoid a Gsreset (**2900 gas**), potentially at the expense of a Gcoldsload (**2100 gas**) or a Gwarmaccess (**100 gas**).


<details>
<summary>Click to show 9 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


673         function changeDepositWaitingTime(uint256 _depositWaitingTime) public onlyMaintainer {
505         function collectManagementFees() public onlyManager nonReentrant returns (uint256, uint256) {
475         function recordProfitForFee() public onlyManager nonReentrant {
170         function setFees(uint256 _withdrawFee, uint256 _performanceFee, uint256 _managementFee) public onlyMaintainer {
370         function fulfillCurrentWithdrawGroup() public onlyManager nonReentrant whenNotPaused {
678         function changeWithdrawWaitingTime(uint256 _withdrawWaitingTime) public onlyMaintainer {
526         function collectPerformanceFees() public onlyManager nonReentrant {
667         function setDepositLimits(uint256 _depositLimitPerTransaction, uint256 _depositTotalAmount) public onlyMaintainer {
135         function setFeeReceivers(
493         function checkIfTVLHasDroped() public nonReentrant {
124         function updateValueOracle(INoyaValueOracle _valueOracle) public onlyMaintainer {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


79          function setMaxNumHoldingPositions(uint256 _maxNumHoldingPositions) external onlyRole(MAINTAINER_ROLE) {
84          function setFlashLoanAddress(address _flashLoan) external onlyRole(MAINTAINER_ROLE) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


37          function makeFlashLoan(IERC20[] memory tokens, uint256[] memory amounts, bytes memory userData)


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


63          function setThreshold(uint8 _threshold) public onlyOwner {
42          function updateOwners(address[] memory _owners, bool[] memory addOrRemove) public onlyOwner {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


67          function updateValueOracle(address _valueOracle) external onlyMaintainer {
45          function updateMinimumHealthFactor(uint256 _minimumHealthFactor) external onlyMaintainer {
58          function updateSwapHandler(address payable _swapHandler) external onlyMaintainer {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/LZHelpers/LZHelperSender.sol


36          function updateMessageSetting(bytes memory _messageSetting) public onlyOwner {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/LZHelpers/LZHelperSender.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


57          function setGeneralSlippageTolerance(uint256 _slippageTolerance) external onlyMaintainerOrEmergency {
48          function setValueOracle(address _valueOracle) external onlyMaintainerOrEmergency {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


56          function updateChainlinkPriceAgeThreshold(uint256 _chainlinkPriceAgeThreshold) external onlyMaintainer {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


38          function setPeriod(uint32 _period) external onlyMaintainer {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## G043 - Duplicated `require()`/`revert()` checks should be refactored to a modifier or function:

Saves deployment costs.


```solidity
File: contracts/accountingManager/Registry.sol


67              require(_governer != address(0));
68              require(_maintainer != address(0));
124             require(_keeperContract != address(0));
125             require(_watcher != address(0));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

## G044 - The use of a logical AND in place of double if is slightly less gas efficient in instances where there isn't a corresponding else statement for the given if statement:

Using a double if statement instead of logical AND (&&) can provide similar short-circuiting behavior whereas double if is slightly more efficient.


<details>
<summary>Click to show 12 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


186             if (!(from == address(0)) && balanceOf(from) < amount + withdrawRequestsByAddress[from]) {
288             if (registry.isAnActiveConnector(vaultId, connector) && processedBaseTokenAmount > 0) {
335             if (currentWithdrawGroup.isFullfilled == false && currentWithdrawGroup.isStarted == true) {
374             if (neededAssets != 0 && amountAskedForWithdraw != currentWithdrawGroup.totalCBAmount) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


40              if (msg.sender != vaults[_vaultId].maintainerWithoutTimeLock && hasRole(EMERGENCY_ROLE, msg.sender) == false) {
47              if (msg.sender != vaults[_vaultId].governer && hasRole(EMERGENCY_ROLE, msg.sender) == false) {
347             if (positionIndex == 0 && removePosition) return type(uint256).max;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


66              if (p.collateral == 0 && p.supplyShares == 0) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


223             if (closePosition && isMarketEmpty(market)) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


111             if (bAmount > 0 && !isBorrowing) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


60              if (closePosition && isSiloEmpty(silo)) {
120                 if (depositAmount == 0 && borrowAmount == 0) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


45                  if (addOrRemove[i] && !isOwner[_owners[i]]) {
48                  } else if (!addOrRemove[i] && isOwner[_owners[i]]) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/governance/NoyaGovernanceBase.sol


55              if (msg.sender != emergencyManager && msg.sender != watcherContract) {
67              if (msg.sender != maintainer && msg.sender != emergencyManager) revert NoyaGovernance_Unauthorized(msg.sender);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


142             if ((positionIndex == 0 && !remove) || (positionIndex > 0 && remove)) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


86              if ((positionIndex == 0 && !remove) || (positionIndex > 0 && remove)) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


30              if (routes[_routeId].route == address(0) && !routes[_routeId].isEnabled) revert RouteNotFound();
102             if (_swapRequest.checkForSlippage && _swapRequest.minAmount == 0) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


82              if (tickCumulativesDelta < 0 && (tickCumulativesDelta % int56(int32(period)) != 0)) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## G045 - Use the inputs/results of assignments rather than re-reading state variables:

When a state variable is assigned, it saves gas to use the value being assigned, later in the function, rather than re-reading the state variable itself. If needed, it can also be stored to a local variable, and be used in that way. Both options avoid a Gwarmaccess (100 gas). Note that if the operation is, say +=, the assignment also results in a value which can be used. The instances below point to the first reference after the assignment, since later references are already covered by issues describing the caching of state variable values.


<details>
<summary>Click to show 14 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


227             uint256 middleTemp = depositQueue.middle;
263             uint256 firstTemp = depositQueue.first;
329             uint256 middleTemp = withdrawQueue.middle;
335             if (currentWithdrawGroup.isFullfilled == false && currentWithdrawGroup.isStarted == true) {
364             emit WithdrawGroupStarted(currentWithdrawGroup.lastId, currentWithdrawGroup.totalCBAmount);
364             emit WithdrawGroupStarted(currentWithdrawGroup.lastId, currentWithdrawGroup.totalCBAmount);
364             emit WithdrawGroupStarted(currentWithdrawGroup.lastId, currentWithdrawGroup.totalCBAmount);
364             emit WithdrawGroupStarted(currentWithdrawGroup.lastId, currentWithdrawGroup.totalCBAmount);
381                 currentWithdrawGroup.totalABAmount = currentWithdrawGroup.totalCBAmount;
385             currentWithdrawGroup.totalCBAmountFullfilled = currentWithdrawGroup.totalCBAmount;
388                 currentWithdrawGroup.lastId, currentWithdrawGroup.totalCBAmount, currentWithdrawGroup.totalABAmount
388                 currentWithdrawGroup.lastId, currentWithdrawGroup.totalCBAmount, currentWithdrawGroup.totalABAmount
381                 currentWithdrawGroup.totalABAmount = currentWithdrawGroup.totalCBAmount;
385             currentWithdrawGroup.totalCBAmountFullfilled = currentWithdrawGroup.totalCBAmount;
388                 currentWithdrawGroup.lastId, currentWithdrawGroup.totalCBAmount, currentWithdrawGroup.totalABAmount
388                 currentWithdrawGroup.lastId, currentWithdrawGroup.totalCBAmount, currentWithdrawGroup.totalABAmount
388                 currentWithdrawGroup.lastId, currentWithdrawGroup.totalCBAmount, currentWithdrawGroup.totalABAmount
380             if (availableAssets >= currentWithdrawGroup.totalCBAmount) {
397             if (currentWithdrawGroup.isFullfilled == false) {
455                 emit ResetMiddle(newMiddle, depositQueue.middle, depositOrWithdraw);
462                 emit ResetMiddle(newMiddle, withdrawQueue.middle, depositOrWithdraw);
457                 if (newMiddle > depositQueue.middle || newMiddle < depositQueue.first) {
486                 storedProfitForFee, totalProfitCalculated, preformanceFeeSharesWaitingForDistribution, block.timestamp
486                 storedProfitForFee, totalProfitCalculated, preformanceFeeSharesWaitingForDistribution, block.timestamp
486                 storedProfitForFee, totalProfitCalculated, preformanceFeeSharesWaitingForDistribution, block.timestamp
486                 storedProfitForFee, totalProfitCalculated, preformanceFeeSharesWaitingForDistribution, block.timestamp
479             if (storedProfitForFee < totalProfitCalculated) {
496                 emit ResetFee(currentProfit, storedProfitForFee, block.timestamp);
514             uint256 currentFeeShares = balanceOf(managementFeeReceiver) + balanceOf(performanceFeeReceiver)
534             _mint(performanceFeeReceiver, preformanceFeeSharesWaitingForDistribution);
619                 currentWithdrawGroup.isStarted == false || currentWithdrawGroup.isFullfilled == true


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


47              _approveOperations(supplyToken, pool, amount);
70              IPool(pool).borrow(_borrowAsset, _amount, _interestRateMode, 0, address(this));
82              _approveOperations(asset, pool, amount);
101             IPool(pool).withdraw(_collateral, _collateralAmount, address(this));


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


55              _approveOperations(IPool(data.pool).token0(), address(aerodromeRouter), data.amount0);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


73                  (tokens,,) = IBalancerVault(balancerVault).getPoolTokens(poolId);
75              address pool = IBalancerVault(balancerVault).getPool(poolId);
125                     (tokens,,) = IBalancerVault(balancerVault).getPoolTokens(p.poolId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


71                  revert Unauthorized(caller);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


44              _approveOperations(p.tokenA, address(router), p.amountA);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


38              IWETH(weth).withdraw(amountIn);
52              _approveOperations(steth, lidoWithdrawal, amount);
52              _approveOperations(steth, lidoWithdrawal, amount);
71              ILidoWithdrawal(lidoWithdrawal).approve(lidoWithdrawal, requestId);
71              ILidoWithdrawal(lidoWithdrawal).approve(lidoWithdrawal, requestId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


66              _approveOperations(mav, veMav, amount);
66              _approveOperations(mav, veMav, amount);
80              IveMAV(veMav).unstake(lockupId);
93              _approveOperations(p.pool.tokenA(), maverickRouter, p.tokenARequiredAllowance); // TODO: check token A is eth
120             IMaverickPosition position = IMaverickRouter(maverickRouter).position();


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


38                  _approveOperations(params.loanToken, address(morphoBlue), amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


45              _approveOperations(p.token0, address(positionManager), p.amount0Desired);
90              _approveOperations(token0, address(positionManager), p.amount0Desired);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


53              require(numOwnersTemp <= 10 && threshold <= numOwnersTemp && threshold > 1);
95              require(sigR.length == threshold, "Not enough signatures");


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


80              (address accountingManager,) = registry.getVaultAddresses(vaultId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


173                 _setAllowance(token, lifi, amount);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


70              secondsAgos[0] = period;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## G046 - Avoid fetching a low-level call's return data by using assembly:

Even if you don't assign the call's second return value, it still gets copied to memory. Use assembly instead to prevent this and save 159 gas.


<details>
<summary>Click to show 4 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


685                 (bool success,) = payable(msg.sender).call{ value: amount }("");


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


81                      (bool success,) = destinationConnector[i].call{ value: 0, gas: gas[i] }(callingData[i]);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


116             (bool success,) = destination.call{ gas: gasLimit }(data);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


176             (bool success, bytes memory err) = lifi.call{ value: msg.value }(data);
195                 (bool success,) = payable(userAddress).call{ value: amount }("");


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

</details>

## G047 - Using msg globals directly, rather than caching the value, saves gas:

For example, use msg.sender directly rather than storing it to a local variable


<details>
<summary>Click to show 4 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


101             lastFeeDistributionTime = block.timestamp;
521             lastFeeDistributionTime = block.timestamp;
477             profitStoredTime = block.timestamp;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


41              caller = msg.sender;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


59              else approvedBridgeTXN[transactionHash] = block.timestamp;
59              else approvedBridgeTXN[transactionHash] = block.timestamp;
59              else approvedBridgeTXN[transactionHash] = block.timestamp;
59              else approvedBridgeTXN[transactionHash] = block.timestamp;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/TVLHelper.sol


50                  latestUpdateTime = block.timestamp;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/TVLHelper.sol#L0:0

</details>

## G048 - State variable read in a loop:

The state variable should be cached in and read from a local variable, or accumulated in a local variable then written to storage once outside of the loop, rather than reading/updating it on every iteration of the loop, which will replace each Gwarmaccess (100 gas) with a much cheaper stack read.


<details>
<summary>Click to show 6 findings</summary>

```solidity
File: contracts/accountingManager/AccountingManager.sol


555                 uint256 balanceBefore = baseToken.balanceOf(address(this));
604                     depositData[i] = depositQueue.queue[items[i]];
609                     withdrawData[i] = withdrawQueue.queue[items[i]];


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


78                  if (amounts[i] > 0) _approveOperations(tokens[i], balancerVault, amounts[i]);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/governance/Keepers.sol


30                  isOwner[_owners[i]] = true;
45                  if (addOrRemove[i] && !isOwner[_owners[i]]) {
104                 for (uint256 i = 0; i < threshold;) {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/Keepers.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol


38                  isEligibleToUse[usersAddresses[i]] = true;
149                 routes.push(_routes[i]);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/GenericSwapAndBridgeHandler.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


42                  defaultPriceSource[baseCurrencies[i]] = oracles[i];
56                  priceSource[asset[i]][baseToken[i]] = INoyaValueOracle(oracle[i]);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


75                  assetsSources[assets[i]][baseTokens[i]] = sources[i];


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

</details>

## G049 - Storage re-read via storage pointer:

The instances below point to the second+ access of a state variable, via a storage pointer, within a function. Caching the value replaces each Gwarmaccess (100 gas) with a much cheaper stack read.


```solidity
File: contracts/accountingManager/Registry.sol


350                     vault.holdingPositions[positionIndex] = vault.holdingPositions[vault.holdingPositions.length - 1];


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

## G050 - State variables only set in their definitions should be declared constant:

Avoids a Gsset (20000 gas) at deployment, and replaces the first access in each transaction (Gcoldsload - 2100 gas) and each access thereafter (Gwarmacces - 100 gas) with a PUSH32 (3 gas).


<details>
<summary>Click to show 28 findings</summary>

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol




```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/connectors/AaveConnector.sol


28          event Repay(address repayToken, uint256 amount, uint256 i);
31      


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AaveConnector.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


28          using SafeERC20 for IERC20;
31          uint256 public constant AERODROME_POSITION_TYPE = 1;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerConnector.sol


28      
31      


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


23      
28              registry = _registry;
31          /**


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


28      }
31          ICamelotRouter public router;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/CompoundConnector.sol


28           */
31              if (!registry.isTokenTrusted(vaultId, asset, address(this))) revert IConnector_UntrustedToken(asset);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CompoundConnector.sol#L0:0

```solidity
File: contracts/connectors/CurveConnector.sol


28          address public CRV;
31          uint256 public constant CURVE_LP_POSITION = 4;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CurveConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


28          }
31              // get market token


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/FraxConnector.sol


28      
31          // ------------ Connector functions -------------- //


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/FraxConnector.sol#L0:0

```solidity
File: contracts/connectors/GearBoxV3.sol


28                  registry.calculatePositionId(address(this), GEARBOX_POSITION_ID, abi.encode(facade)),
31                  false


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/GearBoxV3.sol#L0:0

```solidity
File: contracts/connectors/LidoConnector.sol


28              lidoWithdrawal = _lidoW;
31          }


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/LidoConnector.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


28      
31          address veMav;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/MorphoBlueConnector.sol


28          // ------------ Connector functions -------------- //
31           * @param amount - amount of tokens to supply


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MorphoBlueConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


28          /**
31           * @param minSY The minimum acceptable amount of SY tokens specified for the swap


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/PrismaConnector.sol


28           * @param zap The address of the StakeNTroveZap contract
31           */


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PrismaConnector.sol#L0:0

```solidity
File: contracts/connectors/SNXConnector.sol


28          }
31              // Deposit


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SNXConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


31           */


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/connectors/StargateConnector.sol


28          event DepositIntoStargatePool(StargateRequest depositRequest);
31      


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/StargateConnector.sol#L0:0

```solidity
File: contracts/connectors/UNIv3Connector.sol


28              BaseConnector(baseConnectorParams)
31              factory = IUniswapV3Factory(_factory);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/UNIv3Connector.sol#L0:0

```solidity
File: contracts/governance/NoyaGovernanceBase.sol


23              registry = _registry;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L0:0

```solidity
File: contracts/helpers/BaseConnector.sol


28          uint256 public MINIMUM_HEALTH_FACTOR = 15e17;
31          uint256 public DUST_LEVEL = 1;
23          using SafeERC20 for IERC20;
16          PositionRegistry registry;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/BaseConnector.sol#L0:0

```solidity
File: contracts/helpers/ConnectorMock2.sol


23              registry = PositionRegistry(_registry);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/ConnectorMock2.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


16      
28          /**
31           * @param baseConnectorParams Parameters for initializing the base connector functionalities


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/TVLHelper.sol


23                  bool isPositionDebt = registry.isPositionDebt(vaultId, positions[i].positionId);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/TVLHelper.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


23      


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


23          * @notice The addresses that represents ETH and USD


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


23      


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## G051 - State variables only set in the constructor should be declared immutable:

Avoids a Gsset (20000 gas) in the constructor, and replaces the first access in each transaction (Gcoldsload - 2100 gas) and each access thereafter (Gwarmacces - 100 gas) with a PUSH32 (3 gas).  While strings are not value types, and therefore cannot be immutable/constant if not hard-coded outside of the constructor, the same behavior can be achieved by making the current contract abstract with virtual functions for the string accessors, and having a child contract override the functions with the hard-coded implementation-specific values.


<details>
<summary>Click to show 13 findings</summary>

```solidity
File: contracts/accountingManager/NoyaFeeReceiver.sol




```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/NoyaFeeReceiver.sol#L0:0

```solidity
File: contracts/connectors/AerodromeConnector.sol


34          IVoter voter;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/AerodromeConnector.sol#L0:0

```solidity
File: contracts/connectors/BalancerFlashLoan.sol


16          PositionRegistry public registry;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/BalancerFlashLoan.sol#L0:0

```solidity
File: contracts/connectors/CamelotConnector.sol


32          ICamelotFactory public factory;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/CamelotConnector.sol#L0:0

```solidity
File: contracts/connectors/Dolomite.sol


12          IDepositWithdrawalProxy public depositWithdrawalProxy;
14          IBorrowPositionProxyV1 public borrowPositionProxy;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/Dolomite.sol#L0:0

```solidity
File: contracts/connectors/MaverickConnector.sol


33          IPositionInspector positionInspector;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/MaverickConnector.sol#L0:0

```solidity
File: contracts/connectors/PendleConnector.sol


24          IPendleStaticRouter public staticRouter;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/PendleConnector.sol#L0:0

```solidity
File: contracts/connectors/SiloConnector.sol


28           * @param dToken - token to deposit


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/connectors/SiloConnector.sol#L0:0

```solidity
File: contracts/governance/NoyaGovernanceBase.sol


7           PositionRegistry public registry;
8           uint256 public vaultId;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/governance/NoyaGovernanceBase.sol#L0:0

```solidity
File: contracts/helpers/OmniChainHandler/OmnichainLogic.sol


17          address payable public lzHelper;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/OmniChainHandler/OmnichainLogic.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/NoyaValueOracle.sol


11          PositionRegistry public registry;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/NoyaValueOracle.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol


11          PositionRegistry public registry;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/ChainlinkOracleConnector.sol#L0:0

```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


17          PositionRegistry public registry;


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

</details>

## G052 - State variables can be packed into fewer storage slots:

If variables occupying the same slot are both written in the same function or by the constructor, avoids a separate Gsset (20000 gas). Reads of the variables can also be cheaper


```solidity
File: contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol


12      contract UniswapValueOracle is INoyaValueOracle {


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/valueOracle/oracles/UniswapValueOracle.sol#L0:0

## G053 - Use local variables for emitting:

Use the function/modifier's local copy of the state variable, rather than incurring an extra Gwarmaccess (100 gas). In the unlikely event that the state variable hasn't already been used by the function/modifier, consider whether it is really necessary to include it in the event, given the fact that it incurs a Gcoldsload (2100 gas), or whether it can be passed in to or back out of the functions that do use it


```solidity
File: contracts/accountingManager/AccountingManager.sol


216             emit RecordDeposit(depositQueue.last, receiver, block.timestamp, amount, referrer);
314             emit RecordWithdraw(withdrawQueue.last, msg.sender, receiver, share, block.timestamp);
364             emit WithdrawGroupStarted(currentWithdrawGroup.lastId, currentWithdrawGroup.totalCBAmount);
364             emit WithdrawGroupStarted(currentWithdrawGroup.lastId, currentWithdrawGroup.totalCBAmount);
388                 currentWithdrawGroup.lastId, currentWithdrawGroup.totalCBAmount, currentWithdrawGroup.totalABAmount
388                 currentWithdrawGroup.lastId, currentWithdrawGroup.totalCBAmount, currentWithdrawGroup.totalABAmount
388                 currentWithdrawGroup.lastId, currentWithdrawGroup.totalCBAmount, currentWithdrawGroup.totalABAmount
455                 emit ResetMiddle(newMiddle, depositQueue.middle, depositOrWithdraw);
462                 emit ResetMiddle(newMiddle, withdrawQueue.middle, depositOrWithdraw);
486                 storedProfitForFee, totalProfitCalculated, preformanceFeeSharesWaitingForDistribution, block.timestamp
486                 storedProfitForFee, totalProfitCalculated, preformanceFeeSharesWaitingForDistribution, block.timestamp
486                 storedProfitForFee, totalProfitCalculated, preformanceFeeSharesWaitingForDistribution, block.timestamp
496                 emit ResetFee(currentProfit, storedProfitForFee, block.timestamp);
538             emit CollectPerformanceFee(preformanceFeeSharesWaitingForDistribution);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/AccountingManager.sol#L0:0

```solidity
File: contracts/accountingManager/Registry.sol


85              emit updateFlashloanAddress(_flashLoan, flashLoan);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/accountingManager/Registry.sol#L0:0

```solidity
File: contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol


182             emit Forwarded(lifi, address(token), amount, data);


```

https://github.com/code-423n4/2024-04-noya/tree/main/contracts/helpers/SwapHandler/Implementaions/LifiImplementation.sol#L0:0

